{"remainingRequest":"/home/mobiotics/Projects/hancom/formcontrols/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/mobiotics/Projects/hancom/formcontrols/src/FormDesigner/components/atoms/FDCheckBox/index.vue?vue&type=style&index=0&id=0ecd7903&scoped=true&lang=css&","dependencies":[{"path":"/home/mobiotics/Projects/hancom/formcontrols/src/FormDesigner/components/atoms/FDCheckBox/index.vue","mtime":1610977855600},{"path":"/home/mobiotics/Projects/hancom/formcontrols/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/mobiotics/Projects/hancom/formcontrols/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/home/mobiotics/Projects/hancom/formcontrols/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/home/mobiotics/Projects/hancom/formcontrols/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/mobiotics/Projects/hancom/formcontrols/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCiogewogIGJveC1zaXppbmc6IGJvcmRlci1ib3g7Cn0KCi5vdXRlci1jaGVjayB7CiAgaGVpZ2h0OiAwcHg7CiAgd2lkdGg6IDBweDsKICBsZWZ0OiAwcHg7CiAgdG9wOiAwcHg7CiAgbWluLXdpZHRoOiAxMnB4OwogIG1pbi1oZWlnaHQ6IDEzcHg7CiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDIzOCwgMjM4LCAyMzgpOwogIGJveC1zaGFkb3c6IC0xcHggLTFweCBncmF5OwogIG92ZXJmbG93OiBoaWRkZW47CiAgYWxpZ24taXRlbXM6IGNlbnRlcjsKICBib3gtc2l6aW5nOiBib3JkZXItYm94Owp9CgoudmlzdWFsbHktaGlkZGVuIHsKICBib3JkZXI6IDA7CiAgY2xpcDogcmVjdCgwLCAwLCAwLCAwKTsKICBoZWlnaHQ6IDFweDsKICBtYXJnaW46IC0xcHg7CiAgb3ZlcmZsb3c6IGhpZGRlbjsKICBwYWRkaW5nOiAwOwogIHBvc2l0aW9uOiBhYnNvbHV0ZTsKICB3aWR0aDogMXB4Owp9CgouY29udHJvbCB7CiAgZGlzcGxheTogaW5saW5lLWZsZXg7CiAgcG9zaXRpb246IHN0aWNreTsKICB0b3A6IDQ3JTsKfQoKLmNvbnRyb2wtaW5kaWNhdG9yIHsKICB3aWR0aDogMTBweDsKICBoZWlnaHQ6IDEwcHg7CiAgbWFyZ2luOiAxcHg7CiAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7CiAgYm9yZGVyOiAxcHggaW5zZXQgZ3JleTsKfQoKLmNvbnRyb2wtaW5wdXQ6Y2hlY2tlZCB+IC5jb250cm9sLWluZGljYXRvciB7CiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKC4uLy4uLy4uLy4uL2Fzc2V0cy9jaGVja21hcmsucG5nKTsKICBiYWNrZ3JvdW5kLXNpemU6IDEwcHg7CiAgYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyOwogIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7Cn0KCi5zcGFuU3R5bGUgewogIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lOwogIHRleHQtdW5kZXJsaW5lLXBvc2l0aW9uOiB1bmRlcjsKfQoKLm1lbnUgewogIHdpZHRoOiAxMCU7CiAgbWFyZ2luOiAwIGF1dG87Cn0KCi5tYWluIHsKICB3aWR0aDogOTAlOwogIG1hcmdpbjogMCBhdXRvOwp9CgojbG9nb3sKIGRpc3BsYXk6IGlubGluZS1mbGV4OwoganVzdGlmeS1jb250ZW50OiBjZW50ZXI7Cn0K"},{"version":3,"sources":["index.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwmBA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"index.vue","sourceRoot":"src/FormDesigner/components/atoms/FDCheckBox","sourcesContent":["<template>\n  <div\n    :title=\"properties.ControlTipText\"\n    class=\"outer-check\"\n    :style=\"cssStyleProperty\"\n    @click.stop=\"checkBoxClick\"\n    @keydown.enter.prevent=\"setContentEditable($event, true)\"\n    :tabindex=\"properties.TabIndex\"\n  >\n    <label class=\"control\" :style=\"controlStyleObj\" v-if=\"properties.Alignment === 1\">\n      <input\n        @change=\"handleChange($event, checkboxInput)\"\n        ref=\"checkboxInput\"\n        :name=\"properties.Name\"\n        :tabindex=\"properties.TabIndex\"\n        :disabled=\"getDisableValue\"\n        type=\"checkbox\"\n        class=\"control-input visually-hidden\" />\n      <span\n        class=\"control-indicator\"\n        :style=\"controlIndicatorStyleObj\"\n        ref=\"spanRef\"\n      ></span\n    ></label>\n    <div  v-if=\"properties.Alignment === 1\">\n      <div id=\"logo\" :style=\"reverseStyle\">\n      <img v-if=\"properties.Picture\" id=\"img\" :src=\"properties.Picture\" :style=\"imageProperty\">\n        <div ref=\"divAutoSize\"\n          v-if=\"!syncIsEditMode || isRunMode\"\n          @click=\"isRunMode && makeChecked($event)\"\n          :style=\"labelStyle\"\n        >\n          <span>{{ computedCaption.afterbeginCaption }}</span>\n          <span class=\"spanStyle\">{{\n            computedCaption.acceleratorCaption\n          }}</span>\n          <span>{{ computedCaption.beforeendCaption }}</span>\n        </div>\n        <FDEditableText\n          v-else\n          ref=\"checkBoxSpanRef\"\n          :editable=\"isRunMode === false && syncIsEditMode\"\n          :caption=\"properties.Caption\"\n          :style=\"labelStyle\"\n          @updateCaption=\"updateCaption\"\n          @releaseEditMode=\"releaseEditMode\"\n        >\n        </FDEditableText>\n      </div>\n    </div>\n    <div  v-if=\"properties.Alignment === 0\">\n      <div id=\"logo\" :style=\"reverseStyle\">\n      <img v-if=\"properties.Picture\" id=\"img\" :src=\"properties.Picture\" :style=\"imageProperty\">\n        <div\n          ref=\"divAutoSize\"\n          v-if=\"!syncIsEditMode || isRunMode\"\n          @click=\"isRunMode && makeChecked($event)\"\n          :style=\"labelStyle\"\n        >\n          <span>{{ computedCaption.afterbeginCaption }}</span>\n          <span class=\"spanStyle\">{{\n            computedCaption.acceleratorCaption\n          }}</span>\n          <span>{{ computedCaption.beforeendCaption }}</span>\n        </div>\n        <FDEditableText\n          v-else\n          ref=\"checkBoxSpanRef\"\n          :editable=\"isRunMode === false && syncIsEditMode\"\n          :caption=\"properties.Caption\"\n          :style=\"labelStyle\"\n          @updateCaption=\"updateCaption\"\n          @releaseEditMode=\"releaseEditMode\"\n        >\n        </FDEditableText>\n      </div>\n    </div>\n    <label class=\"control\" :style=\"controlStyleObj\" v-if=\"properties.Alignment === 0\">\n      <input\n        @change=\"handleChange($event, checkboxInput)\"\n        ref=\"checkboxInput\"\n        :name=\"properties.Name\"\n        :tabindex=\"properties.TabIndex\"\n        :disabled=\"getDisableValue\"\n        type=\"checkbox\"\n        class=\"control-input visually-hidden\" />\n      <span\n        class=\"control-indicator\"\n        :style=\"controlIndicatorStyleObj\"\n        ref=\"spanRef\"\n      ></span\n    ></label>\n  </div>\n</template>\n\n<script lang=\"ts\">\n/*eslint-disable */\nimport { Component, Ref, Mixins, Watch, Vue } from 'vue-property-decorator'\nimport FdControlVue from '@/api/abstract/FormDesigner/FdControlVue'\nimport FDEditableText from '@/FormDesigner/components/atoms/FDEditableText/index.vue'\n\n@Component({\n  name: 'FDCheckBox',\n  components: {\n    FDEditableText\n  }\n})\nexport default class FDCheckBox extends Mixins(FdControlVue) {\n  @Ref('checkboxInput') checkboxInput!: HTMLInputElement;\n  @Ref('divAutoSize') autoSizecheckbox!: HTMLDivElement;\n  @Ref('spanRef') spanRef!: HTMLSpanElement;\n  @Ref('checkBoxSpanRef') checkBoxSpanRef!: FDEditableText\n  $el: HTMLDivElement\n  alignItem: boolean = false\n  labelStyle = {}\n  reverseStyle = {\n   display : '',\n   flexDirection : '',\n   justifyItems : '',\n   position:'',\n   justifyContent:'center',\n   alignItems: '',\n   width:''\n  }\n  imageProperty={}\n  get controlStyleObj () {\n    const controlProp = this.properties\n    return {\n      position: 'sticky',\n      top: `${controlProp.Height! / 2 - 10}px`\n    }\n  }\n  /**\n   * @description  watches Enabled property and the sets the backgroundColor\n   * @function checkEnabled\n   */\n  @Watch('properties.Enabled', {\n    deep: true\n  })\n  checkEnabled (newVal: boolean, oldVal: boolean) {\n    if (!this.properties.Enabled) {\n      this.spanRef.style.backgroundColor = 'rgba(220, 220, 220, 1)'\n    } else {\n      this.spanRef.style.backgroundColor = 'white'\n    }\n  }\n\n  /**\n   * @description  watches Value property and the sets the checked\n   * @function verifyValue\n   */\n  @Watch('properties.Value', {\n    deep: true\n  })\n  verifyValue () {\n    if (this.isRunMode) {\n      if (this.properties.Enabled && !this.properties.Locked) {\n        this.handleValue(this.properties.Value! as string)\n      }\n    } else {\n      this.handleValue(this.properties.Value! as string)\n    }\n  }\n\n  handleValue (newVal: string) {\n    let tempValue = newVal.toLowerCase()\n    const checkDiv = this.checkboxInput\n    if (!isNaN(parseInt(newVal))) {\n      if (parseInt(newVal) === 0) {\n        this.spanRef.style.backgroundColor = 'white'\n        checkDiv.checked = false\n      } else {\n        this.spanRef.style.backgroundColor = 'white'\n        checkDiv.checked = true\n      }\n    } else if (tempValue === 'true') {\n      this.spanRef.style.backgroundColor = 'white'\n      checkDiv.checked = true\n    } else if (tempValue === 'false') {\n      this.spanRef.style.backgroundColor = 'white'\n      checkDiv.checked = false\n    } else {\n      checkDiv.checked = true\n      this.spanRef.style.backgroundColor = 'rgba(220, 220, 220, 1)'\n    }\n  }\n  /**\n   * @description  makeChecked controls the checked of the control in RunMode\n   * @function makeChecked\n   */\n  makeChecked () {\n    if (!this.getDisableValue) {\n      this.tripleState += 1\n      const checkDiv = this.checkboxInput\n      if (!this.properties.TripleState) {\n        checkDiv.checked = !checkDiv.checked\n        const tempval = checkDiv.checked\n        this.updateDataModel({ propertyName: 'Value', value: tempval })\n      } else {\n        if (this.tripleState % 3 === 0) {\n          checkDiv.checked = true\n          this.spanRef.style.backgroundColor = 'rgba(220, 220, 220, 1)'\n        } else {\n          this.spanRef.style.backgroundColor = 'white'\n          checkDiv.checked = !checkDiv.checked\n          this.updateDataModel({\n            propertyName: 'Value',\n            value: checkDiv.checked\n          })\n        }\n      }\n    }\n  }\n\n  /**\n   * @description getDisableValue checks for the RunMode of the control and then returns after checking for the Enabled\n   * and the Locked property\n   * @function getDisableValue\n   */\n  get getDisableValue () {\n    if (this.isRunMode) {\n      return this.properties.Enabled === false || this.properties.Locked\n    } else {\n      return true\n    }\n  }\n\n  /**\n   * @description style object is passed to :style attribute in span tag\n   * dynamically changing the styles of the component based on properties\n   * @function controlIndicatorStyleObj\n   *\n   */\n  get controlIndicatorStyleObj () {\n    const controlProp = this.properties\n    return {\n      boxShadow:\n        controlProp.SpecialEffect === 0 ? '0px 0px gray' : '-1px -1px gray'\n    }\n  }\n\n  /**\n   * @description style object is passed to :style attribute in label tag\n   * dynamically changing the styles of the component based on properties\n   * @function cssStyleProperty\n   *\n   */\n  get cssStyleProperty () {\n    const controlProp = this.properties\n    this.reverseStyle.justifyContent = \"center\"\n    if(!controlProp.Picture){\n    this.reverseStyle.justifyContent = \n    controlProp.TextAlign === 0 ? 'flex-start': controlProp.TextAlign === 1 ? 'center' : 'flex-end'\n    }else{\n    this.positionLogo(controlProp.PicturePosition)\n    }\n    const font: font = controlProp.Font\n      ? controlProp.Font\n      : {\n        FontName: 'Arial',\n        FontSize: 20,\n        FontItalic: true,\n        FontBold: true,\n        FontUnderline: true,\n        FontStrikethrough: true\n      }\n    let display = ''\n    if (this.isRunMode) {\n      display = controlProp.Visible ? 'grid' : 'none'\n    } else {\n      display = 'grid'\n    }\n    let alignItems = 'center'\n    if(controlProp.Picture){\n      let labelStyle = document.getElementById('logo')\n      if (this.properties.Height! < labelStyle!.clientHeight) {\n         alignItems = 'normal'\n      }\n    }\n\n    return {\n      left: `${controlProp.Left}px`,\n      width: `${controlProp.Width}px`,\n      height: `${controlProp.Height}px`,\n      top: `${controlProp.Top}px`,\n      backgroundColor: controlProp.BackStyle\n        ? controlProp.BackColor\n        : 'transparent',\n      borderColor: controlProp.BorderColor,\n      textAlign:\n        controlProp.TextAlign === 0\n          ? 'left'\n          : controlProp.TextAlign === 1\n            ? 'center'\n            : 'right',\n      border: this.getBorderStyle,\n      whiteSpace: controlProp.WordWrap ? 'pre-wrap' : 'pre',\n      wordBreak: controlProp.WordWrap ? 'break-all' : 'normal',\n      color:\n        controlProp.Enabled === true ? controlProp.ForeColor : this.getEnabled,\n      cursor:\n        controlProp.MousePointer !== 0 || controlProp.MouseIcon !== ''\n          ? this.getMouseCursorData\n          : 'default',\n      fontFamily: font.FontStyle! !== '' ? this.setFontStyle : font.FontName!,\n      fontSize: `${font.FontSize}px`,\n      fontStyle: font.FontItalic || this.isItalic ? 'italic' : '',\n      textDecoration:\n        font.FontStrikethrough === true && font.FontUnderline === true\n          ? 'underline line-through'\n          : font.FontUnderline\n            ? 'underline'\n            : font.FontStrikethrough\n              ? 'line-through'\n              : '',\n      textUnderlinePosition: 'under',\n      fontWeight: font.FontBold\n        ? 'bold'\n        : font.FontStyle !== ''\n          ? this.tempWeight\n          : '',\n      fontStretch: font.FontStyle !== '' ? this.tempStretch : '',\n\n      display: display,\n      overflow: 'hidden',\n      gridTemplateColumns: controlProp.Alignment === 1 ? '12px auto' : 'auto 12px',\n      gridTemplateRows: '100%',\n      gap: '2px',\n      // alignItems: font.FontSize! > 17 ? 'center' : '',\n      alignContent: 'center',\n      boxShadow: 'none',\n      alignItems: alignItems\n    }\n  }\n\n  /**\n   * @description style object is passed to :style attribute in div tag\n   * dynamically changing the styles of the component based on properties\n   * @function divcssStyleProperty\n   *\n   */\n  get divcssStyleProperty () {\n    const controlProp = this.properties\n    return {\n      overflow: 'hidden',\n      // height: !this.isEditMode ? '100%' : '',\n      display: 'flex',\n      justifyContent:\n        controlProp.TextAlign === 0\n          ? 'flex-start'\n          : controlProp.TextAlign === 1\n            ? 'center'\n            : 'flex-end',\n      alignItems: 'center',\n      textAlign:\n        controlProp.TextAlign === 0\n          ? 'start'\n          : controlProp.TextAlign === 1\n            ? 'center'\n            : 'end',\n      // position: !this.isEditMode ? 'relative' : 'absolute'\n    }\n  }\n\n  /**\n   * @description style object is passed to :style attribute in div tag\n   * dynamically changing the styles of the component based on properties\n   * @function pictureDivStyle\n   *\n   */\n  get pictureDivStyle () {\n    const controlProp = this.properties\n    return {\n      height: '100%',\n      display: !this.isEditMode ? 'table-cell' : 'flex',\n      alignItems: this.alignItem ? 'baseline' : 'center',\n      backgroundImage: `url(${controlProp.Picture})`,\n      backgroundRepeat: this.getRepeat,\n      backgroundPosition: this.getPosition,\n      backgroundPositionX: this.getPositionX,\n      backgroundPositionY: this.getPositionY,\n      position: 'relative'\n    }\n  }\n\n  get setAlignment () {\n    return {\n      editMode: this.isEditMode,\n      caption: this.properties.Caption\n    }\n  }\n\n  @Watch('setAlignment', { deep: true })\n  editableTextVerify () {\n    if (this.isEditMode) {\n      Vue.nextTick(() => {\n        if (this.isEditMode && this.checkBoxSpanRef.$el.clientHeight > this.properties.Height!) {\n          this.alignItem = true\n        } else {\n          this.alignItem = false\n        }\n      })\n    }\n  }\n  @Watch('properties.Height')\n  updateImageSizeHeight () {\n    const  imgStyle={\n      width:'auto',\n      height:'fit-content'\n    }\n    if (this.properties.Picture) {\n      Vue.nextTick(() => {\n      const imgProp = document.getElementById('img')\n      // console.log('imgStyle||', imgProp!.clientHeight,imgProp!.clientWidth)\n      if (this.properties.Height! < imgProp!.clientHeight) {\n          imgStyle.width = '100%'\n          imgStyle.height = 'auto'\n          this.reverseStyle.display = 'contents'\n      }\n      })\n    }\n      this.imageProperty = imgStyle\n  }\n  @Watch('properties.Width')\n  updateImageSizeWidth () {\n    const  imgStyle={\n      width:'auto',\n      height:'fit-content'\n    }\n    if (this.properties.Picture) {\n      Vue.nextTick(() => {\n      const imgProp = document.getElementById('img')\n      if (this.properties.Width! < imgProp!.clientWidth) {\n          imgStyle.width = '100%'\n          imgStyle.height = 'auto'\n          this.reverseStyle.display = 'contents'\n      }\n      })\n    }\n      this.imageProperty = imgStyle\n  }\n  /**\n   * @description style object is passed to :style attribute in tag\n   * dynamically changing the styles of the component based on properties\n   * @function editCssObj\n   *\n   */\n  protected get editCssObj (): Partial<CSSStyleDeclaration> {\n    const controlProp = this.properties\n    return {\n      backgroundImage: 'none'\n    }\n  }\n\n  /**\n   * @override\n   */\n  @Watch('properties.AutoSize', {\n    deep: true\n  })\n  updateAutoSize () {\n    if (this.properties.AutoSize) {\n      const  imgStyle={\n      width:'auto',\n      height:'auto'\n      }\n      this.imageProperty = imgStyle\n      this.positionLogo(this.properties.PicturePosition)\n      this.$nextTick(() => {\n        let divRef: HTMLDivElement = this.autoSizecheckbox\n        const offsetWidth = (divRef.childNodes[0] as HTMLSpanElement)\n          .offsetWidth\n        const offsetHeight = (divRef.childNodes[0] as HTMLSpanElement)\n          .offsetHeight\n        // Value 10 for checkbox, 4 for Gap style value, and offsetHeight and offsetWidth + 1\n        this.updateDataModel({\n          propertyName: 'Width',\n          value: 10 + 4 + offsetWidth + 1\n        })\n        this.updateDataModel({\n          propertyName: 'Height',\n          value: 10 + 4 + offsetHeight + 1\n        })\n      })\n    } else {\n      return undefined\n    }\n  }\n\n  @Watch('properties.Font.FontSize', { deep: true })\n  autoSizeValidateOnFontChange () {\n    if (this.properties.AutoSize) {\n      this.updateAutoSize()\n    }\n  }\n\n  @Watch('properties.WordWrap', { deep: true })\n  autoSizeValidateOnWordWrapChange () {\n    if (this.properties.AutoSize) {\n      this.updateAutoSize()\n    }\n  }\n\n  @Watch('properties.Caption', { deep: true })\n  autoSizeValidateOnCaptionChange () {\n    if (this.properties.AutoSize) {\n      this.updateAutoSize()\n    }\n  }\n\n  /**\n   * @description  sets controlSource if present and updates Value property\n   * @function controlSource\n   */\n  mounted () {\n    this.verifyValue()\n    this.$el.focus()\n    this.controlSource()\n  }\n  releaseEditMode (event: KeyboardEvent) {\n    this.$el.focus()\n    this.setContentEditable(event, false)\n  }\n  checkBoxClick (event: MouseEvent) {\n    this.selectedItem(event)\n    if (this.isEditMode) {\n      (this.checkBoxSpanRef.$el as HTMLSpanElement).focus()\n    }\n  }\n  positionLogo(value:any){\n      let style = {\n        order: Number(),\n        alignItems: '',\n        transform:'',\n        top:'',\n        left:'',\n        position:'',\n        display:'inline-flex',\n        width: '',\n        justifyContent:''\n      }\n      this.reverseStyle = {\n      display : '',\n      flexDirection : '',\n      justifyItems : '',\n      position:'',\n      justifyContent:'center',\n      alignItems: '',\n      width:''\n      }\n      this.reverseStyle.display = 'flex'\n      switch(value) {\n        case 0: \n        break\n        case 1:style.alignItems = 'center'\n        this.reverseStyle.alignItems = 'center'\n        break\n        case 2:style.alignItems = 'flex-end'\n        this.reverseStyle.alignItems = 'flex-end'\n        break\n        case 3: this.reverseStyle.flexDirection = 'row-reverse'\n        break\n        case 4:\n        this.reverseStyle.flexDirection = 'row-reverse'\n        style.alignItems = 'center'\n        this.reverseStyle.alignItems = 'center'\n        break\n        case 5:\n        this.reverseStyle.flexDirection = 'row-reverse'\n        style.alignItems = 'flex-end'\n        this.reverseStyle.alignItems = 'flex-end'\n        break\n        case 6:\n        this.reverseStyle.display = 'grid'\n        break\n        case 7:  \n        this.reverseStyle.display = 'grid'\n        this.reverseStyle.justifyItems = 'center'\n        break\n        case 8:  \n        this.reverseStyle.display = 'grid'\n        this.reverseStyle.justifyItems = 'end'\n        break\n        case 9:  \n        this.reverseStyle.display = 'grid'\n        style.order= -1\n        break\n        case 10:  \n        this.reverseStyle.display = 'grid'\n        this.reverseStyle.justifyItems = 'center'\n        style.order = -1\n        break\n        case 11:  \n        this.reverseStyle.display = 'grid'\n        this.reverseStyle.justifyItems = 'end'\n        style.order= -1\n        break\n        case 12:  \n        this.reverseStyle.position = 'relative'\n        this.reverseStyle.width = '100%'\n        style.position = 'absolute',\n        style.top = '50%',\n        style.left = '50%',\n        style.transform ='translate(-50%, -50%)'\n        style.justifyContent = 'center'\n        style.width = '100%'\n        break\n        default:\n          console.log('none')\n      }\n      this.labelStyle = style \n    }\n}\n</script>\n\n<style scoped>\n* {\n  box-sizing: border-box;\n}\n\n.outer-check {\n  height: 0px;\n  width: 0px;\n  left: 0px;\n  top: 0px;\n  min-width: 12px;\n  min-height: 13px;\n  background-color: rgb(238, 238, 238);\n  box-shadow: -1px -1px gray;\n  overflow: hidden;\n  align-items: center;\n  box-sizing: border-box;\n}\n\n.visually-hidden {\n  border: 0;\n  clip: rect(0, 0, 0, 0);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  width: 1px;\n}\n\n.control {\n  display: inline-flex;\n  position: sticky;\n  top: 47%;\n}\n\n.control-indicator {\n  width: 10px;\n  height: 10px;\n  margin: 1px;\n  background-color: white;\n  border: 1px inset grey;\n}\n\n.control-input:checked ~ .control-indicator {\n  background-image: url(../../../../assets/checkmark.png);\n  background-size: 10px;\n  background-position: center;\n  background-repeat: no-repeat;\n}\n\n.spanStyle {\n  text-decoration: underline;\n  text-underline-position: under;\n}\n\n.menu {\n  width: 10%;\n  margin: 0 auto;\n}\n\n.main {\n  width: 90%;\n  margin: 0 auto;\n}\n\n#logo{\n display: inline-flex;\n justify-content: center;\n}\n</style>\n"]}]}