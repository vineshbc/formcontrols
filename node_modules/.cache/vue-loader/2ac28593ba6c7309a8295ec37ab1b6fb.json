{"remainingRequest":"/home/mobiotics/Projects/formcontrols/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/mobiotics/Projects/formcontrols/src/FormDesigner/components/atoms/FDContextMenu/index.vue?vue&type=script&lang=ts&","dependencies":[{"path":"/home/mobiotics/Projects/formcontrols/src/FormDesigner/components/atoms/FDContextMenu/index.vue","mtime":1610544258554},{"path":"/home/mobiotics/Projects/formcontrols/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/mobiotics/Projects/formcontrols/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/mobiotics/Projects/formcontrols/node_modules/ts-loader/index.js","mtime":499162500000},{"path":"/home/mobiotics/Projects/formcontrols/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/mobiotics/Projects/formcontrols/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCmltcG9ydCB7IENvbXBvbmVudCwgVnVlLCBQcm9wLCBFbWl0IH0gZnJvbSAndnVlLXByb3BlcnR5LWRlY29yYXRvcicKaW1wb3J0IEZEU1ZHSW1hZ2UgZnJvbSAnQC9Gb3JtRGVzaWduZXIvY29tcG9uZW50cy9hdG9tcy9GRFNWR0ltYWdlL2luZGV4LnZ1ZScKaW1wb3J0IHsgQ29udHJvbFByb3BlcnR5RGF0YSB9IGZyb20gJ0AvRm9ybURlc2lnbmVyL21vZGVscy9Db250cm9sc1RhYmxlUHJvcGVydGllcy9Db250cm9sUHJvcGVydHlEYXRhLnRzJwoKaW1wb3J0IHsgQWN0aW9uLCBTdGF0ZSB9IGZyb20gJ3Z1ZXgtY2xhc3MnCmltcG9ydCB7CiAgSWFkZENoaWxkQ29udHJvbHMsCiAgSWFkZENvbnRyb2wsCiAgSWRlbGV0ZUNvbnRyb2wsCiAgSXNlbGVjdENvbnRyb2wsCiAgSXNldENoaWxkQ29udHJvbHMsCiAgSXVwZGF0ZUNvbnRyb2wsCiAgSXVwZGF0ZUNvbnRyb2xFeHRyYURhdGEsCiAgSXVwZGF0ZUNvcHlDb250cm9sTGlzdCwKICBJdXBkYXRlR3JvdXAKfSBmcm9tICdAL3N0b3JlTW9kdWxlcy9mZC9hY3Rpb25zJwppbXBvcnQgeyBFdmVudEJ1cyB9IGZyb20gJ0AvRm9ybURlc2lnbmVyL2V2ZW50LWJ1cycKaW1wb3J0IEZEQ29tbW9uTWV0aG9kIGZyb20gJ0AvYXBpL2Fic3RyYWN0L0Zvcm1EZXNpZ25lci9GRENvbW1vbk1ldGhvZCcKCkBDb21wb25lbnQoewogIG5hbWU6ICdDb250ZXh0TWVudScsCiAgY29tcG9uZW50czogewogICAgRkRTVkdJbWFnZQogIH0KfSkKZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29udGV4dE1lbnUgZXh0ZW5kcyBGRENvbW1vbk1ldGhvZCB7CiAgQFByb3AoKSB2YWx1ZXM6IEFycmF5PElDb250cm9sQ29udGV4dE1lbnU+OwogIEBQcm9wKCkgdXNlckZvcm1JZDogc3RyaW5nOwogIEBQcm9wKCkgY29udGFpbmVySWQ6IHN0cmluZzsKICBAUHJvcCgpIGtleUV2ZW50TmFtZTogc3RyaW5nOwogIEBQcm9wKCkgY29udHJvbElkOiBzdHJpbmc7CiAgQFByb3AoKSBzZWxlY3RlZFRhYjogbnVtYmVyOwogIEBQcm9wKCkgZGF0YTogY29udHJvbERhdGE7CiAgQFByb3AoKSBncm91cFN0eWxlQXJyYXk6IEFycmF5PElHcm91cFN0eWxlPgoKICBAU3RhdGUoKHN0YXRlKSA9PiBzdGF0ZS5mZC5zZWxlY3RlZENvbnRyb2xzKQogIHNlbGVjdGVkQ29udHJvbHMhOiBmZFN0YXRlWydzZWxlY3RlZENvbnRyb2xzJ107CiAgQFN0YXRlKChzdGF0ZTogcm9vdFN0YXRlKSA9PiBzdGF0ZS5mZC5jb3B5Q29udHJvbExpc3QpCiAgY29weUNvbnRyb2xMaXN0ITogZmRTdGF0ZVsnY29weUNvbnRyb2xMaXN0J107CiAgQFN0YXRlKChzdGF0ZSkgPT4gc3RhdGUuZmQudXNlcmZvcm1EYXRhKSB1c2VyZm9ybURhdGEhOiB1c2VyZm9ybURhdGE7CiAgQFN0YXRlKChzdGF0ZSkgPT4gc3RhdGUuZmQuY29waWVkQ29udHJvbCkgY29waWVkQ29udHJvbCE6IHVzZXJmb3JtRGF0YTsKICBAU3RhdGUoKHN0YXRlKSA9PiBzdGF0ZS5mZC5ncm91cGVkQ29udHJvbHMpCiAgZ3JvdXBlZENvbnRyb2xzITogZmRTdGF0ZVsnZ3JvdXBlZENvbnRyb2xzJ107CgogIEBBY3Rpb24oJ2ZkL2RlbGV0ZUNvbnRyb2wnKSBkZWxldGVDb250cm9sITogKHBheWxvYWQ6IElkZWxldGVDb250cm9sKSA9PiB2b2lkOwogIEBBY3Rpb24oJ2ZkL2RlbGV0ZUNvcGllZENvbnRyb2wnKSBkZWxldGVDb3BpZWRDb250cm9sITogKHBheWxvYWQ6IElkZWxldGVDb250cm9sKSA9PiB2b2lkOwogIEBBY3Rpb24oJ2ZkL3VwZGF0ZUNvcHlDb250cm9sTGlzdCcpIHVwZGF0ZUNvcHlDb250cm9sTGlzdCE6ICgKICAgIHBheWxvYWQ6IEl1cGRhdGVDb3B5Q29udHJvbExpc3QKICApID0+IHZvaWQ7CiAgQEFjdGlvbignZmQvYWRkQ29udHJvbCcpIGFkZENvbnRyb2whOiAocGF5bG9hZDogSWFkZENvbnRyb2wpID0+IHZvaWQ7CiAgQEFjdGlvbignZmQvYWRkQ29waWVkQ29udHJvbCcpIGFkZENvcGllZENvbnRyb2whOiAoCiAgICBwYXlsb2FkOiBJYWRkQ29udHJvbAogICkgPT4gdm9pZDsKICBAQWN0aW9uKCdmZC9zZWxlY3RDb250cm9sJykgc2VsZWN0Q29udHJvbCE6IChwYXlsb2FkOiBJc2VsZWN0Q29udHJvbCkgPT4gdm9pZDsKICBAQWN0aW9uKCdmZC91cGRhdGVHcm91cCcpIHVwZGF0ZUdyb3VwITogKHBheWxvYWQ6IEl1cGRhdGVHcm91cCkgPT4gdm9pZDsKICBAQWN0aW9uKCdmZC91cGRhdGVDb250cm9sRXh0cmFEYXRhJykgdXBkYXRlQ29udHJvbEV4dHJhRGF0YSE6ICgKICAgIHBheWxvYWQ6IEl1cGRhdGVDb250cm9sRXh0cmFEYXRhCiAgKSA9PiB2b2lkOwogIEBBY3Rpb24oJ2ZkL3VwZGF0ZUNvbnRyb2wnKSB1cGRhdGVDb250cm9sITogKHBheWxvYWQ6IEl1cGRhdGVDb250cm9sKSA9PiB2b2lkOwogIEBBY3Rpb24oJ2ZkL3NldENoaWxkQ29udHJvbHMnKSBzZXRDaGlsZENvbnRyb2xzITogKAogICAgcGF5bG9hZDogSXNldENoaWxkQ29udHJvbHMKICApID0+IHZvaWQ7CiAgQEFjdGlvbignZmQvYWRkQ2hpbGRDb250cm9scycpIGFkZENoaWxkQ29udHJvbHMhOiAoCiAgICBwYXlsb2FkOiBJYWRkQ2hpbGRDb250cm9scwogICkgPT4gdm9pZDsKICBjb250cm9sQWN0aW9uIChjb250cm9sQWN0aW9uTmFtZTogc3RyaW5nLCBzdWJWYWw6IHN0cmluZykgewogICAgaWYgKGNvbnRyb2xBY3Rpb25OYW1lID09PSAnSURfQ09QWScpIHsKICAgICAgdGhpcy5jb3B5Q29udHJvbCgnY29weScpCiAgICB9IGVsc2UgaWYgKGNvbnRyb2xBY3Rpb25OYW1lID09PSAnSURfREVMRVRFJykgewogICAgICB0aGlzLmNsaWNrRGVsZXRlKCkKICAgIH0gZWxzZSBpZiAoY29udHJvbEFjdGlvbk5hbWUgPT09ICdJRF9QQVNURScpIHsKICAgICAgdGhpcy5wYXN0ZUNvbnRyb2woKQogICAgfSBlbHNlIGlmIChjb250cm9sQWN0aW9uTmFtZSA9PT0gJ0lEX0NVVCcpIHsKICAgICAgdGhpcy5jdXRDb250cm9sKCkKICAgIH0gZWxzZSBpZiAoY29udHJvbEFjdGlvbk5hbWUgPT09ICdJRF9TRUxFQ1RBTEwnKSB7CiAgICAgIHRoaXMuc2VsZWN0QWxsKCkKICAgIH0gZWxzZSBpZiAoY29udHJvbEFjdGlvbk5hbWUgPT09ICdJRF9HUk9VUCcpIHsKICAgICAgdGhpcy5ncm91cENvbnRyb2woKQogICAgfSBlbHNlIGlmIChjb250cm9sQWN0aW9uTmFtZSA9PT0gJ0lEX1VOR1JPVVAnKSB7CiAgICAgIHRoaXMudW5Hcm91cENvbnRyb2woKQogICAgfSBlbHNlIGlmIChjb250cm9sQWN0aW9uTmFtZSA9PT0gJ0lEX05FV1BBR0UnKSB7CiAgICAgIHRoaXMuYWRkTmV3UGFnZSgpCiAgICB9IGVsc2UgaWYgKGNvbnRyb2xBY3Rpb25OYW1lID09PSAnSURfREVMRVRFUEFHRScpIHsKICAgICAgdGhpcy5kZWxldGVDdXJyZW50UGFnZSgpCiAgICB9IGVsc2UgaWYgKGNvbnRyb2xBY3Rpb25OYW1lID09PSAnSURfQ09OVFJPTEZPUldBUkQnKSB7CiAgICAgIHRoaXMuYnJpbmdGb3J3YXJkKCkKICAgIH0gZWxzZSBpZiAoY29udHJvbEFjdGlvbk5hbWUgPT09ICdJRF9DT05UUk9MQkFDS1dBUkQnKSB7CiAgICAgIHRoaXMuYnJpbmdCYWNrd2FyZCgpCiAgICB9IGVsc2UgaWYgKGNvbnRyb2xBY3Rpb25OYW1lID09PSAnSURfT0JKRUNUUFJPUCcpIHsKICAgICAgdGhpcy5kaXNwbGF5UHJvcCgpCiAgICB9IGVsc2UgaWYgKGNvbnRyb2xBY3Rpb25OYW1lID09PSAnSURfUkVOQU1FJykgewogICAgICBjb25zdCBzZWxlY3RlZFBhZ2VJRCA9IHRoaXMuc2VsZWN0ZWRDb250cm9sc1t0aGlzLnVzZXJGb3JtSWRdLnNlbGVjdGVkWzBdCiAgICAgIEV2ZW50QnVzLiRlbWl0KAogICAgICAgICdyZW5hbWVQYWdlJywKICAgICAgICB0aGlzLnVzZXJGb3JtSWQsCiAgICAgICAgc2VsZWN0ZWRQYWdlSUQsCiAgICAgICAgdGhpcy5zZWxlY3RlZFRhYiwKICAgICAgICB0aGlzLnVzZXJmb3JtRGF0YVt0aGlzLnVzZXJGb3JtSWRdW3NlbGVjdGVkUGFnZUlEXS50eXBlCiAgICAgICkKICAgIH0gZWxzZSBpZiAoY29udHJvbEFjdGlvbk5hbWUgPT09ICdJRF9NT1ZFJykgewogICAgICBjb25zdCB0eXBlID0gdGhpcy51c2VyZm9ybURhdGFbdGhpcy51c2VyRm9ybUlkXVt0aGlzLmNvbnRyb2xJZF0udHlwZQogICAgICBpZiAodHlwZSA9PT0gJ011bHRpUGFnZScpIHsKICAgICAgICBFdmVudEJ1cy4kZW1pdCgndXNlckZvcm1UYWJPcmRlcicsIHRoaXMudXNlckZvcm1JZCwgdGhpcy5jb250cm9sSWQsIHR5cGUpCiAgICAgIH0gZWxzZSB7CiAgICAgICAgRXZlbnRCdXMuJGVtaXQoJ3RhYlN0cmlwVGFiT3JkZXInLCB0aGlzLnVzZXJGb3JtSWQsIHRoaXMuY29udHJvbElkLCB0eXBlKQogICAgICB9CiAgICB9IGVsc2UgaWYgKGNvbnRyb2xBY3Rpb25OYW1lID09PSAnSURfVEFCT1JERVInKSB7CiAgICAgIEV2ZW50QnVzLiRlbWl0KCd1c2VyRm9ybVRhYk9yZGVyJywgdGhpcy51c2VyRm9ybUlkLCB0aGlzLmNvbnRhaW5lcklkLCAnJykKICAgIH0gZWxzZSBpZiAoCiAgICAgIGNvbnRyb2xBY3Rpb25OYW1lID09PSAnSURfQUxJR04nIHx8CiAgICAgIGNvbnRyb2xBY3Rpb25OYW1lID09PSAnSURfTUFLRVNBTUVTSVpFJwogICAgKSB7CiAgICAgIHRoaXMuY29udHJvbEFsaWduTWVudChzdWJWYWwpCiAgICB9CiAgICB0aGlzLmNsb3NlTWVudSgpCiAgfQogIGNyZWF0ZWQgKCkgewogICAgRXZlbnRCdXMuJG9uKCdncm91cENvbnRyb2wnLCAodmFsdWU6IHN0cmluZykgPT4gewogICAgICBpZiAodGhpcy5zZWxlY3RlZENvbnRyb2xzW3RoaXMudXNlckZvcm1JZF0uY29udGFpbmVyWzBdID09PSB0aGlzLmNvbnRhaW5lcklkKSB7CiAgICAgICAgaWYgKHZhbHVlID09PSAnZ3JvdXAnKSB7CiAgICAgICAgICB0aGlzLmdyb3VwQ29udHJvbCgpCiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ3VuZ3JvdXAnKSB7CiAgICAgICAgICB0aGlzLnVuR3JvdXBDb250cm9sKCkKICAgICAgICB9CiAgICAgIH0KICAgIH0pCiAgfQogIGRlc3Ryb3llZCAoKSB7CiAgICBFdmVudEJ1cy4kb2ZmKCdncm91cENvbnRyb2wnKQogIH0KICBARW1pdCgnY2xvc2VNZW51JykKICBjbG9zZU1lbnUgKCkgewogICAgcmV0dXJuIDAKICB9CgogIGRpc3BsYXlQcm9wICgpIHsKICAgIEV2ZW50QnVzLiRlbWl0KCdkaXNwUHJvcCcsIGZhbHNlKQogIH0KCiAgYWRkTmV3UGFnZSAoKSB7CiAgICBjb25zdCB0eXBlID0gdGhpcy51c2VyZm9ybURhdGFbdGhpcy51c2VyRm9ybUlkXVt0aGlzLmNvbnRyb2xJZF0udHlwZQogICAgaWYgKHR5cGUgPT09ICdUYWJTdHJpcCcpIHsKICAgICAgY29uc3QgdGFiQ29udHJvbERhdGEgPSBKU09OLnBhcnNlKAogICAgICAgIEpTT04uc3RyaW5naWZ5KHRoaXMudXNlcmZvcm1EYXRhW3RoaXMudXNlckZvcm1JZF1bdGhpcy5jb250cm9sSWRdKQogICAgICApLmV4dHJhRGF0YXMuVGFicwogICAgICBsZXQgcHJldlRhYklkID0gLTEKICAgICAgY29uc3QgaW5pdGlhbFRhYkRhdGE6IHRhYnNJdGVtcyA9IHsKICAgICAgICBOYW1lOiAnJywKICAgICAgICBDYXB0aW9uOiAnJywKICAgICAgICBUb29sVGlwOiAnJywKICAgICAgICBBY2NlbGVyYXRvcjogJycKICAgICAgfQogICAgICBpZiAodGFiQ29udHJvbERhdGEubGVuZ3RoID4gMCkgewogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFiQ29udHJvbERhdGEubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIGNvbnN0IGlkID0gdGFiQ29udHJvbERhdGFbaV0uTmFtZS5zcGxpdCgnVGFiJykucG9wKCkgfHwgJy0xJwogICAgICAgICAgY29uc3QgcGFyc2VJZCA9IHBhcnNlSW50KGlkLCAxMCkKICAgICAgICAgIGlmICghaXNOYU4ocGFyc2VJZCkgJiYgcHJldlRhYklkIDwgcGFyc2VJZCkgewogICAgICAgICAgICBwcmV2VGFiSWQgPSBwYXJzZUlkCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHByZXZUYWJJZCArPSAxCiAgICAgICAgaW5pdGlhbFRhYkRhdGEuTmFtZSA9IGBUYWIke3ByZXZUYWJJZH1gCiAgICAgICAgaW5pdGlhbFRhYkRhdGEuQ2FwdGlvbiA9IGBUYWIke3ByZXZUYWJJZH1gCiAgICAgIH0gZWxzZSB7CiAgICAgICAgaW5pdGlhbFRhYkRhdGEuTmFtZSA9IGBUYWIkezF9YAogICAgICAgIGluaXRpYWxUYWJEYXRhLkNhcHRpb24gPSBgVGFiJHsxfWAKICAgICAgfQogICAgICB0YWJDb250cm9sRGF0YS5wdXNoKGluaXRpYWxUYWJEYXRhKQogICAgICB0aGlzLnVwZGF0ZUNvbnRyb2xFeHRyYURhdGEoewogICAgICAgIHVzZXJGb3JtSWQ6IHRoaXMudXNlckZvcm1JZCwKICAgICAgICBjb250cm9sSWQ6IHRoaXMuY29udHJvbElkLAogICAgICAgIHByb3BlcnR5TmFtZTogJ1RhYnMnLAogICAgICAgIHZhbHVlOiB0YWJDb250cm9sRGF0YQogICAgICB9KQogICAgICB0aGlzLnVwZGF0ZUNvbnRyb2woewogICAgICAgIHVzZXJGb3JtSWQ6IHRoaXMudXNlckZvcm1JZCwKICAgICAgICBjb250cm9sSWQ6IHRoaXMuY29udHJvbElkLAogICAgICAgIHByb3BlcnR5TmFtZTogJ1ZhbHVlJywKICAgICAgICB2YWx1ZTogcHJldlRhYklkIC0gMQogICAgICB9KQogICAgfSBlbHNlIGlmICh0eXBlID09PSAnTXVsdGlQYWdlJykgewogICAgICBjb25zdCBwYXJlbnRJZCA9IHRoaXMuY29udHJvbElkLnNwbGl0KCdNdWx0aVBhZ2UnKS5wb3AoKQogICAgICBjb25zdCBjb250cm9sTmFtZSA9IGBQYWdlJHtwYXJlbnRJZH1fYAoKICAgICAgbGV0IGxhc3RDb250cm9sSWQgPSAwCiAgICAgIGNvbnN0IHVzZXJmb3JtQ29udHJvbElkcyA9IE9iamVjdC5rZXlzKHRoaXMudXNlcmZvcm1EYXRhW3RoaXMudXNlckZvcm1JZF0pCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXNlcmZvcm1Db250cm9sSWRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgaWYgKHVzZXJmb3JtQ29udHJvbElkc1tpXS5pbmRleE9mKGNvbnRyb2xOYW1lKSAhPT0gLTEpIHsKICAgICAgICAgIGNvbnN0IElkTnVtID0KICAgICAgICAgIHVzZXJmb3JtQ29udHJvbElkc1tpXS5zcGxpdChjb250cm9sTmFtZSkucG9wKCkgfHwgJy0xJwogICAgICAgICAgY29uc3QgcGFzcmVJZCA9IHBhcnNlSW50KElkTnVtLCAxMCkKICAgICAgICAgIGlmICghaXNOYU4ocGFzcmVJZCkgJiYgbGFzdENvbnRyb2xJZCA8IHBhc3JlSWQpIHsKICAgICAgICAgICAgbGFzdENvbnRyb2xJZCA9IHBhc3JlSWQKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgY29uc3QgY29udHJvbFByb3BEYXRhID0gbmV3IENvbnRyb2xQcm9wZXJ0eURhdGEoKQogICAgICBsZXQgY29udHJvbE9iaiA9IGNvbnRyb2xQcm9wRGF0YS5kYXRhWydQYWdlJ10KICAgICAgY29uc3QgaXRlbSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY29udHJvbE9iaiEpKQogICAgICBsYXN0Q29udHJvbElkICs9IDEKICAgICAgaXRlbS5wcm9wZXJ0aWVzLklEID0gYElEXyR7Y29udHJvbE5hbWV9JHtsYXN0Q29udHJvbElkfWAKICAgICAgaXRlbS5wcm9wZXJ0aWVzLkNhcHRpb24gPSBgUGFnZSR7bGFzdENvbnRyb2xJZH1gCiAgICAgIGl0ZW0ucHJvcGVydGllcy5OYW1lID0gYFBhZ2Uke2xhc3RDb250cm9sSWR9YAogICAgICBpdGVtLnByb3BlcnRpZXMuSW5kZXggPSB0aGlzLnVzZXJmb3JtRGF0YVt0aGlzLnVzZXJGb3JtSWRdW3RoaXMuY29udHJvbElkXS5jb250cm9scy5sZW5ndGgKICAgICAgdGhpcy5hZGRDb250cm9sKHsKICAgICAgICB1c2VyRm9ybUlkOiB0aGlzLnVzZXJGb3JtSWQsCiAgICAgICAgY29udHJvbElkOiB0aGlzLmNvbnRyb2xJZCwKICAgICAgICBhZGRJZDogaXRlbS5wcm9wZXJ0aWVzLklELAogICAgICAgIGl0ZW06IGl0ZW0KICAgICAgfSkKICAgICAgdGhpcy51cGRhdGVDb250cm9sKHsKICAgICAgICB1c2VyRm9ybUlkOiB0aGlzLnVzZXJGb3JtSWQsCiAgICAgICAgY29udHJvbElkOiB0aGlzLmNvbnRyb2xJZCwKICAgICAgICBwcm9wZXJ0eU5hbWU6ICdWYWx1ZScsCiAgICAgICAgdmFsdWU6IGl0ZW0ucHJvcGVydGllcy5JbmRleAogICAgICB9KQogICAgICB0aGlzLnNlbGVjdENvbnRyb2woewogICAgICAgIHVzZXJGb3JtSWQ6IHRoaXMudXNlckZvcm1JZCwKICAgICAgICBzZWxlY3Q6IHsKICAgICAgICAgIGNvbnRhaW5lcjogdGhpcy5nZXRDb250YWluZXJMaXN0KGl0ZW0ucHJvcGVydGllcy5JRCksCiAgICAgICAgICBzZWxlY3RlZDogW2l0ZW0ucHJvcGVydGllcy5JRF0KICAgICAgICB9CiAgICAgIH0pCiAgICAgIEV2ZW50QnVzLiRlbWl0KCd1cGRhdGVNdWx0aVBhZ2VWYWx1ZScpCiAgICB9CiAgfQogIGJyaW5nRm9yd2FyZCAoKSB7CiAgICBjb25zdCB1c2VyRGF0YSA9IHRoaXMudXNlcmZvcm1EYXRhW3RoaXMudXNlckZvcm1JZF0KICAgIGNvbnN0IGhpZ2hQcm9yQ29udHJvbCA9IFtdCiAgICBjb25zdCBsb3dQcm9yQ29udHJvbCA9IFtdCiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmdldENvbnRhaW5lckxpc3QodGhpcy5nZXRTZWxlY3RlZENvbnRyb2xzRGF0YXMhWzBdKVswXQogICAgY29uc3QgY29udGFpbmVyQ29udHJvbHMgPSB0aGlzLnVzZXJmb3JtRGF0YVt0aGlzLnVzZXJGb3JtSWRdW2NvbnRhaW5lcl0uY29udHJvbHMKICAgIGZvciAoY29uc3QgaW5kZXggaW4gY29udGFpbmVyQ29udHJvbHMpIHsKICAgICAgY29uc3QgY250cmxEYXRhID0gdGhpcy51c2VyZm9ybURhdGFbdGhpcy51c2VyRm9ybUlkXVtjb250YWluZXJDb250cm9sc1tpbmRleF1dCiAgICAgIGlmIChjbnRybERhdGEudHlwZSA9PT0gJ011bHRpUGFnZScgfHwgY250cmxEYXRhLnR5cGUgPT09ICdGcmFtZScgfHwgY250cmxEYXRhLnR5cGUgPT09ICdMaXN0Qm94JykgewogICAgICAgIGhpZ2hQcm9yQ29udHJvbC5wdXNoKGNvbnRhaW5lckNvbnRyb2xzW2luZGV4XSkKICAgICAgfSBlbHNlIHsKICAgICAgICBsb3dQcm9yQ29udHJvbC5wdXNoKGNvbnRhaW5lckNvbnRyb2xzW2luZGV4XSkKICAgICAgfQogICAgfQogICAgbGV0IG5leHRTZWxjdGVkU2VyaWVzOiBzdHJpbmdbXSA9IFtdCiAgICBsZXQgbmV4dEhpZ2hDb250cm9sU2VyaWVzOiBzdHJpbmdbXSA9IFtdCiAgICBjb25zdCBnZXRTZWxDb250cm9sID0gWy4uLnRoaXMuZ2V0U2VsZWN0ZWRDb250cm9sc0RhdGFzIV0KICAgIGdldFNlbENvbnRyb2wuc29ydCgoYSwgYikgPT4gewogICAgICByZXR1cm4gdXNlckRhdGFbYV0uZXh0cmFEYXRhcyEuekluZGV4ISAtIHVzZXJEYXRhW2JdLmV4dHJhRGF0YXMhLnpJbmRleCEKICAgIH0pCiAgICBmb3IgKGNvbnN0IHNlbENvbnRyb2wgb2YgZ2V0U2VsQ29udHJvbCEpIHsKICAgICAgY29uc3QgdHlwZSA9IHVzZXJEYXRhW3NlbENvbnRyb2xdLnR5cGUKICAgICAgY29uc3QgdGVtcFpJbmRleCA9IHVzZXJEYXRhW3NlbENvbnRyb2xdLmV4dHJhRGF0YXMhLnpJbmRleCEKICAgICAgY29uc3QgY29udHJvbEluZGV4ID0gT2JqZWN0LmtleXModXNlckRhdGEpLmZpbmRJbmRleCgodmFsOiBzdHJpbmcsIGluZGV4OiBudW1iZXIpID0+IHsKICAgICAgICByZXR1cm4gJ3pJbmRleCcgaW4gdXNlckRhdGFbdmFsXS5leHRyYURhdGFzISAmJiAodXNlckRhdGFbdmFsXS5leHRyYURhdGFzIS56SW5kZXggPT09IHRlbXBaSW5kZXggKyAxKQogICAgICB9KQogICAgICBjb25zdCBuZXh0U2VsZWN0ZWRDb250cm9sID0gY29udHJvbEluZGV4ICE9PSAtMSA/IE9iamVjdC5rZXlzKHVzZXJEYXRhKVtjb250cm9sSW5kZXhdIDogJycKICAgICAgY29uc3QgbmV4dENvbnRyb2xUeXBlID0gdXNlckRhdGFbbmV4dFNlbGVjdGVkQ29udHJvbF0udHlwZQogICAgICBpZiAobmV4dFNlbGVjdGVkQ29udHJvbCAhPT0gJycgJiYgIWhpZ2hQcm9yQ29udHJvbC5pbmNsdWRlcyhuZXh0U2VsZWN0ZWRDb250cm9sKSkgewogICAgICAgIGlmIChnZXRTZWxDb250cm9sIS5pbmNsdWRlcyhuZXh0U2VsZWN0ZWRDb250cm9sKSkgewogICAgICAgICAgaWYgKCFuZXh0U2VsY3RlZFNlcmllcy5pbmNsdWRlcyhzZWxDb250cm9sKSkgewogICAgICAgICAgICBuZXh0U2VsY3RlZFNlcmllcy5wdXNoKHNlbENvbnRyb2wpCiAgICAgICAgICB9CiAgICAgICAgICBpZiAoIW5leHRTZWxjdGVkU2VyaWVzLmluY2x1ZGVzKG5leHRTZWxlY3RlZENvbnRyb2wpKSB7CiAgICAgICAgICAgIG5leHRTZWxjdGVkU2VyaWVzLnB1c2gobmV4dFNlbGVjdGVkQ29udHJvbCkKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG5leHRTZWxjdGVkU2VyaWVzKS5sZW5ndGggIT09IDApIHsKICAgICAgICAgICAgY29uc3QgdGVtcEV4Y2hhZ2VJbmRleCA9IHVzZXJEYXRhW25leHRTZWxjdGVkU2VyaWVzWzBdXS5leHRyYURhdGFzIS56SW5kZXghCiAgICAgICAgICAgIGNvbnN0IHN3YXBUYWJJbmRleCA9IHVzZXJEYXRhW25leHRTZWxlY3RlZENvbnRyb2xdLmV4dHJhRGF0YXMhLnpJbmRleCEKICAgICAgICAgICAgaWYgKHN3YXBUYWJJbmRleCA8PSB1c2VyRGF0YVtjb250YWluZXJdLmNvbnRyb2xzLmxlbmd0aCAvKiAmJiBzd2FwVGFiSW5kZXggPiAwICovKSB7CiAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB1c2VyRGF0YVtjb250YWluZXJdLmNvbnRyb2xzLmZpbmRJbmRleCgKICAgICAgICAgICAgICAgICh2YWwpID0+IHVzZXJEYXRhW3ZhbF0uZXh0cmFEYXRhcyEuekluZGV4ID09PSBzd2FwVGFiSW5kZXgKICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgdGhpcy51cGRhdGVFeHRyYURhdGFzKHVzZXJEYXRhW2NvbnRhaW5lcl0uY29udHJvbHNbaW5kZXhdLCAnekluZGV4JywgdGVtcEV4Y2hhZ2VJbmRleCkKICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUV4dHJhRGF0YXMobmV4dFNlbGN0ZWRTZXJpZXNbMF0sICd6SW5kZXgnLCBzd2FwVGFiSW5kZXggLSAobmV4dFNlbGN0ZWRTZXJpZXMhLmxlbmd0aCAtIDEpKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZvciAobGV0IGogPSAxOyBqIDwgbmV4dFNlbGN0ZWRTZXJpZXMubGVuZ3RoOyBqKyspIHsKICAgICAgICAgICAgICBjb25zdCB1cGRhdGVJbmRleCA9IHVzZXJEYXRhW25leHRTZWxjdGVkU2VyaWVzW2pdXS5leHRyYURhdGFzIS56SW5kZXghICsgMQogICAgICAgICAgICAgIHRoaXMudXBkYXRlRXh0cmFEYXRhcyhuZXh0U2VsY3RlZFNlcmllc1tqXSwgJ3pJbmRleCcsIHVwZGF0ZUluZGV4KQogICAgICAgICAgICB9CiAgICAgICAgICAgIG5leHRTZWxjdGVkU2VyaWVzID0gW10KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGNvbnN0IHN3YXBUYWJJbmRleCA9IHVzZXJEYXRhW25leHRTZWxlY3RlZENvbnRyb2xdLmV4dHJhRGF0YXMhLnpJbmRleCEKICAgICAgICAgICAgaWYgKHN3YXBUYWJJbmRleCA8PSB1c2VyRGF0YVtjb250YWluZXJdLmNvbnRyb2xzLmxlbmd0aCAvKiAmJiBzd2FwVGFiSW5kZXggPiAwICovKSB7CiAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB1c2VyRGF0YVtjb250YWluZXJdLmNvbnRyb2xzLmZpbmRJbmRleCgKICAgICAgICAgICAgICAgICh2YWwpID0+IHVzZXJEYXRhW3ZhbF0uZXh0cmFEYXRhcyEuekluZGV4ID09PSBzd2FwVGFiSW5kZXgKICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgdGhpcy51cGRhdGVFeHRyYURhdGFzKHNlbENvbnRyb2wsICd6SW5kZXgnLCBzd2FwVGFiSW5kZXgpCiAgICAgICAgICAgICAgdGhpcy51cGRhdGVFeHRyYURhdGFzKG5leHRTZWxlY3RlZENvbnRyb2wsICd6SW5kZXgnLCB0ZW1wWkluZGV4KQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIGlmIChnZXRTZWxDb250cm9sIS5pbmNsdWRlcyhuZXh0U2VsZWN0ZWRDb250cm9sKSAmJiAodHlwZSA9PT0gJ0ZyYW1lJyB8fCB0eXBlID09PSAnTXVsdGlQYWdlJyB8fCB0eXBlID09PSAnTGlzdEJveCcpKSB7CiAgICAgICAgICBpZiAoIW5leHRIaWdoQ29udHJvbFNlcmllcy5pbmNsdWRlcyhzZWxDb250cm9sKSkgewogICAgICAgICAgICBuZXh0SGlnaENvbnRyb2xTZXJpZXMucHVzaChzZWxDb250cm9sKQogICAgICAgICAgfQogICAgICAgICAgaWYgKCFuZXh0SGlnaENvbnRyb2xTZXJpZXMuaW5jbHVkZXMobmV4dFNlbGVjdGVkQ29udHJvbCkpIHsKICAgICAgICAgICAgbmV4dEhpZ2hDb250cm9sU2VyaWVzLnB1c2gobmV4dFNlbGVjdGVkQ29udHJvbCkKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdGcmFtZScgfHwgdHlwZSA9PT0gJ011bHRpUGFnZScgfHwgdHlwZSA9PT0gJ0xpc3RCb3gnKSB7CiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMobmV4dEhpZ2hDb250cm9sU2VyaWVzKS5sZW5ndGggIT09IDApIHsKICAgICAgICAgICAgY29uc3QgdGVtcEV4Y2hhZ2VJbmRleCA9IHVzZXJEYXRhW25leHRIaWdoQ29udHJvbFNlcmllc1swXV0uZXh0cmFEYXRhcyEuekluZGV4IQogICAgICAgICAgICBjb25zdCBzd2FwVGFiSW5kZXggPSB1c2VyRGF0YVtuZXh0U2VsZWN0ZWRDb250cm9sXS5leHRyYURhdGFzIS56SW5kZXghCiAgICAgICAgICAgIGlmIChzd2FwVGFiSW5kZXggPD0gdXNlckRhdGFbY29udGFpbmVyXS5jb250cm9scy5sZW5ndGgpIHsKICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHVzZXJEYXRhW2NvbnRhaW5lcl0uY29udHJvbHMuZmluZEluZGV4KAogICAgICAgICAgICAgICAgKHZhbCkgPT4gdXNlckRhdGFbdmFsXS5leHRyYURhdGFzIS56SW5kZXggPT09IHN3YXBUYWJJbmRleAogICAgICAgICAgICAgICkKICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUV4dHJhRGF0YXModXNlckRhdGFbY29udGFpbmVyXS5jb250cm9sc1tpbmRleF0sICd6SW5kZXgnLCB0ZW1wRXhjaGFnZUluZGV4KQogICAgICAgICAgICAgIHRoaXMudXBkYXRlRXh0cmFEYXRhcyhuZXh0SGlnaENvbnRyb2xTZXJpZXNbMF0sICd6SW5kZXgnLCBzd2FwVGFiSW5kZXggLSAobmV4dEhpZ2hDb250cm9sU2VyaWVzIS5sZW5ndGggLSAxKSkKICAgICAgICAgICAgfQogICAgICAgICAgICBmb3IgKGxldCBqID0gMTsgaiA8IG5leHRIaWdoQ29udHJvbFNlcmllcy5sZW5ndGg7IGorKykgewogICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZUluZGV4ID0gdXNlckRhdGFbbmV4dEhpZ2hDb250cm9sU2VyaWVzW2pdXS5leHRyYURhdGFzIS56SW5kZXghICsgMQogICAgICAgICAgICAgIHRoaXMudXBkYXRlRXh0cmFEYXRhcyhuZXh0SGlnaENvbnRyb2xTZXJpZXNbal0sICd6SW5kZXgnLCB1cGRhdGVJbmRleCkKICAgICAgICAgICAgfQogICAgICAgICAgICBuZXh0SGlnaENvbnRyb2xTZXJpZXMgPSBbXQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgY29uc3Qgc3dhcFRhYkluZGV4ID0gdXNlckRhdGFbbmV4dFNlbGVjdGVkQ29udHJvbF0uZXh0cmFEYXRhcyEuekluZGV4IQogICAgICAgICAgICBpZiAoc3dhcFRhYkluZGV4IDw9IHVzZXJEYXRhW2NvbnRhaW5lcl0uY29udHJvbHMubGVuZ3RoIC8qICYmIHN3YXBUYWJJbmRleCA+IDAgKi8pIHsKICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHVzZXJEYXRhW2NvbnRhaW5lcl0uY29udHJvbHMuZmluZEluZGV4KAogICAgICAgICAgICAgICAgKHZhbCkgPT4gdXNlckRhdGFbdmFsXS5leHRyYURhdGFzIS56SW5kZXggPT09IHN3YXBUYWJJbmRleAogICAgICAgICAgICAgICkKICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUV4dHJhRGF0YXMoc2VsQ29udHJvbCwgJ3pJbmRleCcsIHN3YXBUYWJJbmRleCkKICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUV4dHJhRGF0YXMobmV4dFNlbGVjdGVkQ29udHJvbCwgJ3pJbmRleCcsIHRlbXBaSW5kZXgpCiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9CiAgYnJpbmdCYWNrd2FyZCAoKSB7CiAgICBjb25zdCB1c2VyRGF0YSA9IHRoaXMudXNlcmZvcm1EYXRhW3RoaXMudXNlckZvcm1JZF0KICAgIGNvbnN0IGhpZ2hQcm9yQ29udHJvbCA9IFtdCiAgICBjb25zdCBsb3dQcm9yQ29udHJvbCA9IFtdCiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmdldENvbnRhaW5lckxpc3QodGhpcy5nZXRTZWxlY3RlZENvbnRyb2xzRGF0YXMhWzBdKVswXQogICAgY29uc3QgY29udGFpbmVyQ29udHJvbHMgPSB0aGlzLnVzZXJmb3JtRGF0YVt0aGlzLnVzZXJGb3JtSWRdW2NvbnRhaW5lcl0uY29udHJvbHMKICAgIGZvciAoY29uc3QgaW5kZXggaW4gY29udGFpbmVyQ29udHJvbHMpIHsKICAgICAgY29uc3QgY250cmxEYXRhID0gdGhpcy51c2VyZm9ybURhdGFbdGhpcy51c2VyRm9ybUlkXVtjb250YWluZXJDb250cm9sc1tpbmRleF1dCiAgICAgIGlmIChjbnRybERhdGEudHlwZSA9PT0gJ011bHRpUGFnZScgfHwgY250cmxEYXRhLnR5cGUgPT09ICdGcmFtZScgfHwgY250cmxEYXRhLnR5cGUgPT09ICdMaXN0Qm94JykgewogICAgICAgIGhpZ2hQcm9yQ29udHJvbC5wdXNoKGNvbnRhaW5lckNvbnRyb2xzW2luZGV4XSkKICAgICAgfSBlbHNlIHsKICAgICAgICBsb3dQcm9yQ29udHJvbC5wdXNoKGNvbnRhaW5lckNvbnRyb2xzW2luZGV4XSkKICAgICAgfQogICAgfQogICAgbGV0IG5leHRTZWxjdGVkU2VyaWVzOiBzdHJpbmdbXSA9IFtdCiAgICBsZXQgbmV4dEhpZ2hDb250cm9sU2VyaWVzOiBzdHJpbmdbXSA9IFtdCiAgICBjb25zdCBnZXRTZWxDb250cm9sID0gWy4uLnRoaXMuZ2V0U2VsZWN0ZWRDb250cm9sc0RhdGFzIV0KICAgIGdldFNlbENvbnRyb2wuc29ydCgoYSwgYikgPT4gewogICAgICByZXR1cm4gdXNlckRhdGFbYV0uZXh0cmFEYXRhcyEuekluZGV4ISAtIHVzZXJEYXRhW2JdLmV4dHJhRGF0YXMhLnpJbmRleCEKICAgIH0pCiAgICBmb3IgKGNvbnN0IHNlbENvbnRyb2wgb2YgZ2V0U2VsQ29udHJvbCkgewogICAgICBjb25zdCB0eXBlID0gdXNlckRhdGFbc2VsQ29udHJvbF0udHlwZQogICAgICBjb25zdCB0ZW1wWkluZGV4ID0gdXNlckRhdGFbc2VsQ29udHJvbF0uZXh0cmFEYXRhcyEuekluZGV4IQogICAgICBjb25zdCBjb250cm9sSW5kZXggPSBPYmplY3Qua2V5cyh1c2VyRGF0YSkuZmluZEluZGV4KCh2YWw6IHN0cmluZywgaW5kZXg6IG51bWJlcikgPT4gewogICAgICAgIHJldHVybiAnekluZGV4JyBpbiB1c2VyRGF0YVt2YWxdLmV4dHJhRGF0YXMhICYmICh1c2VyRGF0YVt2YWxdLmV4dHJhRGF0YXMhLnpJbmRleCA9PT0gdGVtcFpJbmRleCAtIDEpCiAgICAgIH0pCiAgICAgIGNvbnN0IG5leHRTZWxlY3RlZENvbnRyb2wgPSBjb250cm9sSW5kZXggIT09IC0xID8gT2JqZWN0LmtleXModXNlckRhdGEpW2NvbnRyb2xJbmRleF0gOiAnJwogICAgICBjb25zdCBuZXh0Q29udHJvbFR5cGUgPSB1c2VyRGF0YVtuZXh0U2VsZWN0ZWRDb250cm9sXS50eXBlCiAgICAgIGlmIChuZXh0U2VsZWN0ZWRDb250cm9sICE9PSAnJyAmJiAhaGlnaFByb3JDb250cm9sLmluY2x1ZGVzKHNlbENvbnRyb2wpKSB7CiAgICAgICAgaWYgKGdldFNlbENvbnRyb2whLmluY2x1ZGVzKG5leHRTZWxlY3RlZENvbnRyb2wpKSB7CiAgICAgICAgICBpZiAoIW5leHRTZWxjdGVkU2VyaWVzLmluY2x1ZGVzKHNlbENvbnRyb2wpKSB7CiAgICAgICAgICAgIG5leHRTZWxjdGVkU2VyaWVzLnB1c2goc2VsQ29udHJvbCkKICAgICAgICAgIH0KICAgICAgICAgIGlmICghbmV4dFNlbGN0ZWRTZXJpZXMuaW5jbHVkZXMobmV4dFNlbGVjdGVkQ29udHJvbCkpIHsKICAgICAgICAgICAgbmV4dFNlbGN0ZWRTZXJpZXMucHVzaChuZXh0U2VsZWN0ZWRDb250cm9sKQogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMobmV4dFNlbGN0ZWRTZXJpZXMpLmxlbmd0aCAhPT0gMCkgewogICAgICAgICAgICBjb25zb2xlLmxvZygnbmV4dFNlbGN0ZWRTZXJpZXMnLCBuZXh0U2VsY3RlZFNlcmllcykKICAgICAgICAgICAgY29uc3QgdGVtcEV4Y2hhZ2VJbmRleCA9IHVzZXJEYXRhW25leHRTZWxjdGVkU2VyaWVzWzBdXS5leHRyYURhdGFzIS56SW5kZXghCiAgICAgICAgICAgIGNvbnN0IHN3YXBUYWJJbmRleCA9IHVzZXJEYXRhW25leHRTZWxlY3RlZENvbnRyb2xdLmV4dHJhRGF0YXMhLnpJbmRleCEKICAgICAgICAgICAgaWYgKHN3YXBUYWJJbmRleCA8PSB1c2VyRGF0YVtjb250YWluZXJdLmNvbnRyb2xzLmxlbmd0aCAmJiBzd2FwVGFiSW5kZXggPiAwKSB7CiAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB1c2VyRGF0YVtjb250YWluZXJdLmNvbnRyb2xzLmZpbmRJbmRleCgKICAgICAgICAgICAgICAgICh2YWwpID0+IHVzZXJEYXRhW3ZhbF0uZXh0cmFEYXRhcyEuekluZGV4ID09PSBzd2FwVGFiSW5kZXgKICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgdGhpcy51cGRhdGVFeHRyYURhdGFzKHVzZXJEYXRhW2NvbnRhaW5lcl0uY29udHJvbHNbaW5kZXhdLCAnekluZGV4JywgdGVtcEV4Y2hhZ2VJbmRleCkKICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUV4dHJhRGF0YXMobmV4dFNlbGN0ZWRTZXJpZXNbMF0sICd6SW5kZXgnLCAobmV4dFNlbGN0ZWRTZXJpZXMhLmxlbmd0aCArIDEpIC0gc3dhcFRhYkluZGV4KQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZvciAobGV0IGogPSAxOyBqIDwgbmV4dFNlbGN0ZWRTZXJpZXMubGVuZ3RoOyBqKyspIHsKICAgICAgICAgICAgICBjb25zdCB1cGRhdGVJbmRleCA9IHVzZXJEYXRhW25leHRTZWxjdGVkU2VyaWVzW2pdXS5leHRyYURhdGFzIS56SW5kZXghIC0gMQogICAgICAgICAgICAgIHRoaXMudXBkYXRlRXh0cmFEYXRhcyhuZXh0U2VsY3RlZFNlcmllc1tqXSwgJ3pJbmRleCcsIHVwZGF0ZUluZGV4KQogICAgICAgICAgICB9CiAgICAgICAgICAgIG5leHRTZWxjdGVkU2VyaWVzID0gW10KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGNvbnN0IHN3YXBUYWJJbmRleCA9IHVzZXJEYXRhW25leHRTZWxlY3RlZENvbnRyb2xdLmV4dHJhRGF0YXMhLnpJbmRleCEKICAgICAgICAgICAgaWYgKHN3YXBUYWJJbmRleCA8PSB1c2VyRGF0YVtjb250YWluZXJdLmNvbnRyb2xzLmxlbmd0aCAmJiBzd2FwVGFiSW5kZXggPiAwKSB7CiAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB1c2VyRGF0YVtjb250YWluZXJdLmNvbnRyb2xzLmZpbmRJbmRleCgKICAgICAgICAgICAgICAgICh2YWwpID0+IHVzZXJEYXRhW3ZhbF0uZXh0cmFEYXRhcyEuekluZGV4ID09PSBzd2FwVGFiSW5kZXgKICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgdGhpcy51cGRhdGVFeHRyYURhdGFzKHNlbENvbnRyb2wsICd6SW5kZXgnLCBzd2FwVGFiSW5kZXgpCiAgICAgICAgICAgICAgdGhpcy51cGRhdGVFeHRyYURhdGFzKG5leHRTZWxlY3RlZENvbnRyb2wsICd6SW5kZXgnLCB0ZW1wWkluZGV4KQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGVsc2UgaWYgKCFsb3dQcm9yQ29udHJvbC5pbmNsdWRlcyhuZXh0U2VsZWN0ZWRDb250cm9sKSAmJiAodHlwZSA9PT0gJ0ZyYW1lJyB8fCB0eXBlID09PSAnTXVsdGlQYWdlJyB8fCB0eXBlID09PSAnTGlzdEJveCcpKSB7CiAgICAgICAgaWYgKGdldFNlbENvbnRyb2whLmluY2x1ZGVzKG5leHRTZWxlY3RlZENvbnRyb2wpKSB7CiAgICAgICAgICBpZiAoIW5leHRIaWdoQ29udHJvbFNlcmllcy5pbmNsdWRlcyhzZWxDb250cm9sKSkgewogICAgICAgICAgICBuZXh0SGlnaENvbnRyb2xTZXJpZXMucHVzaChzZWxDb250cm9sKQogICAgICAgICAgfQogICAgICAgICAgaWYgKCFuZXh0SGlnaENvbnRyb2xTZXJpZXMuaW5jbHVkZXMobmV4dFNlbGVjdGVkQ29udHJvbCkpIHsKICAgICAgICAgICAgbmV4dEhpZ2hDb250cm9sU2VyaWVzLnB1c2gobmV4dFNlbGVjdGVkQ29udHJvbCkKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG5leHRIaWdoQ29udHJvbFNlcmllcykubGVuZ3RoICE9PSAwKSB7CiAgICAgICAgICAgIGNvbnN0IHRlbXBFeGNoYWdlSW5kZXggPSB1c2VyRGF0YVtuZXh0SGlnaENvbnRyb2xTZXJpZXNbMF1dLmV4dHJhRGF0YXMhLnpJbmRleCEKICAgICAgICAgICAgY29uc3Qgc3dhcFRhYkluZGV4ID0gdXNlckRhdGFbbmV4dFNlbGVjdGVkQ29udHJvbF0uZXh0cmFEYXRhcyEuekluZGV4IQogICAgICAgICAgICBpZiAoc3dhcFRhYkluZGV4IDw9IHVzZXJEYXRhW2NvbnRhaW5lcl0uY29udHJvbHMubGVuZ3RoKSB7CiAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB1c2VyRGF0YVtjb250YWluZXJdLmNvbnRyb2xzLmZpbmRJbmRleCgKICAgICAgICAgICAgICAgICh2YWwpID0+IHVzZXJEYXRhW3ZhbF0uZXh0cmFEYXRhcyEuekluZGV4ID09PSBzd2FwVGFiSW5kZXgKICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgdGhpcy51cGRhdGVFeHRyYURhdGFzKHVzZXJEYXRhW2NvbnRhaW5lcl0uY29udHJvbHNbaW5kZXhdLCAnekluZGV4JywgdGVtcEV4Y2hhZ2VJbmRleCkKICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUV4dHJhRGF0YXMobmV4dEhpZ2hDb250cm9sU2VyaWVzWzBdLCAnekluZGV4JywgKG5leHRIaWdoQ29udHJvbFNlcmllcyEubGVuZ3RoICsgMSkgLSBzd2FwVGFiSW5kZXgpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBuZXh0SGlnaENvbnRyb2xTZXJpZXMubGVuZ3RoOyBqKyspIHsKICAgICAgICAgICAgICBjb25zdCB1cGRhdGVJbmRleCA9IHVzZXJEYXRhW25leHRIaWdoQ29udHJvbFNlcmllc1tqXV0uZXh0cmFEYXRhcyEuekluZGV4ISAtIDEKICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUV4dHJhRGF0YXMobmV4dEhpZ2hDb250cm9sU2VyaWVzW2pdLCAnekluZGV4JywgdXBkYXRlSW5kZXgpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgbmV4dEhpZ2hDb250cm9sU2VyaWVzID0gW10KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGNvbnN0IHN3YXBUYWJJbmRleCA9IHVzZXJEYXRhW25leHRTZWxlY3RlZENvbnRyb2xdLmV4dHJhRGF0YXMhLnpJbmRleCEKICAgICAgICAgICAgaWYgKHN3YXBUYWJJbmRleCA8PSB1c2VyRGF0YVtjb250YWluZXJdLmNvbnRyb2xzLmxlbmd0aCAmJiBzd2FwVGFiSW5kZXggPiAwKSB7CiAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB1c2VyRGF0YVtjb250YWluZXJdLmNvbnRyb2xzLmZpbmRJbmRleCgKICAgICAgICAgICAgICAgICh2YWwpID0+IHVzZXJEYXRhW3ZhbF0uZXh0cmFEYXRhcyEuekluZGV4ID09PSBzd2FwVGFiSW5kZXgKICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgdGhpcy51cGRhdGVFeHRyYURhdGFzKHNlbENvbnRyb2wsICd6SW5kZXgnLCBzd2FwVGFiSW5kZXgpCiAgICAgICAgICAgICAgdGhpcy51cGRhdGVFeHRyYURhdGFzKG5leHRTZWxlY3RlZENvbnRyb2wsICd6SW5kZXgnLCB0ZW1wWkluZGV4KQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgfQogIGRlbGV0ZVBhZ2VJbmRleCAoaWQ6IHN0cmluZykgewogICAgY29uc3QgdXNlckRhdGEgPSB0aGlzLnVzZXJmb3JtRGF0YVt0aGlzLnVzZXJGb3JtSWRdCiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLnNlbGVjdGVkQ29udHJvbHNbdGhpcy51c2VyRm9ybUlkXS5jb250YWluZXJbMF0KICAgIGNvbnN0IHRlbXBJbmRleCA9IHVzZXJEYXRhW2lkXS5wcm9wZXJ0aWVzIS5JbmRleCEKICAgIGZvciAoY29uc3Qga2V5IGluIHVzZXJEYXRhW2NvbnRhaW5lcl0uY29udHJvbHMpIHsKICAgICAgY29uc3QgY29udHJvbFpJbmRleCA9IHVzZXJEYXRhW3VzZXJEYXRhW2NvbnRhaW5lcl0uY29udHJvbHNba2V5XV0ucHJvcGVydGllcyEuSW5kZXghCiAgICAgIGlmIChjb250cm9sWkluZGV4ID4gdGVtcEluZGV4KSB7CiAgICAgICAgdGhpcy51cGRhdGVDb250cm9sKHsKICAgICAgICAgIHVzZXJGb3JtSWQ6IHRoaXMudXNlckZvcm1JZCwKICAgICAgICAgIGNvbnRyb2xJZDogdXNlckRhdGFbY29udGFpbmVyXS5jb250cm9sc1trZXldLAogICAgICAgICAgcHJvcGVydHlOYW1lOiAnSW5kZXgnLAogICAgICAgICAgdmFsdWU6IGNvbnRyb2xaSW5kZXggLSAxCiAgICAgICAgfSkKICAgICAgfQogICAgfQogIH0KICBkZWxldGVDdXJyZW50UGFnZSAoKSB7CiAgICBjb25zdCB0eXBlID0gdGhpcy51c2VyZm9ybURhdGFbdGhpcy51c2VyRm9ybUlkXVt0aGlzLmNvbnRyb2xJZF0udHlwZQogICAgaWYgKHR5cGUgPT09ICdUYWJTdHJpcCcpIHsKICAgICAgY29uc3QgdGFiQ29udHJvbERhdGEgPSBKU09OLnBhcnNlKAogICAgICAgIEpTT04uc3RyaW5naWZ5KHRoaXMudXNlcmZvcm1EYXRhW3RoaXMudXNlckZvcm1JZF1bdGhpcy5jb250cm9sSWRdKQogICAgICApLmV4dHJhRGF0YXMuVGFicwogICAgICBpZiAodGFiQ29udHJvbERhdGEgJiYgdGFiQ29udHJvbERhdGEubGVuZ3RoID4gMCkgewogICAgICAgIHRhYkNvbnRyb2xEYXRhLnNwbGljZSh0aGlzLnNlbGVjdGVkVGFiLCAxKQogICAgICAgIHRoaXMudXBkYXRlQ29udHJvbEV4dHJhRGF0YSh7CiAgICAgICAgICB1c2VyRm9ybUlkOiB0aGlzLnVzZXJGb3JtSWQsCiAgICAgICAgICBjb250cm9sSWQ6IHRoaXMuY29udHJvbElkLAogICAgICAgICAgcHJvcGVydHlOYW1lOiAnVGFicycsCiAgICAgICAgICB2YWx1ZTogdGFiQ29udHJvbERhdGEKICAgICAgICB9KQogICAgICAgIHRoaXMudXBkYXRlVGFiU3RyaXBWYWx1ZSh0aGlzLnNlbGVjdGVkVGFiISAtIDEpCiAgICAgIH0KICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ011bHRpUGFnZScpIHsKICAgICAgY29uc3QgY29udHJvbHMgPSB0aGlzLnVzZXJmb3JtRGF0YVt0aGlzLnVzZXJGb3JtSWRdW3RoaXMuY29udHJvbElkXS5jb250cm9scwogICAgICBpZiAoY29udHJvbHMubGVuZ3RoID4gMCkgewogICAgICAgIHRoaXMuZGVsZXRlUGFnZUluZGV4KHRoaXMuc2VsZWN0ZWRDb250cm9sc1t0aGlzLnVzZXJGb3JtSWRdLnNlbGVjdGVkWzBdKQogICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy51c2VyZm9ybURhdGFbdGhpcy51c2VyRm9ybUlkXVt0aGlzLnNlbGVjdGVkQ29udHJvbHNbdGhpcy51c2VyRm9ybUlkXS5zZWxlY3RlZFswXV0ucHJvcGVydGllcy5JbmRleAogICAgICAgIHRoaXMuZGVsZXRlQ29udHJvbCh7CiAgICAgICAgICB1c2VyRm9ybUlkOiB0aGlzLnVzZXJGb3JtSWQsCiAgICAgICAgICBwYXJlbnRJZDogdGhpcy5zZWxlY3RlZENvbnRyb2xzW3RoaXMudXNlckZvcm1JZF0uY29udGFpbmVyWzBdLAogICAgICAgICAgdGFyZ2V0SWQ6IHRoaXMuc2VsZWN0ZWRDb250cm9sc1t0aGlzLnVzZXJGb3JtSWRdLnNlbGVjdGVkWzBdCiAgICAgICAgfSkKICAgICAgICB0aGlzLnVwZGF0ZUluZGV4KGluZGV4ISAtIDEpCiAgICAgIH0KICAgICAgRXZlbnRCdXMuJGVtaXQoJ3VwZGF0ZU11bHRpUGFnZVZhbHVlJykKICAgIH0KICB9CiAgdXBkYXRlVGFiU3RyaXBWYWx1ZSAoaW5kZXg6IG51bWJlcikgewogICAgY29uc3QgdXNlckRhdGEgPSB0aGlzLnVzZXJmb3JtRGF0YVt0aGlzLnVzZXJGb3JtSWRdCiAgICBjb25zdCB0YWJzID0gdXNlckRhdGFbdGhpcy5jb250cm9sSWRdLmV4dHJhRGF0YXMhLlRhYnMhCiAgICBjb25zdCB0YWJJbmRleCA9IHRhYnMuZmluZEluZGV4KCh2YWwsIGtleSkgPT4ga2V5ID09PSBpbmRleCArIDEpCiAgICBpZiAodGFiSW5kZXggIT09IC0xKSB7CiAgICAgIGNvbnN0IHZhbHVlID0gaW5kZXggKyAxCiAgICAgIHRoaXMudXBkYXRlQ29udHJvbFByb3BlcnR5KCdWYWx1ZScsIHZhbHVlLCB0aGlzLmNvbnRyb2xJZCkKICAgIH0gZWxzZSBpZiAodGFiSW5kZXggPT09IC0xICYmIGluZGV4ICE9PSAtMSkgewogICAgICBjb25zdCB2YWx1ZSA9IGluZGV4CiAgICAgIHRoaXMudXBkYXRlQ29udHJvbFByb3BlcnR5KCdWYWx1ZScsIHZhbHVlLCB0aGlzLmNvbnRyb2xJZCkKICAgIH0gZWxzZSB7CiAgICAgIHRoaXMudXBkYXRlQ29udHJvbFByb3BlcnR5KCdWYWx1ZScsIC0xLCB0aGlzLmNvbnRyb2xJZCkKICAgIH0KICB9CiAgY2hhbmdlU2VsZWN0IChjb250cm9sOiBzdHJpbmcpIHsKICAgIHRoaXMuc2VsZWN0Q29udHJvbCh7CiAgICAgIHVzZXJGb3JtSWQ6IHRoaXMudXNlckZvcm1JZCwKICAgICAgc2VsZWN0OiB7CiAgICAgICAgY29udGFpbmVyOiB0aGlzLmdldENvbnRhaW5lckxpc3QoY29udHJvbCksCiAgICAgICAgc2VsZWN0ZWQ6IFtjb250cm9sXQogICAgICB9CiAgICB9KQogIH0KICB1cGRhdGVJbmRleCAoaW5kZXg6IG51bWJlcikgewogICAgY29uc3QgdXNlckRhdGEgPSB0aGlzLnVzZXJmb3JtRGF0YVt0aGlzLnVzZXJGb3JtSWRdCiAgICBjb25zdCBjb250cm9scyA9IHVzZXJEYXRhW3RoaXMuY29udHJvbElkXS5jb250cm9scwogICAgY29uc3QgcGFnZUluZGV4ID0gY29udHJvbHMuZmluZEluZGV4KHZhbCA9PiB1c2VyRGF0YVt2YWxdLnByb3BlcnRpZXMuSW5kZXggPT09IGluZGV4ICsgMSkKICAgIGlmIChwYWdlSW5kZXggIT09IC0xKSB7CiAgICAgIGNvbnN0IHZhbHVlID0gdXNlckRhdGFbY29udHJvbHNbcGFnZUluZGV4XV0ucHJvcGVydGllcy5JbmRleCEKICAgICAgdGhpcy51cGRhdGVDb250cm9sUHJvcGVydHkoJ1ZhbHVlJywgdmFsdWUsIHRoaXMuY29udHJvbElkKQogICAgICB0aGlzLmNoYW5nZVNlbGVjdChjb250cm9sc1twYWdlSW5kZXhdKQogICAgfSBlbHNlIGlmIChwYWdlSW5kZXggPT09IC0xICYmIGluZGV4ICE9PSAtMSkgewogICAgICBjb25zdCB1cGRhdGVJbmRleCA9IGNvbnRyb2xzLmZpbmRJbmRleCh2YWwgPT4gdXNlckRhdGFbdmFsXS5wcm9wZXJ0aWVzLkluZGV4ID09PSBpbmRleCkKICAgICAgY29uc3QgdmFsdWUgPSB1c2VyRGF0YVtjb250cm9sc1t1cGRhdGVJbmRleF1dLnByb3BlcnRpZXMuSW5kZXghCiAgICAgIHRoaXMudXBkYXRlQ29udHJvbFByb3BlcnR5KCdWYWx1ZScsIHZhbHVlLCB0aGlzLmNvbnRyb2xJZCkKICAgICAgdGhpcy5jaGFuZ2VTZWxlY3QoY29udHJvbHNbdXBkYXRlSW5kZXhdKQogICAgfSBlbHNlIHsKICAgICAgdGhpcy51cGRhdGVDb250cm9sUHJvcGVydHkoJ1ZhbHVlJywgLTEsIHRoaXMuY29udHJvbElkKQogICAgICB0aGlzLmNoYW5nZVNlbGVjdCh0aGlzLmNvbnRyb2xJZCkKICAgIH0KICB9CiAgdXBkYXRlQ29udHJvbFByb3BlcnR5ICgKICAgIHByb3BlcnR5TmFtZToga2V5b2YgY29udHJvbFByb3BlcnRpZXMsCiAgICBwcm9wZXJ0eVZhbHVlOiBudW1iZXIgfCBzdHJpbmcsCiAgICBjb250cm9sSWQ6IHN0cmluZwogICkgewogICAgdGhpcy51cGRhdGVDb250cm9sKHsKICAgICAgdXNlckZvcm1JZDogdGhpcy51c2VyRm9ybUlkLAogICAgICBjb250cm9sSWQ6IGNvbnRyb2xJZCwKICAgICAgcHJvcGVydHlOYW1lOiBwcm9wZXJ0eU5hbWUsCiAgICAgIHZhbHVlOiBwcm9wZXJ0eVZhbHVlCiAgICB9KQogIH0KCiAgdW5Hcm91cENvbnRyb2wgKCkgewogICAgY29uc3QgaXNHcm91cCA9IHRoaXMuc2VsZWN0ZWRDb250cm9sc1t0aGlzLnVzZXJGb3JtSWRdLnNlbGVjdGVkWzBdLnN0YXJ0c1dpdGgoJ2dyb3VwJykKICAgIGNvbnN0IHNlbENvbnRyb2wgPSB0aGlzLnNlbGVjdGVkQ29udHJvbHNbdGhpcy51c2VyRm9ybUlkXS5zZWxlY3RlZFswXQogICAgY29uc3Qgc2VsZWN0ZWQgPSBpc0dyb3VwCiAgICAgID8gc2VsQ29udHJvbAogICAgICA6IHRoaXMudXNlcmZvcm1EYXRhW3RoaXMudXNlckZvcm1JZF1bc2VsQ29udHJvbF0ucHJvcGVydGllcy5Hcm91cElEIQoKICAgIGNvbnN0IGNvbnRyb2xMaXN0ID0gW10KICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMudXNlcmZvcm1EYXRhW3RoaXMudXNlckZvcm1JZF0pIHsKICAgICAgY29uc3QgdHlwZSA9IHRoaXMudXNlcmZvcm1EYXRhW3RoaXMudXNlckZvcm1JZF1ba2V5XS50eXBlCiAgICAgIGlmICgKICAgICAgICB0eXBlICE9PSAnVXNlcmZvcm0nICYmCiAgICAgICAgdGhpcy51c2VyZm9ybURhdGFbdGhpcy51c2VyRm9ybUlkXVtrZXldLnByb3BlcnRpZXMuR3JvdXBJRCA9PT0gc2VsZWN0ZWQKICAgICAgKSB7CiAgICAgICAgY29udHJvbExpc3QucHVzaChrZXkpCiAgICAgIH0KICAgIH0KICAgIGNvbnN0IGdyb3VwQXJyYXkgPSBbLi4udGhpcy5ncm91cGVkQ29udHJvbHNbdGhpcy51c2VyRm9ybUlkXSEuZ3JvdXBBcnJheSFdCiAgICB0aGlzLnVwZGF0ZUNvbnRyb2xHcm91cElEKHNlbGVjdGVkLCAnJykKICAgIGNvbnN0IGluZGV4ID0gdGhpcy5ncm91cGVkQ29udHJvbHNbdGhpcy51c2VyRm9ybUlkXSEuZ3JvdXBBcnJheSEuZmluZEluZGV4KAogICAgICAodmFsKSA9PiB2YWwgPT09IHNlbGVjdGVkCiAgICApCiAgICBncm91cEFycmF5LnNwbGljZShpbmRleCwgMSkKICAgIHRoaXMudXBkYXRlR3JvdXAoeyB1c2VyRm9ybUlkOiB0aGlzLnVzZXJGb3JtSWQsIGdyb3VwQXJyYXk6IGdyb3VwQXJyYXkgfSkKICAgIHRoaXMuc2VsZWN0Q29udHJvbCh7CiAgICAgIHVzZXJGb3JtSWQ6IHRoaXMudXNlckZvcm1JZCwKICAgICAgc2VsZWN0OiB7CiAgICAgICAgY29udGFpbmVyOiBpc0dyb3VwCiAgICAgICAgICA/IHRoaXMuZ2V0Q29udGFpbmVyTGlzdChjb250cm9sTGlzdFswXSkKICAgICAgICAgIDogdGhpcy5nZXRDb250YWluZXJMaXN0KHNlbENvbnRyb2xbMF0pLAogICAgICAgIHNlbGVjdGVkOiBpc0dyb3VwID8gY29udHJvbExpc3QgOiBbc2VsQ29udHJvbF0KICAgICAgfQogICAgfSkKICB9CgogIC8qKgogICAqIEBkZXNjcmlwdGlvbiBUbyBnZW5lcmF0ZSBuZXcgR3JvdXBJRAogICAqIEBmdW5jdGlvbiBjcmVhdGVHcm91cElkCiAgICovCiAgY3JlYXRlR3JvdXBJZCAoKSB7CiAgICBsZXQgbGFzdENvbnRyb2xJZCA9IDAKICAgIGZvciAobGV0IGkgb2YgdGhpcy5ncm91cGVkQ29udHJvbHNbdGhpcy51c2VyRm9ybUlkXSEuZ3JvdXBBcnJheSEpIHsKICAgICAgaWYgKGkuaW5kZXhPZignZ3JvdXAnKSAhPT0gLTEpIHsKICAgICAgICBjb25zdCBJZE51bSA9IGkuc3BsaXQoJ2dyb3VwJykucG9wKCkgfHwgJy0xJwogICAgICAgIGNvbnN0IHBhc3JlSWQgPSBwYXJzZUludChJZE51bSwgMTApCiAgICAgICAgaWYgKCFpc05hTihwYXNyZUlkKSAmJiBsYXN0Q29udHJvbElkIDwgcGFzcmVJZCkgewogICAgICAgICAgbGFzdENvbnRyb2xJZCA9IHBhc3JlSWQKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBgZ3JvdXAke2xhc3RDb250cm9sSWQgKyAxfWAKICB9CgogIEBFbWl0KCdjcmVhdGVHcm91cCcpCiAgY3JlYXRlR3JvdXAgKGdyb3VwSWQ6IHN0cmluZykgewogICAgcmV0dXJuIGdyb3VwSWQKICB9CgogIHVwZGF0ZUNvbnRyb2xHcm91cElEIChncm91cE5hbWU6IHN0cmluZywgdXBkYXRlR3JvdXBJZDogc3RyaW5nKSB7CiAgICBmb3IgKGNvbnN0IHZhbCBpbiB0aGlzLnVzZXJmb3JtRGF0YVt0aGlzLnVzZXJGb3JtSWRdKSB7CiAgICAgIGlmICghdmFsLnN0YXJ0c1dpdGgoJ0lEX1VTRVJGT1JNJykpIHsKICAgICAgICBjb25zdCBjb250cm9sR3JwSWQgPSB0aGlzLnVzZXJmb3JtRGF0YVt0aGlzLnVzZXJGb3JtSWRdW3ZhbF0ucHJvcGVydGllcwogICAgICAgICAgLkdyb3VwSUQKICAgICAgICBpZiAoY29udHJvbEdycElkID09PSBncm91cE5hbWUpIHsKICAgICAgICAgIHRoaXMudXBkYXRlQ29udHJvbFByb3BlcnR5KCdHcm91cElEJywgdXBkYXRlR3JvdXBJZCwgdmFsKQogICAgICAgIH0KICAgICAgfQogICAgfQogIH0KICAvKioKICAgKiBAZGVzY3JpcHRpb24gVG8gdXBkYXRlIHRoZSBncm91cCBJbmZvcm1hdGlvbiBpbiBtYWluIGRhdGEKICAgKiBAZnVuY3Rpb24gZ3JvdXBDb250cm9sCiAgICovCiAgZ3JvdXBDb250cm9sICgpIHsKICAgIGxldCB1cGRhdGVHcm91cElkOiBzdHJpbmcgPSAnJwogICAgY29uc3Qgc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkQ29udHJvbHNbdGhpcy51c2VyRm9ybUlkXS5zZWxlY3RlZAoKICAgIGNvbnN0IHNlbGVjdGVkR3JvdXBBcnJheSA9IHNlbGVjdGVkLmZpbHRlcigKICAgICAgKHZhbDogc3RyaW5nKSA9PiB2YWwuc3RhcnRzV2l0aCgnZ3JvdXAnKSAmJiB2YWwKICAgICkKICAgIHVwZGF0ZUdyb3VwSWQgPSBzZWxlY3RlZEdyb3VwQXJyYXlbMF0KICAgIGlmIChzZWxlY3RlZEdyb3VwQXJyYXkubGVuZ3RoID49IDIpIHsKICAgICAgY29uc3QgZ3JvdXBBcnJheSA9IFsKICAgICAgICAuLi50aGlzLmdyb3VwZWRDb250cm9sc1t0aGlzLnVzZXJGb3JtSWRdIS5ncm91cEFycmF5IQogICAgICBdCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBBcnJheS5sZW5ndGg7IGkrKykgewogICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2VsZWN0ZWRHcm91cEFycmF5Lmxlbmd0aDsgaisrKSB7CiAgICAgICAgICBpZiAoc2VsZWN0ZWRHcm91cEFycmF5W2pdID09PSBncm91cEFycmF5W2ldKSB7CiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udHJvbEdyb3VwSUQoZ3JvdXBBcnJheVtpXSwgc2VsZWN0ZWRHcm91cEFycmF5WzBdKQogICAgICAgICAgICBncm91cEFycmF5LnNwbGljZShpLCAxKQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICB0aGlzLnVwZGF0ZUdyb3VwKHsKICAgICAgICB1c2VyRm9ybUlkOiB0aGlzLnVzZXJGb3JtSWQsCiAgICAgICAgZ3JvdXBBcnJheTogWy4uLmdyb3VwQXJyYXksIHNlbGVjdGVkR3JvdXBBcnJheVswXV0KICAgICAgfSkKICAgICAgdXBkYXRlR3JvdXBJZCA9IHNlbGVjdGVkR3JvdXBBcnJheVswXSEKICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRHcm91cEFycmF5Lmxlbmd0aCA9PT0gMCkgewogICAgICB1cGRhdGVHcm91cElkID0gdGhpcy5jcmVhdGVHcm91cElkKCkKICAgICAgY29uc3QgZ3JvdXBBcnJheSA9IFsKICAgICAgICAuLi50aGlzLmdyb3VwZWRDb250cm9sc1t0aGlzLnVzZXJGb3JtSWRdIS5ncm91cEFycmF5ISwKICAgICAgICB1cGRhdGVHcm91cElkCiAgICAgIF0KICAgICAgdGhpcy51cGRhdGVHcm91cCh7IHVzZXJGb3JtSWQ6IHRoaXMudXNlckZvcm1JZCwgZ3JvdXBBcnJheTogZ3JvdXBBcnJheSB9KQogICAgfQoKICAgIGZvciAobGV0IHZhbCBvZiBzZWxlY3RlZCkgewogICAgICBpZiAoIXZhbC5zdGFydHNXaXRoKCdncm91cCcpKSB7CiAgICAgICAgdGhpcy51cGRhdGVDb250cm9sUHJvcGVydHkoJ0dyb3VwSUQnLCB1cGRhdGVHcm91cElkLCB2YWwpCiAgICAgIH0KICAgIH0KICAgIHRoaXMuY3JlYXRlR3JvdXAodXBkYXRlR3JvdXBJZCkKICAgIHRoaXMuc2VsZWN0Q29udHJvbCh7CiAgICAgIHVzZXJGb3JtSWQ6IHRoaXMudXNlckZvcm1JZCwKICAgICAgc2VsZWN0OiB7CiAgICAgICAgY29udGFpbmVyOiB0aGlzLmdldENvbnRhaW5lckxpc3QodXBkYXRlR3JvdXBJZCksCiAgICAgICAgc2VsZWN0ZWQ6IFt1cGRhdGVHcm91cElkXQogICAgICB9CiAgICB9KQogIH0KCiAgLyoqCiAgICogQGRlc2NyaXB0aW9uIFRvIHNlbGVjdCBhbGwgdGhlIGNvbnRyb2xzIGluIHJlc3BlY3RpdmUgY29udGFpbmVyIHByZXNlbnQgaW4gcmVzcGVjdGl2ZSB1c2VyZm9ybQogICAqIEBmdW5jdGlvbiBzZWxlY3RBbGwKICAgKi8KICBzZWxlY3RBbGwgKCkgewogICAgY29uc3QgY29udHJvbE9iamVjdExpc3QgPSBbCiAgICAgIC4uLnRoaXMudXNlcmZvcm1EYXRhW3RoaXMudXNlckZvcm1JZF1bdGhpcy5jb250YWluZXJJZF0uY29udHJvbHMKICAgIF0KICAgIGNvbnN0IHNlbGVjZWRHcm91cDogc3RyaW5nW10gPSBbXQogICAgZm9yIChjb25zdCB2YWwgb2YgY29udHJvbE9iamVjdExpc3QpIHsKICAgICAgY29uc3QgY29udHJvbEdyb3VwSWQ6IHN0cmluZyA9IHRoaXMudXNlcmZvcm1EYXRhW3RoaXMudXNlckZvcm1JZF1bdmFsXQogICAgICAgIC5wcm9wZXJ0aWVzLkdyb3VwSUQhCiAgICAgIGlmIChjb250cm9sR3JvdXBJZCAmJiBjb250cm9sR3JvdXBJZCAhPT0gJycpIHsKICAgICAgICAhc2VsZWNlZEdyb3VwLmluY2x1ZGVzKGNvbnRyb2xHcm91cElkKSEgJiYKICAgICAgICAgIHNlbGVjZWRHcm91cC5wdXNoKGNvbnRyb2xHcm91cElkKQogICAgICB9IGVsc2UgewogICAgICAgIHNlbGVjZWRHcm91cC5wdXNoKHZhbCkKICAgICAgfQogICAgfQoKICAgIGlmIChjb250cm9sT2JqZWN0TGlzdC5sZW5ndGggIT09IDApIHsKICAgICAgdGhpcy5zZWxlY3RDb250cm9sKHsKICAgICAgICB1c2VyRm9ybUlkOiB0aGlzLnVzZXJGb3JtSWQsCiAgICAgICAgc2VsZWN0OiB7CiAgICAgICAgICBjb250YWluZXI6IHRoaXMuZ2V0Q29udGFpbmVyTGlzdChzZWxlY2VkR3JvdXBbMF0pLAogICAgICAgICAgc2VsZWN0ZWQ6IFsuLi5zZWxlY2VkR3JvdXBdCiAgICAgICAgfQogICAgICB9KQogICAgfQogIH0KCiAgLyoqCiAgICogQGRlc2NyaXB0aW9uIFRvIHVwZGF0ZSB0aGUgY3V0dGVkIGNvbnRyb2xzIGluIHJlc3BlY3RpdmUgY29udGFpbmVyIHByZXNlbnQgaW4gcmVzcGVjdGl2ZSB1c2VyZm9ybQogICAqIEBmdW5jdGlvbiBjdXRDb250cm9sCiAgICovCiAgY3V0Q29udHJvbCAoKSB7CiAgICB0aGlzLmNvcHlDb250cm9sKCdjdXQnKQogICAgdGhpcy5jbGlja0RlbGV0ZSgpCiAgfQoKICAvKioKICAgKiBAZGVzY3JpcHRpb24gVG8gdXBkYXRlIHRoZSBjb3BpZWQgY29udHJvbHMgaW4gcmVzcGVjdGl2ZSBjb250YWluZXIgcHJlc2VudCBpbiByZXNwZWN0aXZlIHVzZXJmb3JtCiAgICogQGZ1bmN0aW9uIGNvcHlDb250cm9sCiAgICovCiAgY29weUNvbnRyb2wgKHR5cGU6IHN0cmluZykgewogICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvcGllZENvbnRyb2xbdGhpcy51c2VyRm9ybUlkXVt0aGlzLnVzZXJGb3JtSWRdLmNvbnRyb2xzLmxlbmd0aDsgaSsrKSB7CiAgICAgIHRoaXMuZGVsZXRlQ29waWVkQ29udHJvbCh7CiAgICAgICAgdXNlckZvcm1JZDogdGhpcy51c2VyRm9ybUlkLAogICAgICAgIHBhcmVudElkOiB0aGlzLnVzZXJGb3JtSWQsCiAgICAgICAgdGFyZ2V0SWQ6IHRoaXMuY29waWVkQ29udHJvbFt0aGlzLnVzZXJGb3JtSWRdW3RoaXMudXNlckZvcm1JZF0uY29udHJvbHNbaV0KICAgICAgfSkKICAgIH0KICAgIGNvbnN0IHVzZXJGb3JtRGF0YSA9IHRoaXMudXNlcmZvcm1EYXRhW3RoaXMudXNlckZvcm1JZF0KICAgIGNvbnN0IHNlbENvbnRhaW5lciA9IHRoaXMuc2VsZWN0ZWRDb250cm9sc1t0aGlzLnVzZXJGb3JtSWRdLmNvbnRhaW5lclswXQogICAgY29uc3Qgc2VsU2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkQ29udHJvbHNbdGhpcy51c2VyRm9ybUlkXS5zZWxlY3RlZAogICAgY29uc3QgdXBkYXRlU2VsZWN0ZWQgPSBbXQogICAgZm9yIChsZXQgY29udHJvbCBvZiBzZWxTZWxlY3RlZCkgewogICAgICBpZiAoIWNvbnRyb2wuc3RhcnRzV2l0aCgnZ3JvdXAnKSAmJiB1c2VyRm9ybURhdGFbY29udHJvbF0udHlwZSA9PT0gJ1BhZ2UnKSB7CiAgICAgICAgY29udHJvbCA9IHRoaXMuZ2V0Q29udGFpbmVyTGlzdChjb250cm9sKVswXQogICAgICB9CiAgICAgIHVwZGF0ZVNlbGVjdGVkLnB1c2goY29udHJvbCkKICAgIH0KICAgIHRoaXMudXBkYXRlQ29weUNvbnRyb2xMaXN0KHsKICAgICAgdXNlckZvcm1JZDogdGhpcy51c2VyRm9ybUlkLAogICAgICBwYXJlbnRJZDogc2VsQ29udGFpbmVyLAogICAgICB0YXJnZXRJZDogdXBkYXRlU2VsZWN0ZWQsCiAgICAgIHR5cGU6IHR5cGUKICAgIH0pCgogICAgY29uc3QgcmVjQ29weUNvbnRyb2wgPSAoZGFUYXJnZXQ6IHN0cmluZykgPT4gewogICAgICBjb25zdCBkYVRhcmdldENvbnRyb2xzID0gdXNlckZvcm1EYXRhW2RhVGFyZ2V0XS5jb250cm9scwogICAgICBpZiAoZGFUYXJnZXRDb250cm9scy5sZW5ndGggPiAwKSB7CiAgICAgICAgZm9yIChsZXQgaSBpbiBkYVRhcmdldENvbnRyb2xzKSB7CiAgICAgICAgICBjb25zdCBjb250cm9sT2JqZWN0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh1c2VyRm9ybURhdGFbZGFUYXJnZXRDb250cm9sc1tpXV0pKQogICAgICAgICAgY29uc3QgY29udHJvbEFycmF5ID0gW10KICAgICAgICAgIGNvbnN0IGN0cmxPYmogPSB7IC4uLmNvbnRyb2xPYmplY3QsIGNvbnRyb2xzOiBbXSB9CiAgICAgICAgICB0aGlzLmFkZENvcGllZENvbnRyb2woewogICAgICAgICAgICB1c2VyRm9ybUlkOiB0aGlzLnVzZXJGb3JtSWQsCiAgICAgICAgICAgIGNvbnRyb2xJZDogZGFUYXJnZXQsCiAgICAgICAgICAgIGFkZElkOiBkYVRhcmdldENvbnRyb2xzW2ldLAogICAgICAgICAgICBpdGVtOiBjdHJsT2JqCiAgICAgICAgICB9KQogICAgICAgICAgcmVjQ29weUNvbnRyb2woZGFUYXJnZXRDb250cm9sc1tpXSkKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICBmb3IgKGxldCBrZXkgb2Ygc2VsU2VsZWN0ZWQpIHsKICAgICAgaWYgKCFrZXkuc3RhcnRzV2l0aCgnZ3JvdXAnKSkgewogICAgICAgIGlmICh1c2VyRm9ybURhdGFba2V5XS50eXBlID09PSAnUGFnZScpIHsKICAgICAgICAgIGtleSA9IHRoaXMuZ2V0Q29udGFpbmVyTGlzdChrZXkpWzBdCiAgICAgICAgfQogICAgICAgIGNvbnN0IGNvbnRyb2xPYmplY3QgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHVzZXJGb3JtRGF0YVtrZXldKSkKICAgICAgICBjb25zdCBjdHJsT2JqID0geyAuLi5jb250cm9sT2JqZWN0LCBjb250cm9sczogW10gfQogICAgICAgIHRoaXMuYWRkQ29waWVkQ29udHJvbCh7CiAgICAgICAgICB1c2VyRm9ybUlkOiB0aGlzLnVzZXJGb3JtSWQsCiAgICAgICAgICBjb250cm9sSWQ6IHRoaXMudXNlckZvcm1JZCwKICAgICAgICAgIGFkZElkOiBrZXksCiAgICAgICAgICBpdGVtOiBjdHJsT2JqCiAgICAgICAgfSkKICAgICAgICByZWNDb3B5Q29udHJvbChrZXkpCiAgICAgIH0gZWxzZSB7CiAgICAgICAgZm9yIChsZXQgY3RybElkIGluIHVzZXJGb3JtRGF0YSkgewogICAgICAgICAgY29uc3QgY29udHJvbFByb3AgPSB1c2VyRm9ybURhdGFbY3RybElkXS5wcm9wZXJ0aWVzLkdyb3VwSUQKICAgICAgICAgIGlmIChjb250cm9sUHJvcCkgewogICAgICAgICAgICBpZiAoY29udHJvbFByb3AgPT09IGtleSkgewogICAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xPYmplY3QgPSBKU09OLnBhcnNlKAogICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkodXNlckZvcm1EYXRhW2N0cmxJZF0pCiAgICAgICAgICAgICAgKQogICAgICAgICAgICAgIGNvbnN0IGN0cmxPYmogPSB7IC4uLmNvbnRyb2xPYmplY3QsIGNvbnRyb2xzOiBbXSB9CiAgICAgICAgICAgICAgdGhpcy5hZGRDb3BpZWRDb250cm9sKHsKICAgICAgICAgICAgICAgIHVzZXJGb3JtSWQ6IHRoaXMudXNlckZvcm1JZCwKICAgICAgICAgICAgICAgIGNvbnRyb2xJZDogdGhpcy51c2VyRm9ybUlkLAogICAgICAgICAgICAgICAgYWRkSWQ6IGN0cmxJZCwKICAgICAgICAgICAgICAgIGl0ZW06IGN0cmxPYmoKICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgIHJlY0NvcHlDb250cm9sKGN0cmxJZCkKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfQogIH0KICB1cGRhdGVOZXdDb250cm9sIChwYXJlbnRJZDogc3RyaW5nLCBjdHJsSWQ6IHN0cmluZywgY3RybE9iajogY29udHJvbERhdGEsIGlzUGFyZW50OiBib29sZWFuKSB7CiAgICB0aGlzLmFkZENvbnRyb2woewogICAgICB1c2VyRm9ybUlkOiB0aGlzLnVzZXJGb3JtSWQsCiAgICAgIGNvbnRyb2xJZDogcGFyZW50SWQsCiAgICAgIGFkZElkOiBjdHJsSWQsCiAgICAgIGl0ZW06IGN0cmxPYmoKICAgIH0pCiAgICBpZiAoaXNQYXJlbnQpIHsKICAgICAgY29uc3QgbmV3VGFiSW5kZXggPSB0aGlzLnVzZXJmb3JtRGF0YVt0aGlzLnVzZXJGb3JtSWRdW3BhcmVudElkXS5jb250cm9scy5sZW5ndGgKICAgICAgdGhpcy51cGRhdGVUYWJJbmRleFZhbHVlKGN0cmxJZCkKICAgICAgdGhpcy51cGRhdGVaSW5kZXhWYWx1ZShjdHJsSWQpCiAgICB9CiAgfQoKICBuZXdQYXN0ZUNvbnRyb2xJZCAoa2V5OiBzdHJpbmcsIHBhcmVudElkOiBzdHJpbmcpIHsKICAgIGNvbnN0IHVzZXJGb3JtRGF0YSA9IHRoaXMudXNlcmZvcm1EYXRhW3RoaXMudXNlckZvcm1JZF0KICAgIGxldCBsYXN0Q29udHJvbElkID0gMAogICAgY29uc3QgdHlwZSA9IGtleSBpbiB1c2VyRm9ybURhdGEgPyB1c2VyRm9ybURhdGFba2V5XS50eXBlIDogJycKICAgIGNvbnN0IHBhcmVudE5hbWUgPSBwYXJlbnRJZCAhPT0gJycgPyBwYXJlbnRJZC5zcGxpdCgnTXVsdGlQYWdlJykucG9wKCkgOiAtMQogICAgY29uc3Qgc2VsZWN0ZWRDb250cm9sTmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkID0KICAgIHR5cGUgPT09ICdQYWdlJwogICAgICA/IGBQYWdlJHtwYXJlbnROYW1lfV9gCiAgICAgIDoga2V5LnJlcGxhY2UoL1swLTldL2csICcnKS5zcGxpdCgnXycpLnBvcCgpCiAgICBjb25zdCB1c2VyZm9ybUNvbnRyb2xJZHMgPSBPYmplY3Qua2V5cyh1c2VyRm9ybURhdGEpCiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVzZXJmb3JtQ29udHJvbElkcy5sZW5ndGg7IGkrKykgewogICAgICBpZiAodXNlcmZvcm1Db250cm9sSWRzW2ldLmluZGV4T2Yoc2VsZWN0ZWRDb250cm9sTmFtZSEpICE9PSAtMSkgewogICAgICAgIGNvbnN0IElkTnVtID0gdXNlcmZvcm1Db250cm9sSWRzW2ldLnNwbGl0KHNlbGVjdGVkQ29udHJvbE5hbWUhKS5wb3AoKSB8fCAnLTEnCiAgICAgICAgY29uc3QgcGFzcmVJZCA9IHBhcnNlSW50KElkTnVtLCAxMCkKICAgICAgICBpZiAoIWlzTmFOKHBhc3JlSWQpICYmIGxhc3RDb250cm9sSWQgPCBwYXNyZUlkKSB7CiAgICAgICAgICBsYXN0Q29udHJvbElkID0gcGFzcmVJZAogICAgICAgIH0KICAgICAgfQogICAgfQogICAgbGFzdENvbnRyb2xJZCArPSAxCiAgICBjb25zdCBOYW1lID0gYCR7c2VsZWN0ZWRDb250cm9sTmFtZX0ke2xhc3RDb250cm9sSWR9YAogICAgcmV0dXJuIE5hbWUKICB9CiAgcmVtb3ZlQ2hpbGRDb250cm9sIChkYVRhcmdldDogc3RyaW5nLCBkZWxldGVDb250cm9sOiBzdHJpbmcpIHsKICAgIGNvbnN0IHJlbW92ZUNvbnRyb2wgPSBbLi4udGhpcy51c2VyZm9ybURhdGFbdGhpcy51c2VyRm9ybUlkXVtkYVRhcmdldF0uY29udHJvbHNdCiAgICBjb25zdCByZW1vdmVJbmRleCA9IHJlbW92ZUNvbnRyb2wuZmluZEluZGV4KCh2YWwpID0+IHZhbCA9PT0gZGVsZXRlQ29udHJvbCkKICAgIHJlbW92ZUNvbnRyb2wuc3BsaWNlKHJlbW92ZUluZGV4LCAxKQogICAgdGhpcy5zZXRDaGlsZENvbnRyb2xzKHsKICAgICAgdXNlckZvcm1JZDogdGhpcy51c2VyRm9ybUlkLAogICAgICBjb250YWluZXJJZDogZGFUYXJnZXQsCiAgICAgIHRhcmdldENvbnRyb2xzOiByZW1vdmVDb250cm9sCiAgICB9KQogIH0KICAvKioKICAgKiBAZGVzY3JpcHRpb24gVG8gcGFzdGUgY29udHJvbHMgaW4gcmVzcGVjdGl2ZSBjb250YWluZXIgcHJlc2VudCBpbiByZXNwZWN0aXZlIHVzZXJmb3JtCiAgICogQGZ1bmN0aW9uIHBhc3RlQ29udHJvbAogICAqLwogIHBhc3RlQ29udHJvbCAoKSB7CiAgICBpZiAodGhpcy5jb3B5Q29udHJvbExpc3QudHlwZSA9PT0gJ2NvcHknKSB7CiAgICAgIGNvbnN0IHNlbENvbnRhaW5lciA9IHRoaXMuY29weUNvbnRyb2xMaXN0LnBhcmVudElkCiAgICAgIGNvbnN0IHNlbFNlbGVjdGVkID0gdGhpcy5jb3B5Q29udHJvbExpc3QudGFyZ2V0SWQKICAgICAgY29uc3QgdXNlckZvcm1EYXRhID0gdGhpcy51c2VyZm9ybURhdGFbdGhpcy51c2VyRm9ybUlkXQogICAgICBjb25zdCBwcmVzZW50R3JvdXBJZDogc3RyaW5nW10gPSBbXQogICAgICBjb25zdCBuZXdHcm91cElkOiBzdHJpbmdbXSA9IFtdCiAgICAgIGNvbnN0IG9sZENvbnRyb2xJZDogc3RyaW5nW10gPSBbXQogICAgICBjb25zdCBuZXdDb250cm9sSWQ6IHN0cmluZ1tdID0gW10KCiAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuY29waWVkQ29udHJvbFt0aGlzLnVzZXJGb3JtSWRdKSB7CiAgICAgICAgY29uc3QgY29udHJvbFByb3AgPSB0aGlzLmNvcGllZENvbnRyb2xbdGhpcy51c2VyRm9ybUlkXVtrZXldLnByb3BlcnRpZXMuR3JvdXBJRAogICAgICAgIGlmIChjb250cm9sUHJvcCAmJiAhcHJlc2VudEdyb3VwSWQuaW5jbHVkZXMoY29udHJvbFByb3ApKSB7CiAgICAgICAgICBwcmVzZW50R3JvdXBJZC5wdXNoKGNvbnRyb2xQcm9wKQogICAgICAgIH0KICAgICAgfQogICAgICBmb3IgKGxldCBqIGluIHByZXNlbnRHcm91cElkKSB7CiAgICAgICAgY29uc3QgbmV3SWQgPSB0aGlzLmNyZWF0ZUdyb3VwSWQoKQogICAgICAgIG5ld0dyb3VwSWQucHVzaChuZXdJZCkKICAgICAgICBsZXQgZ3JvdXBBcnJheTogc3RyaW5nW10gPSBbCiAgICAgICAgICAuLi50aGlzLmdyb3VwZWRDb250cm9sc1t0aGlzLnVzZXJGb3JtSWRdIS5ncm91cEFycmF5ISwKICAgICAgICAgIG5ld0lkCiAgICAgICAgXQogICAgICAgIHRoaXMudXBkYXRlR3JvdXAoewogICAgICAgICAgdXNlckZvcm1JZDogdGhpcy51c2VyRm9ybUlkLAogICAgICAgICAgZ3JvdXBBcnJheTogZ3JvdXBBcnJheSEKICAgICAgICB9KQogICAgICB9CgogICAgICBjb25zdCByZWNDb3B5Q29udHJvbCA9IChkYVRhcmdldDogc3RyaW5nKSA9PiB7CiAgICAgICAgY29uc3QgZGFUYXJnZXRDb250cm9scyA9IHVzZXJGb3JtRGF0YVtkYVRhcmdldF0uY29udHJvbHMKICAgICAgICBpZiAoZGFUYXJnZXRDb250cm9scy5sZW5ndGggPiAwKSB7CiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGltaXQgPSBkYVRhcmdldENvbnRyb2xzLmxlbmd0aDsgaSA8IGxpbWl0OyBpKyspIHsKICAgICAgICAgICAgY29uc3Qga2V5ID0gZGFUYXJnZXRDb250cm9sc1tpXQogICAgICAgICAgICBjb25zdCBOYW1lID0gdGhpcy5uZXdQYXN0ZUNvbnRyb2xJZChrZXksIGRhVGFyZ2V0KQogICAgICAgICAgICBjb25zdCBjb250cm9sSUQ6fCBzdHJpbmd8IHVuZGVmaW5lZCA9IGBJRF8ke05hbWV9YAogICAgICAgICAgICBjb25zdCBjb250cm9sT2JqID0geyAuLi50aGlzLmNvcGllZENvbnRyb2xbdGhpcy51c2VyRm9ybUlkXVtrZXldIH0KICAgICAgICAgICAgbGV0IGdyb3VwSWRJbmRleCA9IC0xCiAgICAgICAgICAgIGdyb3VwSWRJbmRleCA9IHByZXNlbnRHcm91cElkLmZpbmRJbmRleCgodmFsKSA9PiB2YWwgPT09IGNvbnRyb2xPYmoucHJvcGVydGllcy5Hcm91cElEKQogICAgICAgICAgICBjb25zdCBpdGVtOiBjb250cm9sRGF0YSA9IHsKICAgICAgICAgICAgICAuLi5jb250cm9sT2JqLAogICAgICAgICAgICAgIHByb3BlcnRpZXM6IHsKICAgICAgICAgICAgICAgIC4uLmNvbnRyb2xPYmoucHJvcGVydGllcywKICAgICAgICAgICAgICAgIElEOiBjb250cm9sSUQhLAogICAgICAgICAgICAgICAgR3JvdXBJRDogZ3JvdXBJZEluZGV4ICE9PSAtMSA/IG5ld0dyb3VwSWRbZ3JvdXBJZEluZGV4XSA6ICcnLAogICAgICAgICAgICAgICAgTmFtZTogTmFtZQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLnJlbW92ZUNoaWxkQ29udHJvbChkYVRhcmdldCwga2V5KQogICAgICAgICAgICB0aGlzLnVwZGF0ZU5ld0NvbnRyb2woZGFUYXJnZXQsIGNvbnRyb2xJRCwgaXRlbSwgZmFsc2UpCiAgICAgICAgICAgIHJlY0NvcHlDb250cm9sKGNvbnRyb2xJRCkKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIGZvciAoY29uc3Qga2V5IG9mIHNlbFNlbGVjdGVkKSB7CiAgICAgICAgaWYgKCFrZXkuc3RhcnRzV2l0aCgnZ3JvdXAnKSkgewogICAgICAgICAgb2xkQ29udHJvbElkLnB1c2goa2V5KQogICAgICAgICAgY29uc3QgTmFtZSA9IHRoaXMubmV3UGFzdGVDb250cm9sSWQoa2V5LCAnJykKICAgICAgICAgIGNvbnN0IGNvbnRyb2xJRDp8IHN0cmluZ3wgdW5kZWZpbmVkID0gYElEXyR7TmFtZX1gCiAgICAgICAgICBjb25zdCBjb250cm9sT2JqID0geyAuLi50aGlzLmNvcGllZENvbnRyb2xbdGhpcy51c2VyRm9ybUlkXVtrZXldIH0KICAgICAgICAgIG5ld0NvbnRyb2xJZC5wdXNoKGNvbnRyb2xJRCkKICAgICAgICAgIGxldCBncm91cElkSW5kZXggPSAtMQogICAgICAgICAgZ3JvdXBJZEluZGV4ID0gcHJlc2VudEdyb3VwSWQuZmluZEluZGV4KAogICAgICAgICAgICAodmFsKSA9PiBjb250cm9sT2JqLnByb3BlcnRpZXMuR3JvdXBJRCA9PT0gdmFsCiAgICAgICAgICApCiAgICAgICAgICBpZiAoc2VsU2VsZWN0ZWQubGVuZ3RoID09PSAxICYmIHRoaXMuY29waWVkQ29udHJvbFt0aGlzLnVzZXJGb3JtSWRdW3NlbFNlbGVjdGVkWzBdXS5wcm9wZXJ0aWVzLkdyb3VwSUQgIT09ICcnKSB7CiAgICAgICAgICAgIGdyb3VwSWRJbmRleCA9IC0xCiAgICAgICAgICB9CiAgICAgICAgICBjb25zdCBpdGVtOiBjb250cm9sRGF0YSA9IHsKICAgICAgICAgICAgLi4uY29udHJvbE9iaiwKICAgICAgICAgICAgcHJvcGVydGllczogewogICAgICAgICAgICAgIC4uLmNvbnRyb2xPYmoucHJvcGVydGllcywKICAgICAgICAgICAgICBJRDogY29udHJvbElEISwKICAgICAgICAgICAgICBMZWZ0OiBjb250cm9sT2JqLnByb3BlcnRpZXMuTGVmdCEgKyAxMCwKICAgICAgICAgICAgICBUb3A6IGNvbnRyb2xPYmoucHJvcGVydGllcy5Ub3AhICsgMTAsCiAgICAgICAgICAgICAgR3JvdXBJRDogZ3JvdXBJZEluZGV4ICE9PSAtMSA/IG5ld0dyb3VwSWRbZ3JvdXBJZEluZGV4XSA6ICcnLAogICAgICAgICAgICAgIE5hbWU6IE5hbWUKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgdGhpcy51cGRhdGVOZXdDb250cm9sKHRoaXMuY29udGFpbmVySWQsIGNvbnRyb2xJRCwgaXRlbSwgdHJ1ZSkKICAgICAgICAgIHJlY0NvcHlDb250cm9sKGNvbnRyb2xJRCkKICAgICAgICB9IGVsc2UgewogICAgICAgICAgZm9yIChsZXQgY3RybElkIGluIHRoaXMuY29waWVkQ29udHJvbFt0aGlzLnVzZXJGb3JtSWRdKSB7CiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xQcm9wID0gdGhpcy5jb3BpZWRDb250cm9sW3RoaXMudXNlckZvcm1JZF1bY3RybElkXQogICAgICAgICAgICAgIC5wcm9wZXJ0aWVzLkdyb3VwSUQKICAgICAgICAgICAgaWYgKGNvbnRyb2xQcm9wKSB7CiAgICAgICAgICAgICAgaWYgKGNvbnRyb2xQcm9wID09PSBrZXkpIHsKICAgICAgICAgICAgICAgIGNvbnN0IE5hbWUgPSB0aGlzLm5ld1Bhc3RlQ29udHJvbElkKGN0cmxJZCwgJycpCiAgICAgICAgICAgICAgICBjb25zdCBjb250cm9sSUQ6fCBzdHJpbmd8IHVuZGVmaW5lZCA9IGBJRF8ke05hbWV9YAogICAgICAgICAgICAgICAgY29uc3QgY29udHJvbE9iaiA9IHRoaXMuY29waWVkQ29udHJvbFt0aGlzLnVzZXJGb3JtSWRdW2N0cmxJZF0KCiAgICAgICAgICAgICAgICBsZXQgZ3JvdXBJZEluZGV4ID0gLTEKICAgICAgICAgICAgICAgIGdyb3VwSWRJbmRleCA9IHByZXNlbnRHcm91cElkLmZpbmRJbmRleCgKICAgICAgICAgICAgICAgICAgKHZhbCkgPT4gY29udHJvbE9iai5wcm9wZXJ0aWVzLkdyb3VwSUQgPT09IHZhbAogICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgY29uc3QgaXRlbTogY29udHJvbERhdGEgPSB7CiAgICAgICAgICAgICAgICAgIC4uLmNvbnRyb2xPYmosCiAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHsKICAgICAgICAgICAgICAgICAgICAuLi5jb250cm9sT2JqLnByb3BlcnRpZXMsCiAgICAgICAgICAgICAgICAgICAgSUQ6IGNvbnRyb2xJRCEsCiAgICAgICAgICAgICAgICAgICAgTGVmdDogY29udHJvbE9iai5wcm9wZXJ0aWVzLkxlZnQhICsgMTAsCiAgICAgICAgICAgICAgICAgICAgVG9wOiBjb250cm9sT2JqLnByb3BlcnRpZXMuVG9wISArIDEwLAogICAgICAgICAgICAgICAgICAgIEdyb3VwSUQ6IGdyb3VwSWRJbmRleCAhPT0gLTEgPyBuZXdHcm91cElkW2dyb3VwSWRJbmRleF0gOiAnJywKICAgICAgICAgICAgICAgICAgICBOYW1lOiBOYW1lCiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTmV3Q29udHJvbCh0aGlzLmNvbnRhaW5lcklkLCBjb250cm9sSUQsIGl0ZW0sIHRydWUpCiAgICAgICAgICAgICAgICByZWNDb3B5Q29udHJvbChjb250cm9sSUQpCiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGZvciAobGV0IGogb2YgbmV3R3JvdXBJZCkgewogICAgICAgIHRoaXMuY3JlYXRlR3JvdXAoaikKICAgICAgfQogICAgICBjb25zdCBuZXdTZWxlY3RlZDogc3RyaW5nW10gPSBbXQogICAgICBmb3IgKGNvbnN0IGNvbnRyb2wgb2Ygc2VsU2VsZWN0ZWQpIHsKICAgICAgICBpZiAoY29udHJvbC5zdGFydHNXaXRoKCdncm91cCcpKSB7CiAgICAgICAgICBjb25zdCBpbmRleCA9IHByZXNlbnRHcm91cElkLmZpbmRJbmRleCgodmFsKSA9PiB2YWwgPT09IGNvbnRyb2wpCiAgICAgICAgICBuZXdTZWxlY3RlZC5wdXNoKG5ld0dyb3VwSWRbaW5kZXhdKQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjb25zdCBpbmRleCA9IG9sZENvbnRyb2xJZC5maW5kSW5kZXgoKHZhbCkgPT4gdmFsID09PSBjb250cm9sKQogICAgICAgICAgbmV3U2VsZWN0ZWQucHVzaChuZXdDb250cm9sSWRbaW5kZXhdKQogICAgICAgIH0KICAgICAgfQogICAgICB0aGlzLnNlbGVjdENvbnRyb2woewogICAgICAgIHVzZXJGb3JtSWQ6IHRoaXMudXNlckZvcm1JZCwKICAgICAgICBzZWxlY3Q6IHsKICAgICAgICAgIGNvbnRhaW5lcjogdGhpcy5nZXRDb250YWluZXJMaXN0KG5ld1NlbGVjdGVkWzBdKSwKICAgICAgICAgIHNlbGVjdGVkOiBuZXdTZWxlY3RlZAogICAgICAgIH0KICAgICAgfSkKICAgIH0gZWxzZSBpZiAodGhpcy5jb3B5Q29udHJvbExpc3QudHlwZSA9PT0gJ2N1dCcpIHsKICAgICAgY29uc3Qgc2VsQ29udGFpbmVyID0gdGhpcy5jb3B5Q29udHJvbExpc3QucGFyZW50SWQKICAgICAgY29uc3Qgc2VsU2VsZWN0ZWQgPSB0aGlzLmNvcHlDb250cm9sTGlzdC50YXJnZXRJZAogICAgICBjb25zdCB1c2VyRm9ybURhdGEgPSB0aGlzLmNvcGllZENvbnRyb2xbdGhpcy51c2VyRm9ybUlkXQogICAgICBjb25zdCByZWNDb3B5Q29udHJvbCA9IChkYVRhcmdldDogc3RyaW5nKSA9PiB7CiAgICAgICAgY29uc3QgZGFUYXJnZXRDb250cm9scyA9IHVzZXJGb3JtRGF0YVtkYVRhcmdldF0uY29udHJvbHMKICAgICAgICBpZiAoZGFUYXJnZXRDb250cm9scy5sZW5ndGggPiAwKSB7CiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGltaXQgPSBkYVRhcmdldENvbnRyb2xzLmxlbmd0aDsgaSA8IGxpbWl0OyBpKyspIHsKICAgICAgICAgICAgY29uc3Qga2V5ID0gZGFUYXJnZXRDb250cm9sc1tpXQogICAgICAgICAgICBjb25zdCBjb250cm9sT2JqID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmNvcGllZENvbnRyb2xbdGhpcy51c2VyRm9ybUlkXVtrZXldKSkKICAgICAgICAgICAgY29uc3QgaXRlbTogY29udHJvbERhdGEgPSB7CiAgICAgICAgICAgICAgLi4uY29udHJvbE9iagogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hpbGRDb250cm9sKGRhVGFyZ2V0LCBrZXkpCiAgICAgICAgICAgIHRoaXMudXBkYXRlTmV3Q29udHJvbChkYVRhcmdldCwga2V5LCBpdGVtLCBmYWxzZSkKICAgICAgICAgICAgcmVjQ29weUNvbnRyb2woa2V5KQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBmb3IgKGNvbnN0IGtleSBvZiBzZWxTZWxlY3RlZCkgewogICAgICAgIGlmICgha2V5LnN0YXJ0c1dpdGgoJ2dyb3VwJykpIHsKICAgICAgICAgIGNvbnN0IGNvbnRyb2xPYmogPSBKU09OLnBhcnNlKAogICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh0aGlzLmNvcGllZENvbnRyb2xbdGhpcy51c2VyRm9ybUlkXVtrZXldKQogICAgICAgICAgKQogICAgICAgICAgaWYgKHNlbFNlbGVjdGVkLmxlbmd0aCA9PT0gMSAmJiB1c2VyRm9ybURhdGFbc2VsU2VsZWN0ZWRbMF1dLnByb3BlcnRpZXMuR3JvdXBJRCEgIT09ICcnKSB7CiAgICAgICAgICAgIGNvbnRyb2xPYmoucHJvcGVydGllcy5Hcm91cElEID0gJycKICAgICAgICAgIH0KICAgICAgICAgIGNvbnN0IGl0ZW06IGNvbnRyb2xEYXRhID0gewogICAgICAgICAgICAuLi5jb250cm9sT2JqCiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLnVwZGF0ZU5ld0NvbnRyb2wodGhpcy5jb250YWluZXJJZCwga2V5LCBpdGVtLCB0cnVlKQogICAgICAgICAgcmVjQ29weUNvbnRyb2woa2V5KQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBmb3IgKGxldCBjdHJsSWQgaW4gdXNlckZvcm1EYXRhKSB7CiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xQcm9wID0gdXNlckZvcm1EYXRhW2N0cmxJZF0ucHJvcGVydGllcy5Hcm91cElECiAgICAgICAgICAgIGlmIChjb250cm9sUHJvcCkgewogICAgICAgICAgICAgIGlmIChjb250cm9sUHJvcCA9PT0ga2V5KSB7CiAgICAgICAgICAgICAgICBjb25zdCBjb250cm9sT2JqID0gSlNPTi5wYXJzZSgKICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkodGhpcy5jb3BpZWRDb250cm9sW3RoaXMudXNlckZvcm1JZF1bY3RybElkXSkKICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW06IGNvbnRyb2xEYXRhID0gewogICAgICAgICAgICAgICAgICAuLi5jb250cm9sT2JqCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU5ld0NvbnRyb2wodGhpcy5jb250YWluZXJJZCwgY3RybElkLCBpdGVtLCB0cnVlKQogICAgICAgICAgICAgICAgcmVjQ29weUNvbnRyb2woY3RybElkKQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICB0aGlzLnNlbGVjdENvbnRyb2woewogICAgICAgIHVzZXJGb3JtSWQ6IHRoaXMudXNlckZvcm1JZCwKICAgICAgICBzZWxlY3Q6IHsKICAgICAgICAgIGNvbnRhaW5lcjogdGhpcy5nZXRDb250YWluZXJMaXN0KHNlbFNlbGVjdGVkWzBdKSwKICAgICAgICAgIHNlbGVjdGVkOiBzZWxTZWxlY3RlZAogICAgICAgIH0KICAgICAgfSkKICAgICAgdGhpcy51cGRhdGVDb3B5Q29udHJvbExpc3QoewogICAgICAgIHVzZXJGb3JtSWQ6IHRoaXMudXNlckZvcm1JZCwKICAgICAgICBwYXJlbnRJZDogdGhpcy5jb250YWluZXJJZCwKICAgICAgICB0YXJnZXRJZDogc2VsU2VsZWN0ZWQsCiAgICAgICAgdHlwZTogJ2NvcHknCiAgICAgIH0pCiAgICB9CiAgfQoKICAvKioKICAgKiBAZGVzY3JpcHRpb24gVG8gZGVsZXRlIGNvbnRyb2xzIGluIHJlc3BlY3RpdmUgY29udGFpbmVyIHByZXNlbnQgaW4gcmVzcGVjdGl2ZSB1c2VyZm9ybQogICAqIEBmdW5jdGlvbiBjbGlja0RlbGV0ZQogICAqLwogIGNsaWNrRGVsZXRlICgpIHsKICAgIGNvbnN0IHNlbENvbnRyb2wgPSBbXQogICAgY29uc3QgdXNlckRhdGEgPSB0aGlzLnVzZXJmb3JtRGF0YVt0aGlzLnVzZXJGb3JtSWRdCiAgICBjb25zdCBzZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWRDb250cm9sc1t0aGlzLnVzZXJGb3JtSWRdLnNlbGVjdGVkCiAgICBjb25zdCBzZWxDb250YWluZXIgPSB0aGlzLnNlbGVjdGVkQ29udHJvbHNbdGhpcy51c2VyRm9ybUlkXS5jb250YWluZXIKICAgIGNvbnN0IGZpbHRlckNvbnRyb2xzID0gW10KICAgIGNvbnN0IGNvbnRyb2xzID0gdGhpcy51c2VyZm9ybURhdGFbdGhpcy51c2VyRm9ybUlkXVt0aGlzLnNlbGVjdGVkQ29udHJvbHNbdGhpcy51c2VyRm9ybUlkXS5jb250YWluZXJbMF1dLmNvbnRyb2xzCiAgICBmb3IgKGNvbnN0IGNvbnRyb2wgb2Ygc2VsZWN0ZWQpIHsKICAgICAgaWYgKCFjb250cm9sLnN0YXJ0c1dpdGgoJ0lEX1VTRVJGT1JNJykpIHsKICAgICAgICBpZiAoY29udHJvbC5zdGFydHNXaXRoKCdncm91cCcpKSB7CiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB1c2VyRGF0YSkgewogICAgICAgICAgICBpZiAoCiAgICAgICAgICAgICAgdXNlckRhdGFba2V5XS5wcm9wZXJ0aWVzLkdyb3VwSUQgPT09IGNvbnRyb2wKICAgICAgICAgICAgKSB7CiAgICAgICAgICAgICAgc2VsQ29udHJvbC5wdXNoKGtleSkKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBzZWxDb250cm9sLnB1c2goY29udHJvbCkKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIGlmIChzZWxlY3RlZC5sZW5ndGggPT09IDEgJiYgIXNlbGVjdGVkWzBdLnN0YXJ0c1dpdGgoJ2dyb3VwJykgJiYgdGhpcy51c2VyZm9ybURhdGFbdGhpcy51c2VyRm9ybUlkXVtzZWxlY3RlZFswXV0ucHJvcGVydGllcy5Hcm91cElEICE9PSAnJykgewogICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbnRyb2xzLmxlbmd0aDsgaisrKSB7CiAgICAgICAgaWYgKHVzZXJEYXRhW2NvbnRyb2xzW2pdXS5wcm9wZXJ0aWVzLkdyb3VwSUQgPT09IHVzZXJEYXRhW3NlbGVjdGVkWzBdXS5wcm9wZXJ0aWVzLkdyb3VwSUQpIHsKICAgICAgICAgIGZpbHRlckNvbnRyb2xzLnB1c2goY29udHJvbHNbal0pCiAgICAgICAgfQogICAgICB9CiAgICAgIGlmIChmaWx0ZXJDb250cm9scy5sZW5ndGggPT09IDIpIHsKICAgICAgICBjb25zdCBjdXJTZWxlY3QgPSBmaWx0ZXJDb250cm9sc1swXSA9PT0gc2VsZWN0ZWRbMF0gPyBmaWx0ZXJDb250cm9sc1sxXSA6IGZpbHRlckNvbnRyb2xzWzBdCiAgICAgICAgY29uc3Qgc2VsR3JvdXBJZCA9IHVzZXJEYXRhW3NlbGVjdGVkWzBdXS5wcm9wZXJ0aWVzLkdyb3VwSUQKICAgICAgICB0aGlzLnVwZGF0ZUNvbnRyb2xQcm9wZXJ0eSgnR3JvdXBJRCcsICcnLCBjdXJTZWxlY3QpCiAgICAgIH0KICAgIH0KICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsQ29udHJvbC5sZW5ndGg7IGkrKykgewogICAgICBjb25zdCBjb250cm9sSWQgPSB1c2VyRGF0YVtzZWxDb250cm9sW2ldXS50eXBlID09PSAnUGFnZScgPyBzZWxDb250YWluZXJbMF0gOiBzZWxDb250cm9sW2ldCiAgICAgIHRoaXMuZGVsZXRlWkluZGV4KGNvbnRyb2xJZCkKICAgICAgdGhpcy5kZWxldGVUYWJJbmRleChjb250cm9sSWQpCiAgICAgIHRoaXMuZGVsZXRlQ29udHJvbCh7CiAgICAgICAgdXNlckZvcm1JZDogdGhpcy51c2VyRm9ybUlkLAogICAgICAgIHBhcmVudElkOiB0aGlzLmdldENvbnRhaW5lckxpc3QoY29udHJvbElkKVswXSwKICAgICAgICB0YXJnZXRJZDogY29udHJvbElkCiAgICAgIH0pCiAgICB9CgogICAgdGhpcy5zZWxlY3RDb250cm9sKHsKICAgICAgdXNlckZvcm1JZDogdGhpcy51c2VyRm9ybUlkLAogICAgICBzZWxlY3Q6IHsKICAgICAgICBjb250YWluZXI6IHVzZXJEYXRhW3NlbENvbnRhaW5lclswXV0udHlwZSA9PT0gJ011bHRpUGFnZScgPyB0aGlzLmdldENvbnRhaW5lckxpc3Qoc2VsQ29udGFpbmVyWzBdKSA6IHNlbENvbnRhaW5lciwKICAgICAgICBzZWxlY3RlZDogdXNlckRhdGFbc2VsQ29udGFpbmVyWzBdXS50eXBlID09PSAnTXVsdGlQYWdlJyA/IFt0aGlzLmdldENvbnRhaW5lckxpc3Qoc2VsQ29udGFpbmVyWzBdKVswXV0gOiBbc2VsQ29udGFpbmVyWzBdXQogICAgICB9CiAgICB9KQogICAgRXZlbnRCdXMuJGVtaXQoJ2ZvY3VzVXNlckZvcm0nKQogIH0KICB1cGRhdGVBY3Rpb24gKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7CiAgICBsZXQgY29udHJvbEFjdGlvbk5hbWUgPSAnJwogICAgaWYgKGV2ZW50LmN0cmxLZXkgJiYgZXZlbnQuY29kZSA9PT0gJ0tleUEnKSB7CiAgICAgIGNvbnRyb2xBY3Rpb25OYW1lID0gJ0lEX1NFTEVDVEFMTCcKICAgIH0gZWxzZSBpZiAoZXZlbnQuY3RybEtleSAmJiBldmVudC5jb2RlID09PSAnS2V5QycpIHsKICAgICAgaWYgKAogICAgICAgIHRoaXMuc2VsZWN0ZWRDb250cm9sc1t0aGlzLnVzZXJGb3JtSWRdLnNlbGVjdGVkWzBdICE9PSB0aGlzLnVzZXJGb3JtSWQKICAgICAgKSB7CiAgICAgICAgY29udHJvbEFjdGlvbk5hbWUgPSAnSURfQ09QWScKICAgICAgfQogICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSA0NikgewogICAgICBjb250cm9sQWN0aW9uTmFtZSA9ICdJRF9ERUxFVEUnCiAgICB9IGVsc2UgaWYgKGV2ZW50LmN0cmxLZXkgJiYgZXZlbnQuY29kZSA9PT0gJ0tleVYnKSB7CiAgICAgIGNvbnRyb2xBY3Rpb25OYW1lID0gJ0lEX1BBU1RFJwogICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlICYmIGV2ZW50LmNvZGUgPT09ICdLZXlYJykgewogICAgICBjb250cm9sQWN0aW9uTmFtZSA9ICdJRF9DVVQnCiAgICB9CiAgICB0aGlzLmNvbnRyb2xBY3Rpb24oY29udHJvbEFjdGlvbk5hbWUsICcnKQogIH0KICB1cGRhdGVQcm9wVmFsIChwcm9wTmFtZTogc3RyaW5nLCBwcm9wVmFsdWU6IG51bWJlcikgewogICAgY29uc3QgY3RybFNlbCA9IHRoaXMuc2VsZWN0ZWRDb250cm9sc1t0aGlzLnVzZXJGb3JtSWRdLnNlbGVjdGVkCiAgICBjb25zdCB1c3JGcm1EYXRhID0gdGhpcy51c2VyZm9ybURhdGFbdGhpcy51c2VyRm9ybUlkXQogICAgZm9yIChsZXQgaW5kZXggPSAxOyBpbmRleCA8IGN0cmxTZWwubGVuZ3RoOyBpbmRleCsrKSB7CiAgICAgIGlmICghY3RybFNlbFtpbmRleF0uc3RhcnRzV2l0aCgnZ3JvdXAnKSkgewogICAgICAgIGNvbnN0IGN1clByb3AgPSB1c3JGcm1EYXRhW2N0cmxTZWxbaW5kZXhdXS5wcm9wZXJ0aWVzCiAgICAgICAgaWYgKHByb3BOYW1lID09PSAnc2VsUmlnaHQnKSB7CiAgICAgICAgICBjb25zdCBjdXJSaWdodCA9IGN1clByb3AuV2lkdGghICsgY3VyUHJvcC5MZWZ0IQogICAgICAgICAgY29uc3QgdmFsdWUgPSBjdXJQcm9wLkxlZnQhICsgKHByb3BWYWx1ZSAtIGN1clJpZ2h0KQogICAgICAgICAgdGhpcy51cGRhdGVDb250cm9sUHJvcGVydHkoJ0xlZnQnLCB2YWx1ZSwgY3RybFNlbFtpbmRleF0pCiAgICAgICAgfSBlbHNlIGlmIChwcm9wTmFtZSA9PT0gJ3NlbEJvdHRvbScpIHsKICAgICAgICAgIGNvbnN0IGN1ckJvdHRvbSA9IGN1clByb3AuSGVpZ2h0ISArIGN1clByb3AuVG9wIQogICAgICAgICAgY29uc3QgdmFsdWUgPSBjdXJQcm9wLlRvcCEgKyAocHJvcFZhbHVlIC0gY3VyQm90dG9tKQogICAgICAgICAgdGhpcy51cGRhdGVDb250cm9sUHJvcGVydHkoJ1RvcCcsIHZhbHVlLCBjdHJsU2VsW2luZGV4XSkKICAgICAgICB9CiAgICAgICAgaWYgKHByb3BOYW1lID09PSAnc2VsQ2VudGVyJykgewogICAgICAgICAgY29uc3QgY3VyQ2VudGVyID0gY3VyUHJvcC5XaWR0aCEgLyAyCiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHByb3BWYWx1ZSAtIGN1ckNlbnRlcgogICAgICAgICAgdGhpcy51cGRhdGVDb250cm9sUHJvcGVydHkoJ0xlZnQnLCB2YWx1ZSwgY3RybFNlbFtpbmRleF0pCiAgICAgICAgfQogICAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ3NlbE1pZGRsZScpIHsKICAgICAgICAgIGNvbnN0IGN1ck1pZGRsZSA9IGN1clByb3AuSGVpZ2h0ISAvIDIKICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHJvcFZhbHVlIC0gY3VyTWlkZGxlCiAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRyb2xQcm9wZXJ0eSgnVG9wJywgdmFsdWUsIGN0cmxTZWxbaW5kZXhdKQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjb25zdCBwcm9wZXJ0eW5hbWU6IGtleW9mIGNvbnRyb2xQcm9wZXJ0aWVzID0gcHJvcE5hbWUgYXMga2V5b2YgY29udHJvbFByb3BlcnRpZXMKICAgICAgICAgIHRoaXMudXBkYXRlQ29udHJvbFByb3BlcnR5KHByb3BlcnR5bmFtZSwgcHJvcFZhbHVlLCBjdHJsU2VsW2luZGV4XSkKICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY29uc3QgZ3JvdXBJbmRleDogbnVtYmVyID0gdGhpcy5ncm91cFN0eWxlQXJyYXkuZmluZEluZGV4KHZhbCA9PiB2YWwuZ3JvdXBOYW1lID09PSBjdHJsU2VsW2luZGV4XSkKICAgICAgICBjb25zdCBjdXJQcm9wID0gdGhpcy5ncm91cFN0eWxlQXJyYXlbZ3JvdXBJbmRleF0KICAgICAgICBjb25zdCBsZWZ0ID0gcGFyc2VJbnQoY3VyUHJvcC5sZWZ0ISkKICAgICAgICBjb25zdCB0b3AgPSBwYXJzZUludChjdXJQcm9wLnRvcCEpCiAgICAgICAgY29uc3Qgd2lkdGggPSBwYXJzZUludChjdXJQcm9wLndpZHRoISkKICAgICAgICBjb25zdCBoZWlnaHQgPSBwYXJzZUludChjdXJQcm9wLmhlaWdodCEpCiAgICAgICAgbGV0IHZhbHVlID0gLTEKICAgICAgICBpZiAocHJvcE5hbWUgPT09ICdzZWxSaWdodCcpIHsKICAgICAgICAgIHZhbHVlID0gbGVmdCEgKyAocHJvcFZhbHVlIC0gKHdpZHRoISArIGxlZnQhKSkKICAgICAgICAgIEV2ZW50QnVzLiRlbWl0KCd1cGRhc3RlR3JvdXBTaXplJywgJ0xlZnQnLCB2YWx1ZSwgZ3JvdXBJbmRleCkKICAgICAgICB9IGVsc2UgaWYgKHByb3BOYW1lID09PSAnc2VsQm90dG9tJykgewogICAgICAgICAgdmFsdWUgPSB0b3AhICsgKHByb3BWYWx1ZSAtIChoZWlnaHQgKyB0b3ApKQogICAgICAgICAgRXZlbnRCdXMuJGVtaXQoJ3VwZGFzdGVHcm91cFNpemUnLCAnVG9wJywgdmFsdWUsIGdyb3VwSW5kZXgpCiAgICAgICAgfQogICAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ3NlbENlbnRlcicpIHsKICAgICAgICAgIHZhbHVlID0gcHJvcFZhbHVlIC0gKHdpZHRoISAvIDIpCiAgICAgICAgICBFdmVudEJ1cy4kZW1pdCgndXBkYXN0ZUdyb3VwU2l6ZScsICdMZWZ0JywgdmFsdWUsIGdyb3VwSW5kZXgpCiAgICAgICAgfQogICAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ3NlbE1pZGRsZScpIHsKICAgICAgICAgIHZhbHVlID0gcHJvcFZhbHVlIC0gaGVpZ2h0ISAvIDIKICAgICAgICAgIEV2ZW50QnVzLiRlbWl0KCd1cGRhc3RlR3JvdXBTaXplJywgJ1RvcCcsIHZhbHVlLCBncm91cEluZGV4KQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjb25zdCBwcm9wZXJ0eW5hbWU6IGtleW9mIGNvbnRyb2xQcm9wZXJ0aWVzID0gcHJvcE5hbWUgYXMga2V5b2YgY29udHJvbFByb3BlcnRpZXMKICAgICAgICAgIEV2ZW50QnVzLiRlbWl0KCd1cGRhc3RlR3JvdXBTaXplJywgcHJvcGVydHluYW1lLCBwcm9wVmFsdWUsIGdyb3VwSW5kZXgpCiAgICAgICAgfQogICAgICB9CiAgICB9CiAgfQogIGNvbnRyb2xBbGlnbk1lbnQgKHN1YlZhbDogc3RyaW5nKSB7CiAgICBjb25zdCBtYWluU2VsID0gdGhpcy5zZWxlY3RlZENvbnRyb2xzW3RoaXMudXNlckZvcm1JZF0uc2VsZWN0ZWRbMF0KICAgIGNvbnN0IGlzR3JvdXAgPSBtYWluU2VsLnN0YXJ0c1dpdGgoJ2dyb3VwJykKICAgIGNvbnN0IHVzckZybURhdGEgPSB0aGlzLnVzZXJmb3JtRGF0YVt0aGlzLnVzZXJGb3JtSWRdCiAgICBjb25zdCBjdHJsUHJvcCA9ICFpc0dyb3VwICYmIHVzckZybURhdGFbbWFpblNlbF0ucHJvcGVydGllcwogICAgY29uc3QgZ3JvdXBJbmRleDogbnVtYmVyID0gdGhpcy5ncm91cFN0eWxlQXJyYXkuZmluZEluZGV4KHZhbCA9PiB2YWwuZ3JvdXBOYW1lID09PSBtYWluU2VsKQogICAgY29uc3QgbmV3T2JqZWN0ID0gewogICAgICBMZWZ0OiBpc0dyb3VwICYmIGdyb3VwSW5kZXggIT09IC0xID8gcGFyc2VJbnQodGhpcy5ncm91cFN0eWxlQXJyYXlbZ3JvdXBJbmRleF0ubGVmdCEpIDogY3RybFByb3AgPyBjdHJsUHJvcC5MZWZ0ISA6IDAsCiAgICAgIFRvcDogaXNHcm91cCAmJiBncm91cEluZGV4ICE9PSAtMSA/IHBhcnNlSW50KHRoaXMuZ3JvdXBTdHlsZUFycmF5W2dyb3VwSW5kZXhdLnRvcCEpIDogY3RybFByb3AgPyBjdHJsUHJvcC5Ub3AhIDogMCwKICAgICAgV2lkdGg6IGlzR3JvdXAgJiYgZ3JvdXBJbmRleCAhPT0gLTEgPyBwYXJzZUludCh0aGlzLmdyb3VwU3R5bGVBcnJheVtncm91cEluZGV4XS53aWR0aCEpIDogY3RybFByb3AgPyBjdHJsUHJvcC5XaWR0aCEgOiAwLAogICAgICBIZWlnaHQ6IGlzR3JvdXAgJiYgZ3JvdXBJbmRleCAhPT0gLTEgPyBwYXJzZUludCh0aGlzLmdyb3VwU3R5bGVBcnJheVtncm91cEluZGV4XS5oZWlnaHQhKSA6IGN0cmxQcm9wID8gY3RybFByb3AuSGVpZ2h0ISA6IDAKICAgIH0KICAgIGlmIChzdWJWYWwgPT09ICdJRF9BTElHTkxFRlQnKSB7CiAgICAgIHRoaXMudXBkYXRlUHJvcFZhbCgnTGVmdCcsIG5ld09iamVjdC5MZWZ0ISkKICAgIH0gZWxzZSBpZiAoc3ViVmFsID09PSAnSURfQUxJR05UT1AnKSB7CiAgICAgIHRoaXMudXBkYXRlUHJvcFZhbCgnVG9wJywgbmV3T2JqZWN0LlRvcCEpCiAgICB9IGVsc2UgaWYgKHN1YlZhbCA9PT0gJ0lEX0FMSUdOUklHSFQnKSB7CiAgICAgIGNvbnN0IHNlbFJpZ2h0ID0gbmV3T2JqZWN0LldpZHRoISArIG5ld09iamVjdC5MZWZ0IQogICAgICB0aGlzLnVwZGF0ZVByb3BWYWwoJ3NlbFJpZ2h0Jywgc2VsUmlnaHQpCiAgICB9IGVsc2UgaWYgKHN1YlZhbCA9PT0gJ0lEX0FMSUdOQk9UVE9NJykgewogICAgICBjb25zdCBzZWxCb3R0b20gPSBuZXdPYmplY3QuSGVpZ2h0ISArIG5ld09iamVjdC5Ub3AhCiAgICAgIHRoaXMudXBkYXRlUHJvcFZhbCgnc2VsQm90dG9tJywgc2VsQm90dG9tKQogICAgfSBlbHNlIGlmIChzdWJWYWwgPT09ICdJRF9BTElHTkNFTlRFUicpIHsKICAgICAgY29uc3Qgc2VsQ2VudGVyID0gbmV3T2JqZWN0LkxlZnQhICsgbmV3T2JqZWN0LldpZHRoISAvIDIKICAgICAgdGhpcy51cGRhdGVQcm9wVmFsKCdzZWxDZW50ZXInLCBzZWxDZW50ZXIpCiAgICB9IGVsc2UgaWYgKHN1YlZhbCA9PT0gJ0lEX0FMSUdOTUlERExFJykgewogICAgICBjb25zdCBzZWxNaWRkbGUgPSBuZXdPYmplY3QuVG9wISArIG5ld09iamVjdC5IZWlnaHQhIC8gMgogICAgICB0aGlzLnVwZGF0ZVByb3BWYWwoJ3NlbE1pZGRsZScsIHNlbE1pZGRsZSkKICAgIH0gZWxzZSBpZiAoc3ViVmFsID09PSAnSURfV0lEVEgnKSB7CiAgICAgIHRoaXMudXBkYXRlUHJvcFZhbCgnV2lkdGgnLCBuZXdPYmplY3QuV2lkdGghKQogICAgfSBlbHNlIGlmIChzdWJWYWwgPT09ICdJRF9IRUlHSFQnKSB7CiAgICAgIHRoaXMudXBkYXRlUHJvcFZhbCgnSGVpZ2h0JywgbmV3T2JqZWN0LkhlaWdodCEpCiAgICB9IGVsc2UgaWYgKHN1YlZhbCA9PT0gJ0lEX0JPVEgnKSB7CiAgICAgIHRoaXMudXBkYXRlUHJvcFZhbCgnSGVpZ2h0JywgbmV3T2JqZWN0LkhlaWdodCEpCiAgICAgIHRoaXMudXBkYXRlUHJvcFZhbCgnV2lkdGgnLCBuZXdPYmplY3QuV2lkdGghKQogICAgfQogIH0KCiAgY29udHJvbERpc2FibGUgKGV2ZW50OiBNb3VzZUV2ZW50KSB7CiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpCiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKQogIH0KfQo="},{"version":3,"sources":["index.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4EA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","file":"index.vue","sourceRoot":"src/FormDesigner/components/atoms/FDContextMenu","sourcesContent":["<template>\n  <div>\n    <div class=\"outercontext-div\">\n      <div class=\"wrapper-context\" v-for=\"(value, i) in values\" :key=\"i\">\n        <button\n          class=\"wrapper1-context\"\n          v-if=\"value.values.length === 0\"\n          :style=\"{\n            border: value.text === 'none' ? '0.3px solid white' : '',\n            background: value.text === 'none' ? 'white' : '',\n            height: value.text === 'none' ? '4px' : '',\n            'padding-top': value.text === 'none' ? '0px' : '',\n            outline: value.text === 'none' ? 'none' : '',\n          }\"\n          @mousedown.stop=\"value.disabled === false ? controlAction(value.id) : controlDisable($event)\"\n        >\n          <div>\n            <FDSVGImage v-if=\"value.icon\" :name=\"value.icon\" />\n          </div>\n          <span v-if=\"value.text === 'none'\">\n            <hr />\n          </span>\n          <span\n            v-else\n            class=\"set-context\"\n            v-html=\"value.text\"\n            :style=\"{ opacity: value.disabled ? 0.5 : 1 }\"\n            >{{ value.text }}\n          </span>\n        </button>\n        <button class=\"wrapper1-context wrapper21\" v-else>\n          <div></div>\n          <ul class=\"set-context top-level-menu\">\n            <li>\n              <a href=\"#\" v-html=\"value.text\"  @mousedown.prevent.stop>{{ value.text }}</a>\n              <ul class=\"third-level-menu\">\n                <li\n                  class=\"wrapper1-context\"\n                  v-for=\"(subVal, i) in value.values\"\n                  :key=\"i\"\n                  :style=\"{\n                    border: subVal.text === 'none' ? '0.3px solid white' : '',\n                    background: subVal.text === 'none' ? 'white' : '',\n                    height: subVal.text === 'none' ? '4px' : '',\n                    'padding-top': subVal.text === 'none' ? '0px' : '',\n                    outline: subVal.text === 'none' ? 'none' : '',\n                  }\"\n                  @mousedown.stop=\"subVal.disabled === false ? controlAction(value.id, subVal.id): controlDisable($event)\"\n                >\n                  <div>\n                    <FDSVGImage v-if=\"subVal.icon\" :name=\"subVal.icon\" />\n                  </div>\n                  <a v-if=\"subVal.text === 'none'\">\n                    <hr />\n                  </a>\n                  <a\n                    v-else\n                    href=\"#\"\n                    v-html=\"subVal.text\"\n                    :style=\"{ opacity: subVal.disabled ? 0.5 : 1 }\"\n                    >{{ subVal.text }}</a\n                  >\n                </li>\n              </ul>\n            </li>\n          </ul>\n          <div class=\"triangle-right\"></div>\n        </button>\n      </div>\n    </div>\n    <div></div>\n    <div></div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { Component, Vue, Prop, Emit } from 'vue-property-decorator'\nimport FDSVGImage from '@/FormDesigner/components/atoms/FDSVGImage/index.vue'\nimport { ControlPropertyData } from '@/FormDesigner/models/ControlsTableProperties/ControlPropertyData.ts'\n\nimport { Action, State } from 'vuex-class'\nimport {\n  IaddChildControls,\n  IaddControl,\n  IdeleteControl,\n  IselectControl,\n  IsetChildControls,\n  IupdateControl,\n  IupdateControlExtraData,\n  IupdateCopyControlList,\n  IupdateGroup\n} from '@/storeModules/fd/actions'\nimport { EventBus } from '@/FormDesigner/event-bus'\nimport FDCommonMethod from '@/api/abstract/FormDesigner/FDCommonMethod'\n\n@Component({\n  name: 'ContextMenu',\n  components: {\n    FDSVGImage\n  }\n})\nexport default class ContextMenu extends FDCommonMethod {\n  @Prop() values: Array<IControlContextMenu>;\n  @Prop() userFormId: string;\n  @Prop() containerId: string;\n  @Prop() keyEventName: string;\n  @Prop() controlId: string;\n  @Prop() selectedTab: number;\n  @Prop() data: controlData;\n  @Prop() groupStyleArray: Array<IGroupStyle>\n\n  @State((state) => state.fd.selectedControls)\n  selectedControls!: fdState['selectedControls'];\n  @State((state: rootState) => state.fd.copyControlList)\n  copyControlList!: fdState['copyControlList'];\n  @State((state) => state.fd.userformData) userformData!: userformData;\n  @State((state) => state.fd.copiedControl) copiedControl!: userformData;\n  @State((state) => state.fd.groupedControls)\n  groupedControls!: fdState['groupedControls'];\n\n  @Action('fd/deleteControl') deleteControl!: (payload: IdeleteControl) => void;\n  @Action('fd/deleteCopiedControl') deleteCopiedControl!: (payload: IdeleteControl) => void;\n  @Action('fd/updateCopyControlList') updateCopyControlList!: (\n    payload: IupdateCopyControlList\n  ) => void;\n  @Action('fd/addControl') addControl!: (payload: IaddControl) => void;\n  @Action('fd/addCopiedControl') addCopiedControl!: (\n    payload: IaddControl\n  ) => void;\n  @Action('fd/selectControl') selectControl!: (payload: IselectControl) => void;\n  @Action('fd/updateGroup') updateGroup!: (payload: IupdateGroup) => void;\n  @Action('fd/updateControlExtraData') updateControlExtraData!: (\n    payload: IupdateControlExtraData\n  ) => void;\n  @Action('fd/updateControl') updateControl!: (payload: IupdateControl) => void;\n  @Action('fd/setChildControls') setChildControls!: (\n    payload: IsetChildControls\n  ) => void;\n  @Action('fd/addChildControls') addChildControls!: (\n    payload: IaddChildControls\n  ) => void;\n  controlAction (controlActionName: string, subVal: string) {\n    if (controlActionName === 'ID_COPY') {\n      this.copyControl('copy')\n    } else if (controlActionName === 'ID_DELETE') {\n      this.clickDelete()\n    } else if (controlActionName === 'ID_PASTE') {\n      this.pasteControl()\n    } else if (controlActionName === 'ID_CUT') {\n      this.cutControl()\n    } else if (controlActionName === 'ID_SELECTALL') {\n      this.selectAll()\n    } else if (controlActionName === 'ID_GROUP') {\n      this.groupControl()\n    } else if (controlActionName === 'ID_UNGROUP') {\n      this.unGroupControl()\n    } else if (controlActionName === 'ID_NEWPAGE') {\n      this.addNewPage()\n    } else if (controlActionName === 'ID_DELETEPAGE') {\n      this.deleteCurrentPage()\n    } else if (controlActionName === 'ID_CONTROLFORWARD') {\n      this.bringForward()\n    } else if (controlActionName === 'ID_CONTROLBACKWARD') {\n      this.bringBackward()\n    } else if (controlActionName === 'ID_OBJECTPROP') {\n      this.displayProp()\n    } else if (controlActionName === 'ID_RENAME') {\n      const selectedPageID = this.selectedControls[this.userFormId].selected[0]\n      EventBus.$emit(\n        'renamePage',\n        this.userFormId,\n        selectedPageID,\n        this.selectedTab,\n        this.userformData[this.userFormId][selectedPageID].type\n      )\n    } else if (controlActionName === 'ID_MOVE') {\n      const type = this.userformData[this.userFormId][this.controlId].type\n      if (type === 'MultiPage') {\n        EventBus.$emit('userFormTabOrder', this.userFormId, this.controlId, type)\n      } else {\n        EventBus.$emit('tabStripTabOrder', this.userFormId, this.controlId, type)\n      }\n    } else if (controlActionName === 'ID_TABORDER') {\n      EventBus.$emit('userFormTabOrder', this.userFormId, this.containerId, '')\n    } else if (\n      controlActionName === 'ID_ALIGN' ||\n      controlActionName === 'ID_MAKESAMESIZE'\n    ) {\n      this.controlAlignMent(subVal)\n    }\n    this.closeMenu()\n  }\n  created () {\n    EventBus.$on('groupControl', (value: string) => {\n      if (this.selectedControls[this.userFormId].container[0] === this.containerId) {\n        if (value === 'group') {\n          this.groupControl()\n        } else if (value === 'ungroup') {\n          this.unGroupControl()\n        }\n      }\n    })\n  }\n  destroyed () {\n    EventBus.$off('groupControl')\n  }\n  @Emit('closeMenu')\n  closeMenu () {\n    return 0\n  }\n\n  displayProp () {\n    EventBus.$emit('dispProp', false)\n  }\n\n  addNewPage () {\n    const type = this.userformData[this.userFormId][this.controlId].type\n    if (type === 'TabStrip') {\n      const tabControlData = JSON.parse(\n        JSON.stringify(this.userformData[this.userFormId][this.controlId])\n      ).extraDatas.Tabs\n      let prevTabId = -1\n      const initialTabData: tabsItems = {\n        Name: '',\n        Caption: '',\n        ToolTip: '',\n        Accelerator: ''\n      }\n      if (tabControlData.length > 0) {\n        for (let i = 0; i < tabControlData.length; i++) {\n          const id = tabControlData[i].Name.split('Tab').pop() || '-1'\n          const parseId = parseInt(id, 10)\n          if (!isNaN(parseId) && prevTabId < parseId) {\n            prevTabId = parseId\n          }\n        }\n        prevTabId += 1\n        initialTabData.Name = `Tab${prevTabId}`\n        initialTabData.Caption = `Tab${prevTabId}`\n      } else {\n        initialTabData.Name = `Tab${1}`\n        initialTabData.Caption = `Tab${1}`\n      }\n      tabControlData.push(initialTabData)\n      this.updateControlExtraData({\n        userFormId: this.userFormId,\n        controlId: this.controlId,\n        propertyName: 'Tabs',\n        value: tabControlData\n      })\n      this.updateControl({\n        userFormId: this.userFormId,\n        controlId: this.controlId,\n        propertyName: 'Value',\n        value: prevTabId - 1\n      })\n    } else if (type === 'MultiPage') {\n      const parentId = this.controlId.split('MultiPage').pop()\n      const controlName = `Page${parentId}_`\n\n      let lastControlId = 0\n      const userformControlIds = Object.keys(this.userformData[this.userFormId])\n      for (let i = 0; i < userformControlIds.length; i++) {\n        if (userformControlIds[i].indexOf(controlName) !== -1) {\n          const IdNum =\n          userformControlIds[i].split(controlName).pop() || '-1'\n          const pasreId = parseInt(IdNum, 10)\n          if (!isNaN(pasreId) && lastControlId < pasreId) {\n            lastControlId = pasreId\n          }\n        }\n      }\n      const controlPropData = new ControlPropertyData()\n      let controlObj = controlPropData.data['Page']\n      const item = JSON.parse(JSON.stringify(controlObj!))\n      lastControlId += 1\n      item.properties.ID = `ID_${controlName}${lastControlId}`\n      item.properties.Caption = `Page${lastControlId}`\n      item.properties.Name = `Page${lastControlId}`\n      item.properties.Index = this.userformData[this.userFormId][this.controlId].controls.length\n      this.addControl({\n        userFormId: this.userFormId,\n        controlId: this.controlId,\n        addId: item.properties.ID,\n        item: item\n      })\n      this.updateControl({\n        userFormId: this.userFormId,\n        controlId: this.controlId,\n        propertyName: 'Value',\n        value: item.properties.Index\n      })\n      this.selectControl({\n        userFormId: this.userFormId,\n        select: {\n          container: this.getContainerList(item.properties.ID),\n          selected: [item.properties.ID]\n        }\n      })\n      EventBus.$emit('updateMultiPageValue')\n    }\n  }\n  bringForward () {\n    const userData = this.userformData[this.userFormId]\n    const highProrControl = []\n    const lowProrControl = []\n    const container = this.getContainerList(this.getSelectedControlsDatas![0])[0]\n    const containerControls = this.userformData[this.userFormId][container].controls\n    for (const index in containerControls) {\n      const cntrlData = this.userformData[this.userFormId][containerControls[index]]\n      if (cntrlData.type === 'MultiPage' || cntrlData.type === 'Frame' || cntrlData.type === 'ListBox') {\n        highProrControl.push(containerControls[index])\n      } else {\n        lowProrControl.push(containerControls[index])\n      }\n    }\n    let nextSelctedSeries: string[] = []\n    let nextHighControlSeries: string[] = []\n    const getSelControl = [...this.getSelectedControlsDatas!]\n    getSelControl.sort((a, b) => {\n      return userData[a].extraDatas!.zIndex! - userData[b].extraDatas!.zIndex!\n    })\n    for (const selControl of getSelControl!) {\n      const type = userData[selControl].type\n      const tempZIndex = userData[selControl].extraDatas!.zIndex!\n      const controlIndex = Object.keys(userData).findIndex((val: string, index: number) => {\n        return 'zIndex' in userData[val].extraDatas! && (userData[val].extraDatas!.zIndex === tempZIndex + 1)\n      })\n      const nextSelectedControl = controlIndex !== -1 ? Object.keys(userData)[controlIndex] : ''\n      const nextControlType = userData[nextSelectedControl].type\n      if (nextSelectedControl !== '' && !highProrControl.includes(nextSelectedControl)) {\n        if (getSelControl!.includes(nextSelectedControl)) {\n          if (!nextSelctedSeries.includes(selControl)) {\n            nextSelctedSeries.push(selControl)\n          }\n          if (!nextSelctedSeries.includes(nextSelectedControl)) {\n            nextSelctedSeries.push(nextSelectedControl)\n          }\n        } else {\n          if (Object.keys(nextSelctedSeries).length !== 0) {\n            const tempExchageIndex = userData[nextSelctedSeries[0]].extraDatas!.zIndex!\n            const swapTabIndex = userData[nextSelectedControl].extraDatas!.zIndex!\n            if (swapTabIndex <= userData[container].controls.length /* && swapTabIndex > 0 */) {\n              const index = userData[container].controls.findIndex(\n                (val) => userData[val].extraDatas!.zIndex === swapTabIndex\n              )\n              this.updateExtraDatas(userData[container].controls[index], 'zIndex', tempExchageIndex)\n              this.updateExtraDatas(nextSelctedSeries[0], 'zIndex', swapTabIndex - (nextSelctedSeries!.length - 1))\n            }\n            for (let j = 1; j < nextSelctedSeries.length; j++) {\n              const updateIndex = userData[nextSelctedSeries[j]].extraDatas!.zIndex! + 1\n              this.updateExtraDatas(nextSelctedSeries[j], 'zIndex', updateIndex)\n            }\n            nextSelctedSeries = []\n          } else {\n            const swapTabIndex = userData[nextSelectedControl].extraDatas!.zIndex!\n            if (swapTabIndex <= userData[container].controls.length /* && swapTabIndex > 0 */) {\n              const index = userData[container].controls.findIndex(\n                (val) => userData[val].extraDatas!.zIndex === swapTabIndex\n              )\n              this.updateExtraDatas(selControl, 'zIndex', swapTabIndex)\n              this.updateExtraDatas(nextSelectedControl, 'zIndex', tempZIndex)\n            }\n          }\n        }\n      } else {\n        if (getSelControl!.includes(nextSelectedControl) && (type === 'Frame' || type === 'MultiPage' || type === 'ListBox')) {\n          if (!nextHighControlSeries.includes(selControl)) {\n            nextHighControlSeries.push(selControl)\n          }\n          if (!nextHighControlSeries.includes(nextSelectedControl)) {\n            nextHighControlSeries.push(nextSelectedControl)\n          }\n        } else if (type === 'Frame' || type === 'MultiPage' || type === 'ListBox') {\n          if (Object.keys(nextHighControlSeries).length !== 0) {\n            const tempExchageIndex = userData[nextHighControlSeries[0]].extraDatas!.zIndex!\n            const swapTabIndex = userData[nextSelectedControl].extraDatas!.zIndex!\n            if (swapTabIndex <= userData[container].controls.length) {\n              const index = userData[container].controls.findIndex(\n                (val) => userData[val].extraDatas!.zIndex === swapTabIndex\n              )\n              this.updateExtraDatas(userData[container].controls[index], 'zIndex', tempExchageIndex)\n              this.updateExtraDatas(nextHighControlSeries[0], 'zIndex', swapTabIndex - (nextHighControlSeries!.length - 1))\n            }\n            for (let j = 1; j < nextHighControlSeries.length; j++) {\n              const updateIndex = userData[nextHighControlSeries[j]].extraDatas!.zIndex! + 1\n              this.updateExtraDatas(nextHighControlSeries[j], 'zIndex', updateIndex)\n            }\n            nextHighControlSeries = []\n          } else {\n            const swapTabIndex = userData[nextSelectedControl].extraDatas!.zIndex!\n            if (swapTabIndex <= userData[container].controls.length /* && swapTabIndex > 0 */) {\n              const index = userData[container].controls.findIndex(\n                (val) => userData[val].extraDatas!.zIndex === swapTabIndex\n              )\n              this.updateExtraDatas(selControl, 'zIndex', swapTabIndex)\n              this.updateExtraDatas(nextSelectedControl, 'zIndex', tempZIndex)\n            }\n          }\n        }\n      }\n    }\n  }\n  bringBackward () {\n    const userData = this.userformData[this.userFormId]\n    const highProrControl = []\n    const lowProrControl = []\n    const container = this.getContainerList(this.getSelectedControlsDatas![0])[0]\n    const containerControls = this.userformData[this.userFormId][container].controls\n    for (const index in containerControls) {\n      const cntrlData = this.userformData[this.userFormId][containerControls[index]]\n      if (cntrlData.type === 'MultiPage' || cntrlData.type === 'Frame' || cntrlData.type === 'ListBox') {\n        highProrControl.push(containerControls[index])\n      } else {\n        lowProrControl.push(containerControls[index])\n      }\n    }\n    let nextSelctedSeries: string[] = []\n    let nextHighControlSeries: string[] = []\n    const getSelControl = [...this.getSelectedControlsDatas!]\n    getSelControl.sort((a, b) => {\n      return userData[a].extraDatas!.zIndex! - userData[b].extraDatas!.zIndex!\n    })\n    for (const selControl of getSelControl) {\n      const type = userData[selControl].type\n      const tempZIndex = userData[selControl].extraDatas!.zIndex!\n      const controlIndex = Object.keys(userData).findIndex((val: string, index: number) => {\n        return 'zIndex' in userData[val].extraDatas! && (userData[val].extraDatas!.zIndex === tempZIndex - 1)\n      })\n      const nextSelectedControl = controlIndex !== -1 ? Object.keys(userData)[controlIndex] : ''\n      const nextControlType = userData[nextSelectedControl].type\n      if (nextSelectedControl !== '' && !highProrControl.includes(selControl)) {\n        if (getSelControl!.includes(nextSelectedControl)) {\n          if (!nextSelctedSeries.includes(selControl)) {\n            nextSelctedSeries.push(selControl)\n          }\n          if (!nextSelctedSeries.includes(nextSelectedControl)) {\n            nextSelctedSeries.push(nextSelectedControl)\n          }\n        } else {\n          if (Object.keys(nextSelctedSeries).length !== 0) {\n            console.log('nextSelctedSeries', nextSelctedSeries)\n            const tempExchageIndex = userData[nextSelctedSeries[0]].extraDatas!.zIndex!\n            const swapTabIndex = userData[nextSelectedControl].extraDatas!.zIndex!\n            if (swapTabIndex <= userData[container].controls.length && swapTabIndex > 0) {\n              const index = userData[container].controls.findIndex(\n                (val) => userData[val].extraDatas!.zIndex === swapTabIndex\n              )\n              this.updateExtraDatas(userData[container].controls[index], 'zIndex', tempExchageIndex)\n              this.updateExtraDatas(nextSelctedSeries[0], 'zIndex', (nextSelctedSeries!.length + 1) - swapTabIndex)\n            }\n            for (let j = 1; j < nextSelctedSeries.length; j++) {\n              const updateIndex = userData[nextSelctedSeries[j]].extraDatas!.zIndex! - 1\n              this.updateExtraDatas(nextSelctedSeries[j], 'zIndex', updateIndex)\n            }\n            nextSelctedSeries = []\n          } else {\n            const swapTabIndex = userData[nextSelectedControl].extraDatas!.zIndex!\n            if (swapTabIndex <= userData[container].controls.length && swapTabIndex > 0) {\n              const index = userData[container].controls.findIndex(\n                (val) => userData[val].extraDatas!.zIndex === swapTabIndex\n              )\n              this.updateExtraDatas(selControl, 'zIndex', swapTabIndex)\n              this.updateExtraDatas(nextSelectedControl, 'zIndex', tempZIndex)\n            }\n          }\n        }\n      } else if (!lowProrControl.includes(nextSelectedControl) && (type === 'Frame' || type === 'MultiPage' || type === 'ListBox')) {\n        if (getSelControl!.includes(nextSelectedControl)) {\n          if (!nextHighControlSeries.includes(selControl)) {\n            nextHighControlSeries.push(selControl)\n          }\n          if (!nextHighControlSeries.includes(nextSelectedControl)) {\n            nextHighControlSeries.push(nextSelectedControl)\n          }\n        } else {\n          if (Object.keys(nextHighControlSeries).length !== 0) {\n            const tempExchageIndex = userData[nextHighControlSeries[0]].extraDatas!.zIndex!\n            const swapTabIndex = userData[nextSelectedControl].extraDatas!.zIndex!\n            if (swapTabIndex <= userData[container].controls.length) {\n              const index = userData[container].controls.findIndex(\n                (val) => userData[val].extraDatas!.zIndex === swapTabIndex\n              )\n              this.updateExtraDatas(userData[container].controls[index], 'zIndex', tempExchageIndex)\n              this.updateExtraDatas(nextHighControlSeries[0], 'zIndex', (nextHighControlSeries!.length + 1) - swapTabIndex)\n            }\n            for (let j = 1; j < nextHighControlSeries.length; j++) {\n              const updateIndex = userData[nextHighControlSeries[j]].extraDatas!.zIndex! - 1\n              this.updateExtraDatas(nextHighControlSeries[j], 'zIndex', updateIndex)\n            }\n            nextHighControlSeries = []\n          } else {\n            const swapTabIndex = userData[nextSelectedControl].extraDatas!.zIndex!\n            if (swapTabIndex <= userData[container].controls.length && swapTabIndex > 0) {\n              const index = userData[container].controls.findIndex(\n                (val) => userData[val].extraDatas!.zIndex === swapTabIndex\n              )\n              this.updateExtraDatas(selControl, 'zIndex', swapTabIndex)\n              this.updateExtraDatas(nextSelectedControl, 'zIndex', tempZIndex)\n            }\n          }\n        }\n      }\n    }\n  }\n  deletePageIndex (id: string) {\n    const userData = this.userformData[this.userFormId]\n    const container = this.selectedControls[this.userFormId].container[0]\n    const tempIndex = userData[id].properties!.Index!\n    for (const key in userData[container].controls) {\n      const controlZIndex = userData[userData[container].controls[key]].properties!.Index!\n      if (controlZIndex > tempIndex) {\n        this.updateControl({\n          userFormId: this.userFormId,\n          controlId: userData[container].controls[key],\n          propertyName: 'Index',\n          value: controlZIndex - 1\n        })\n      }\n    }\n  }\n  deleteCurrentPage () {\n    const type = this.userformData[this.userFormId][this.controlId].type\n    if (type === 'TabStrip') {\n      const tabControlData = JSON.parse(\n        JSON.stringify(this.userformData[this.userFormId][this.controlId])\n      ).extraDatas.Tabs\n      if (tabControlData && tabControlData.length > 0) {\n        tabControlData.splice(this.selectedTab, 1)\n        this.updateControlExtraData({\n          userFormId: this.userFormId,\n          controlId: this.controlId,\n          propertyName: 'Tabs',\n          value: tabControlData\n        })\n        this.updateTabStripValue(this.selectedTab! - 1)\n      }\n    } else if (type === 'MultiPage') {\n      const controls = this.userformData[this.userFormId][this.controlId].controls\n      if (controls.length > 0) {\n        this.deletePageIndex(this.selectedControls[this.userFormId].selected[0])\n        const index = this.userformData[this.userFormId][this.selectedControls[this.userFormId].selected[0]].properties.Index\n        this.deleteControl({\n          userFormId: this.userFormId,\n          parentId: this.selectedControls[this.userFormId].container[0],\n          targetId: this.selectedControls[this.userFormId].selected[0]\n        })\n        this.updateIndex(index! - 1)\n      }\n      EventBus.$emit('updateMultiPageValue')\n    }\n  }\n  updateTabStripValue (index: number) {\n    const userData = this.userformData[this.userFormId]\n    const tabs = userData[this.controlId].extraDatas!.Tabs!\n    const tabIndex = tabs.findIndex((val, key) => key === index + 1)\n    if (tabIndex !== -1) {\n      const value = index + 1\n      this.updateControlProperty('Value', value, this.controlId)\n    } else if (tabIndex === -1 && index !== -1) {\n      const value = index\n      this.updateControlProperty('Value', value, this.controlId)\n    } else {\n      this.updateControlProperty('Value', -1, this.controlId)\n    }\n  }\n  changeSelect (control: string) {\n    this.selectControl({\n      userFormId: this.userFormId,\n      select: {\n        container: this.getContainerList(control),\n        selected: [control]\n      }\n    })\n  }\n  updateIndex (index: number) {\n    const userData = this.userformData[this.userFormId]\n    const controls = userData[this.controlId].controls\n    const pageIndex = controls.findIndex(val => userData[val].properties.Index === index + 1)\n    if (pageIndex !== -1) {\n      const value = userData[controls[pageIndex]].properties.Index!\n      this.updateControlProperty('Value', value, this.controlId)\n      this.changeSelect(controls[pageIndex])\n    } else if (pageIndex === -1 && index !== -1) {\n      const updateIndex = controls.findIndex(val => userData[val].properties.Index === index)\n      const value = userData[controls[updateIndex]].properties.Index!\n      this.updateControlProperty('Value', value, this.controlId)\n      this.changeSelect(controls[updateIndex])\n    } else {\n      this.updateControlProperty('Value', -1, this.controlId)\n      this.changeSelect(this.controlId)\n    }\n  }\n  updateControlProperty (\n    propertyName: keyof controlProperties,\n    propertyValue: number | string,\n    controlId: string\n  ) {\n    this.updateControl({\n      userFormId: this.userFormId,\n      controlId: controlId,\n      propertyName: propertyName,\n      value: propertyValue\n    })\n  }\n\n  unGroupControl () {\n    const isGroup = this.selectedControls[this.userFormId].selected[0].startsWith('group')\n    const selControl = this.selectedControls[this.userFormId].selected[0]\n    const selected = isGroup\n      ? selControl\n      : this.userformData[this.userFormId][selControl].properties.GroupID!\n\n    const controlList = []\n    for (const key in this.userformData[this.userFormId]) {\n      const type = this.userformData[this.userFormId][key].type\n      if (\n        type !== 'Userform' &&\n        this.userformData[this.userFormId][key].properties.GroupID === selected\n      ) {\n        controlList.push(key)\n      }\n    }\n    const groupArray = [...this.groupedControls[this.userFormId]!.groupArray!]\n    this.updateControlGroupID(selected, '')\n    const index = this.groupedControls[this.userFormId]!.groupArray!.findIndex(\n      (val) => val === selected\n    )\n    groupArray.splice(index, 1)\n    this.updateGroup({ userFormId: this.userFormId, groupArray: groupArray })\n    this.selectControl({\n      userFormId: this.userFormId,\n      select: {\n        container: isGroup\n          ? this.getContainerList(controlList[0])\n          : this.getContainerList(selControl[0]),\n        selected: isGroup ? controlList : [selControl]\n      }\n    })\n  }\n\n  /**\n   * @description To generate new GroupID\n   * @function createGroupId\n   */\n  createGroupId () {\n    let lastControlId = 0\n    for (let i of this.groupedControls[this.userFormId]!.groupArray!) {\n      if (i.indexOf('group') !== -1) {\n        const IdNum = i.split('group').pop() || '-1'\n        const pasreId = parseInt(IdNum, 10)\n        if (!isNaN(pasreId) && lastControlId < pasreId) {\n          lastControlId = pasreId\n        }\n      }\n    }\n    return `group${lastControlId + 1}`\n  }\n\n  @Emit('createGroup')\n  createGroup (groupId: string) {\n    return groupId\n  }\n\n  updateControlGroupID (groupName: string, updateGroupId: string) {\n    for (const val in this.userformData[this.userFormId]) {\n      if (!val.startsWith('ID_USERFORM')) {\n        const controlGrpId = this.userformData[this.userFormId][val].properties\n          .GroupID\n        if (controlGrpId === groupName) {\n          this.updateControlProperty('GroupID', updateGroupId, val)\n        }\n      }\n    }\n  }\n  /**\n   * @description To update the group Information in main data\n   * @function groupControl\n   */\n  groupControl () {\n    let updateGroupId: string = ''\n    const selected = this.selectedControls[this.userFormId].selected\n\n    const selectedGroupArray = selected.filter(\n      (val: string) => val.startsWith('group') && val\n    )\n    updateGroupId = selectedGroupArray[0]\n    if (selectedGroupArray.length >= 2) {\n      const groupArray = [\n        ...this.groupedControls[this.userFormId]!.groupArray!\n      ]\n      for (let i = 0; i < groupArray.length; i++) {\n        for (let j = 0; j < selectedGroupArray.length; j++) {\n          if (selectedGroupArray[j] === groupArray[i]) {\n            this.updateControlGroupID(groupArray[i], selectedGroupArray[0])\n            groupArray.splice(i, 1)\n          }\n        }\n      }\n      this.updateGroup({\n        userFormId: this.userFormId,\n        groupArray: [...groupArray, selectedGroupArray[0]]\n      })\n      updateGroupId = selectedGroupArray[0]!\n    } else if (selectedGroupArray.length === 0) {\n      updateGroupId = this.createGroupId()\n      const groupArray = [\n        ...this.groupedControls[this.userFormId]!.groupArray!,\n        updateGroupId\n      ]\n      this.updateGroup({ userFormId: this.userFormId, groupArray: groupArray })\n    }\n\n    for (let val of selected) {\n      if (!val.startsWith('group')) {\n        this.updateControlProperty('GroupID', updateGroupId, val)\n      }\n    }\n    this.createGroup(updateGroupId)\n    this.selectControl({\n      userFormId: this.userFormId,\n      select: {\n        container: this.getContainerList(updateGroupId),\n        selected: [updateGroupId]\n      }\n    })\n  }\n\n  /**\n   * @description To select all the controls in respective container present in respective userform\n   * @function selectAll\n   */\n  selectAll () {\n    const controlObjectList = [\n      ...this.userformData[this.userFormId][this.containerId].controls\n    ]\n    const selecedGroup: string[] = []\n    for (const val of controlObjectList) {\n      const controlGroupId: string = this.userformData[this.userFormId][val]\n        .properties.GroupID!\n      if (controlGroupId && controlGroupId !== '') {\n        !selecedGroup.includes(controlGroupId)! &&\n          selecedGroup.push(controlGroupId)\n      } else {\n        selecedGroup.push(val)\n      }\n    }\n\n    if (controlObjectList.length !== 0) {\n      this.selectControl({\n        userFormId: this.userFormId,\n        select: {\n          container: this.getContainerList(selecedGroup[0]),\n          selected: [...selecedGroup]\n        }\n      })\n    }\n  }\n\n  /**\n   * @description To update the cutted controls in respective container present in respective userform\n   * @function cutControl\n   */\n  cutControl () {\n    this.copyControl('cut')\n    this.clickDelete()\n  }\n\n  /**\n   * @description To update the copied controls in respective container present in respective userform\n   * @function copyControl\n   */\n  copyControl (type: string) {\n    for (let i = 0; i < this.copiedControl[this.userFormId][this.userFormId].controls.length; i++) {\n      this.deleteCopiedControl({\n        userFormId: this.userFormId,\n        parentId: this.userFormId,\n        targetId: this.copiedControl[this.userFormId][this.userFormId].controls[i]\n      })\n    }\n    const userFormData = this.userformData[this.userFormId]\n    const selContainer = this.selectedControls[this.userFormId].container[0]\n    const selSelected = this.selectedControls[this.userFormId].selected\n    const updateSelected = []\n    for (let control of selSelected) {\n      if (!control.startsWith('group') && userFormData[control].type === 'Page') {\n        control = this.getContainerList(control)[0]\n      }\n      updateSelected.push(control)\n    }\n    this.updateCopyControlList({\n      userFormId: this.userFormId,\n      parentId: selContainer,\n      targetId: updateSelected,\n      type: type\n    })\n\n    const recCopyControl = (daTarget: string) => {\n      const daTargetControls = userFormData[daTarget].controls\n      if (daTargetControls.length > 0) {\n        for (let i in daTargetControls) {\n          const controlObject = JSON.parse(JSON.stringify(userFormData[daTargetControls[i]]))\n          const controlArray = []\n          const ctrlObj = { ...controlObject, controls: [] }\n          this.addCopiedControl({\n            userFormId: this.userFormId,\n            controlId: daTarget,\n            addId: daTargetControls[i],\n            item: ctrlObj\n          })\n          recCopyControl(daTargetControls[i])\n        }\n      }\n    }\n\n    for (let key of selSelected) {\n      if (!key.startsWith('group')) {\n        if (userFormData[key].type === 'Page') {\n          key = this.getContainerList(key)[0]\n        }\n        const controlObject = JSON.parse(JSON.stringify(userFormData[key]))\n        const ctrlObj = { ...controlObject, controls: [] }\n        this.addCopiedControl({\n          userFormId: this.userFormId,\n          controlId: this.userFormId,\n          addId: key,\n          item: ctrlObj\n        })\n        recCopyControl(key)\n      } else {\n        for (let ctrlId in userFormData) {\n          const controlProp = userFormData[ctrlId].properties.GroupID\n          if (controlProp) {\n            if (controlProp === key) {\n              const controlObject = JSON.parse(\n                JSON.stringify(userFormData[ctrlId])\n              )\n              const ctrlObj = { ...controlObject, controls: [] }\n              this.addCopiedControl({\n                userFormId: this.userFormId,\n                controlId: this.userFormId,\n                addId: ctrlId,\n                item: ctrlObj\n              })\n              recCopyControl(ctrlId)\n            }\n          }\n        }\n      }\n    }\n  }\n  updateNewControl (parentId: string, ctrlId: string, ctrlObj: controlData, isParent: boolean) {\n    this.addControl({\n      userFormId: this.userFormId,\n      controlId: parentId,\n      addId: ctrlId,\n      item: ctrlObj\n    })\n    if (isParent) {\n      const newTabIndex = this.userformData[this.userFormId][parentId].controls.length\n      this.updateTabIndexValue(ctrlId)\n      this.updateZIndexValue(ctrlId)\n    }\n  }\n\n  newPasteControlId (key: string, parentId: string) {\n    const userFormData = this.userformData[this.userFormId]\n    let lastControlId = 0\n    const type = key in userFormData ? userFormData[key].type : ''\n    const parentName = parentId !== '' ? parentId.split('MultiPage').pop() : -1\n    const selectedControlName: string | undefined =\n    type === 'Page'\n      ? `Page${parentName}_`\n      : key.replace(/[0-9]/g, '').split('_').pop()\n    const userformControlIds = Object.keys(userFormData)\n    for (let i = 0; i < userformControlIds.length; i++) {\n      if (userformControlIds[i].indexOf(selectedControlName!) !== -1) {\n        const IdNum = userformControlIds[i].split(selectedControlName!).pop() || '-1'\n        const pasreId = parseInt(IdNum, 10)\n        if (!isNaN(pasreId) && lastControlId < pasreId) {\n          lastControlId = pasreId\n        }\n      }\n    }\n    lastControlId += 1\n    const Name = `${selectedControlName}${lastControlId}`\n    return Name\n  }\n  removeChildControl (daTarget: string, deleteControl: string) {\n    const removeControl = [...this.userformData[this.userFormId][daTarget].controls]\n    const removeIndex = removeControl.findIndex((val) => val === deleteControl)\n    removeControl.splice(removeIndex, 1)\n    this.setChildControls({\n      userFormId: this.userFormId,\n      containerId: daTarget,\n      targetControls: removeControl\n    })\n  }\n  /**\n   * @description To paste controls in respective container present in respective userform\n   * @function pasteControl\n   */\n  pasteControl () {\n    if (this.copyControlList.type === 'copy') {\n      const selContainer = this.copyControlList.parentId\n      const selSelected = this.copyControlList.targetId\n      const userFormData = this.userformData[this.userFormId]\n      const presentGroupId: string[] = []\n      const newGroupId: string[] = []\n      const oldControlId: string[] = []\n      const newControlId: string[] = []\n\n      for (const key in this.copiedControl[this.userFormId]) {\n        const controlProp = this.copiedControl[this.userFormId][key].properties.GroupID\n        if (controlProp && !presentGroupId.includes(controlProp)) {\n          presentGroupId.push(controlProp)\n        }\n      }\n      for (let j in presentGroupId) {\n        const newId = this.createGroupId()\n        newGroupId.push(newId)\n        let groupArray: string[] = [\n          ...this.groupedControls[this.userFormId]!.groupArray!,\n          newId\n        ]\n        this.updateGroup({\n          userFormId: this.userFormId,\n          groupArray: groupArray!\n        })\n      }\n\n      const recCopyControl = (daTarget: string) => {\n        const daTargetControls = userFormData[daTarget].controls\n        if (daTargetControls.length > 0) {\n          for (let i = 0, limit = daTargetControls.length; i < limit; i++) {\n            const key = daTargetControls[i]\n            const Name = this.newPasteControlId(key, daTarget)\n            const controlID:| string| undefined = `ID_${Name}`\n            const controlObj = { ...this.copiedControl[this.userFormId][key] }\n            let groupIdIndex = -1\n            groupIdIndex = presentGroupId.findIndex((val) => val === controlObj.properties.GroupID)\n            const item: controlData = {\n              ...controlObj,\n              properties: {\n                ...controlObj.properties,\n                ID: controlID!,\n                GroupID: groupIdIndex !== -1 ? newGroupId[groupIdIndex] : '',\n                Name: Name\n              }\n            }\n            this.removeChildControl(daTarget, key)\n            this.updateNewControl(daTarget, controlID, item, false)\n            recCopyControl(controlID)\n          }\n        }\n      }\n\n      for (const key of selSelected) {\n        if (!key.startsWith('group')) {\n          oldControlId.push(key)\n          const Name = this.newPasteControlId(key, '')\n          const controlID:| string| undefined = `ID_${Name}`\n          const controlObj = { ...this.copiedControl[this.userFormId][key] }\n          newControlId.push(controlID)\n          let groupIdIndex = -1\n          groupIdIndex = presentGroupId.findIndex(\n            (val) => controlObj.properties.GroupID === val\n          )\n          if (selSelected.length === 1 && this.copiedControl[this.userFormId][selSelected[0]].properties.GroupID !== '') {\n            groupIdIndex = -1\n          }\n          const item: controlData = {\n            ...controlObj,\n            properties: {\n              ...controlObj.properties,\n              ID: controlID!,\n              Left: controlObj.properties.Left! + 10,\n              Top: controlObj.properties.Top! + 10,\n              GroupID: groupIdIndex !== -1 ? newGroupId[groupIdIndex] : '',\n              Name: Name\n            }\n          }\n          this.updateNewControl(this.containerId, controlID, item, true)\n          recCopyControl(controlID)\n        } else {\n          for (let ctrlId in this.copiedControl[this.userFormId]) {\n            const controlProp = this.copiedControl[this.userFormId][ctrlId]\n              .properties.GroupID\n            if (controlProp) {\n              if (controlProp === key) {\n                const Name = this.newPasteControlId(ctrlId, '')\n                const controlID:| string| undefined = `ID_${Name}`\n                const controlObj = this.copiedControl[this.userFormId][ctrlId]\n\n                let groupIdIndex = -1\n                groupIdIndex = presentGroupId.findIndex(\n                  (val) => controlObj.properties.GroupID === val\n                )\n                const item: controlData = {\n                  ...controlObj,\n                  properties: {\n                    ...controlObj.properties,\n                    ID: controlID!,\n                    Left: controlObj.properties.Left! + 10,\n                    Top: controlObj.properties.Top! + 10,\n                    GroupID: groupIdIndex !== -1 ? newGroupId[groupIdIndex] : '',\n                    Name: Name\n                  }\n                }\n                this.updateNewControl(this.containerId, controlID, item, true)\n                recCopyControl(controlID)\n              }\n            }\n          }\n        }\n      }\n      for (let j of newGroupId) {\n        this.createGroup(j)\n      }\n      const newSelected: string[] = []\n      for (const control of selSelected) {\n        if (control.startsWith('group')) {\n          const index = presentGroupId.findIndex((val) => val === control)\n          newSelected.push(newGroupId[index])\n        } else {\n          const index = oldControlId.findIndex((val) => val === control)\n          newSelected.push(newControlId[index])\n        }\n      }\n      this.selectControl({\n        userFormId: this.userFormId,\n        select: {\n          container: this.getContainerList(newSelected[0]),\n          selected: newSelected\n        }\n      })\n    } else if (this.copyControlList.type === 'cut') {\n      const selContainer = this.copyControlList.parentId\n      const selSelected = this.copyControlList.targetId\n      const userFormData = this.copiedControl[this.userFormId]\n      const recCopyControl = (daTarget: string) => {\n        const daTargetControls = userFormData[daTarget].controls\n        if (daTargetControls.length > 0) {\n          for (let i = 0, limit = daTargetControls.length; i < limit; i++) {\n            const key = daTargetControls[i]\n            const controlObj = JSON.parse(JSON.stringify(this.copiedControl[this.userFormId][key]))\n            const item: controlData = {\n              ...controlObj\n            }\n            this.removeChildControl(daTarget, key)\n            this.updateNewControl(daTarget, key, item, false)\n            recCopyControl(key)\n          }\n        }\n      }\n      for (const key of selSelected) {\n        if (!key.startsWith('group')) {\n          const controlObj = JSON.parse(\n            JSON.stringify(this.copiedControl[this.userFormId][key])\n          )\n          if (selSelected.length === 1 && userFormData[selSelected[0]].properties.GroupID! !== '') {\n            controlObj.properties.GroupID = ''\n          }\n          const item: controlData = {\n            ...controlObj\n          }\n          this.updateNewControl(this.containerId, key, item, true)\n          recCopyControl(key)\n        } else {\n          for (let ctrlId in userFormData) {\n            const controlProp = userFormData[ctrlId].properties.GroupID\n            if (controlProp) {\n              if (controlProp === key) {\n                const controlObj = JSON.parse(\n                  JSON.stringify(this.copiedControl[this.userFormId][ctrlId])\n                )\n                const item: controlData = {\n                  ...controlObj\n                }\n                this.updateNewControl(this.containerId, ctrlId, item, true)\n                recCopyControl(ctrlId)\n              }\n            }\n          }\n        }\n      }\n      this.selectControl({\n        userFormId: this.userFormId,\n        select: {\n          container: this.getContainerList(selSelected[0]),\n          selected: selSelected\n        }\n      })\n      this.updateCopyControlList({\n        userFormId: this.userFormId,\n        parentId: this.containerId,\n        targetId: selSelected,\n        type: 'copy'\n      })\n    }\n  }\n\n  /**\n   * @description To delete controls in respective container present in respective userform\n   * @function clickDelete\n   */\n  clickDelete () {\n    const selControl = []\n    const userData = this.userformData[this.userFormId]\n    const selected = this.selectedControls[this.userFormId].selected\n    const selContainer = this.selectedControls[this.userFormId].container\n    const filterControls = []\n    const controls = this.userformData[this.userFormId][this.selectedControls[this.userFormId].container[0]].controls\n    for (const control of selected) {\n      if (!control.startsWith('ID_USERFORM')) {\n        if (control.startsWith('group')) {\n          for (const key in userData) {\n            if (\n              userData[key].properties.GroupID === control\n            ) {\n              selControl.push(key)\n            }\n          }\n        } else {\n          selControl.push(control)\n        }\n      }\n    }\n    if (selected.length === 1 && !selected[0].startsWith('group') && this.userformData[this.userFormId][selected[0]].properties.GroupID !== '') {\n      for (let j = 0; j < controls.length; j++) {\n        if (userData[controls[j]].properties.GroupID === userData[selected[0]].properties.GroupID) {\n          filterControls.push(controls[j])\n        }\n      }\n      if (filterControls.length === 2) {\n        const curSelect = filterControls[0] === selected[0] ? filterControls[1] : filterControls[0]\n        const selGroupId = userData[selected[0]].properties.GroupID\n        this.updateControlProperty('GroupID', '', curSelect)\n      }\n    }\n    for (let i = 0; i < selControl.length; i++) {\n      const controlId = userData[selControl[i]].type === 'Page' ? selContainer[0] : selControl[i]\n      this.deleteZIndex(controlId)\n      this.deleteTabIndex(controlId)\n      this.deleteControl({\n        userFormId: this.userFormId,\n        parentId: this.getContainerList(controlId)[0],\n        targetId: controlId\n      })\n    }\n\n    this.selectControl({\n      userFormId: this.userFormId,\n      select: {\n        container: userData[selContainer[0]].type === 'MultiPage' ? this.getContainerList(selContainer[0]) : selContainer,\n        selected: userData[selContainer[0]].type === 'MultiPage' ? [this.getContainerList(selContainer[0])[0]] : [selContainer[0]]\n      }\n    })\n    EventBus.$emit('focusUserForm')\n  }\n  updateAction (event: KeyboardEvent) {\n    let controlActionName = ''\n    if (event.ctrlKey && event.code === 'KeyA') {\n      controlActionName = 'ID_SELECTALL'\n    } else if (event.ctrlKey && event.code === 'KeyC') {\n      if (\n        this.selectedControls[this.userFormId].selected[0] !== this.userFormId\n      ) {\n        controlActionName = 'ID_COPY'\n      }\n    } else if (event.keyCode === 46) {\n      controlActionName = 'ID_DELETE'\n    } else if (event.ctrlKey && event.code === 'KeyV') {\n      controlActionName = 'ID_PASTE'\n    } else if (event.keyCode && event.code === 'KeyX') {\n      controlActionName = 'ID_CUT'\n    }\n    this.controlAction(controlActionName, '')\n  }\n  updatePropVal (propName: string, propValue: number) {\n    const ctrlSel = this.selectedControls[this.userFormId].selected\n    const usrFrmData = this.userformData[this.userFormId]\n    for (let index = 1; index < ctrlSel.length; index++) {\n      if (!ctrlSel[index].startsWith('group')) {\n        const curProp = usrFrmData[ctrlSel[index]].properties\n        if (propName === 'selRight') {\n          const curRight = curProp.Width! + curProp.Left!\n          const value = curProp.Left! + (propValue - curRight)\n          this.updateControlProperty('Left', value, ctrlSel[index])\n        } else if (propName === 'selBottom') {\n          const curBottom = curProp.Height! + curProp.Top!\n          const value = curProp.Top! + (propValue - curBottom)\n          this.updateControlProperty('Top', value, ctrlSel[index])\n        }\n        if (propName === 'selCenter') {\n          const curCenter = curProp.Width! / 2\n          const value = propValue - curCenter\n          this.updateControlProperty('Left', value, ctrlSel[index])\n        }\n        if (propName === 'selMiddle') {\n          const curMiddle = curProp.Height! / 2\n          const value = propValue - curMiddle\n          this.updateControlProperty('Top', value, ctrlSel[index])\n        } else {\n          const propertyname: keyof controlProperties = propName as keyof controlProperties\n          this.updateControlProperty(propertyname, propValue, ctrlSel[index])\n        }\n      } else {\n        const groupIndex: number = this.groupStyleArray.findIndex(val => val.groupName === ctrlSel[index])\n        const curProp = this.groupStyleArray[groupIndex]\n        const left = parseInt(curProp.left!)\n        const top = parseInt(curProp.top!)\n        const width = parseInt(curProp.width!)\n        const height = parseInt(curProp.height!)\n        let value = -1\n        if (propName === 'selRight') {\n          value = left! + (propValue - (width! + left!))\n          EventBus.$emit('updasteGroupSize', 'Left', value, groupIndex)\n        } else if (propName === 'selBottom') {\n          value = top! + (propValue - (height + top))\n          EventBus.$emit('updasteGroupSize', 'Top', value, groupIndex)\n        }\n        if (propName === 'selCenter') {\n          value = propValue - (width! / 2)\n          EventBus.$emit('updasteGroupSize', 'Left', value, groupIndex)\n        }\n        if (propName === 'selMiddle') {\n          value = propValue - height! / 2\n          EventBus.$emit('updasteGroupSize', 'Top', value, groupIndex)\n        } else {\n          const propertyname: keyof controlProperties = propName as keyof controlProperties\n          EventBus.$emit('updasteGroupSize', propertyname, propValue, groupIndex)\n        }\n      }\n    }\n  }\n  controlAlignMent (subVal: string) {\n    const mainSel = this.selectedControls[this.userFormId].selected[0]\n    const isGroup = mainSel.startsWith('group')\n    const usrFrmData = this.userformData[this.userFormId]\n    const ctrlProp = !isGroup && usrFrmData[mainSel].properties\n    const groupIndex: number = this.groupStyleArray.findIndex(val => val.groupName === mainSel)\n    const newObject = {\n      Left: isGroup && groupIndex !== -1 ? parseInt(this.groupStyleArray[groupIndex].left!) : ctrlProp ? ctrlProp.Left! : 0,\n      Top: isGroup && groupIndex !== -1 ? parseInt(this.groupStyleArray[groupIndex].top!) : ctrlProp ? ctrlProp.Top! : 0,\n      Width: isGroup && groupIndex !== -1 ? parseInt(this.groupStyleArray[groupIndex].width!) : ctrlProp ? ctrlProp.Width! : 0,\n      Height: isGroup && groupIndex !== -1 ? parseInt(this.groupStyleArray[groupIndex].height!) : ctrlProp ? ctrlProp.Height! : 0\n    }\n    if (subVal === 'ID_ALIGNLEFT') {\n      this.updatePropVal('Left', newObject.Left!)\n    } else if (subVal === 'ID_ALIGNTOP') {\n      this.updatePropVal('Top', newObject.Top!)\n    } else if (subVal === 'ID_ALIGNRIGHT') {\n      const selRight = newObject.Width! + newObject.Left!\n      this.updatePropVal('selRight', selRight)\n    } else if (subVal === 'ID_ALIGNBOTTOM') {\n      const selBottom = newObject.Height! + newObject.Top!\n      this.updatePropVal('selBottom', selBottom)\n    } else if (subVal === 'ID_ALIGNCENTER') {\n      const selCenter = newObject.Left! + newObject.Width! / 2\n      this.updatePropVal('selCenter', selCenter)\n    } else if (subVal === 'ID_ALIGNMIDDLE') {\n      const selMiddle = newObject.Top! + newObject.Height! / 2\n      this.updatePropVal('selMiddle', selMiddle)\n    } else if (subVal === 'ID_WIDTH') {\n      this.updatePropVal('Width', newObject.Width!)\n    } else if (subVal === 'ID_HEIGHT') {\n      this.updatePropVal('Height', newObject.Height!)\n    } else if (subVal === 'ID_BOTH') {\n      this.updatePropVal('Height', newObject.Height!)\n      this.updatePropVal('Width', newObject.Width!)\n    }\n  }\n\n  controlDisable (event: MouseEvent) {\n    event.preventDefault()\n    event.stopPropagation()\n  }\n}\n</script>\n\n<style scoped>\n.outercontext-div {\n  border: 0.3px solid black;\n  box-shadow: 2px 2px lightgray;\n  width: 150px;\n  height: auto;\n  font-size: 13px;\n  position: fixed;\n  z-index: 1000;\n}\n.wrapper-context {\n  display: grid;\n  grid-template-columns: 1fr;\n  width: 100%;\n  height: 100%;\n}\n.wrapper1-context {\n  display: grid;\n  grid-template-columns: 10% 90%;\n  border: 0.3px solid white;\n  background: white;\n  height: 24px;\n  padding-top: 5px;\n  outline: none;\n}\n.wrapper1-context:hover {\n  background-color: rgb(155, 215, 255);\n  border: 0.3px solid rgb(0, 153, 255);\n}\n.wrapper21 {\n  display: grid;\n  grid-template-columns: 10% 85% 5%;\n}\n.triangle-right {\n  width: 0;\n  height: 0;\n  border-top: 5px solid transparent;\n  border-left: 5px solid black;\n  border-bottom: 5px solid transparent;\n  padding-top: 2px;\n}\n.iset-context {\n  text-align: left;\n  padding-left: 15px;\n  font-size: 12px;\n}\n.set-context {\n  text-align: left;\n  padding-left: 15px;\n  font-size: 12px;\n}\nhr {\n  margin: 0px;\n}\nul {\n  list-style-type: none;\n  margin-block-start: 0em;\n  margin-block-end: 0em;\n  margin-inline-start: 0px;\n  margin-inline-end: 0px;\n  padding-inline-start: 0px;\n  margin-top: 0px;\n  margin-bottom: 0px;\n}\n\n/* testing submenu */\n\n.top-level-menu {\n  list-style: none;\n  padding: 0;\n  margin: 0;\n}\n\n.top-level-menu > li {\n  position: absolute;\n  float: left;\n  height: 30px;\n  width: 143px;\n}\n\n.top-level-menu li:hover > ul {\n  /* On hover, display the next level's menu */\n  display: inline;\n}\n\n/* Menu Link Styles */\n\n.top-level-menu a /* Apply to all links inside the multi-level menu */ {\n  font-size: 12px;\n  color: black;\n  text-decoration: none;\n  padding: 0 0 0 10px;\n  padding-left: 15px;\n\n  /* Make the link cover the entire list item-container */\n  display: block;\n}\n.top-level-menu a:hover {\n  color: black;\n}\n.third-level-menu {\n  position: absolute;\n  top: 0;\n  right: -100px;\n  width: 110px;\n  list-style: none;\n  padding: 0;\n  margin: 0;\n  display: none;\n  border: 1px solid black;\n  background-color: white;\n}\n\n.third-level-menu > li {\n  height: 20px;\n  padding-top: 5px;\n  /* margin: 1px; */\n}\n.third-level-menu > li:hover {\n  background-color: rgb(155, 215, 255);\n  border: 0.2px solid rgb(0, 153, 255);\n}\n.top-level-menu1 {\n  list-style: none;\n  padding: 0;\n  margin: 0;\n}\n\n.top-level-menu1 > li {\n  position: absolute;\n  float: left;\n  height: 30px;\n  width: 143px;\n}\n\n.top-level-menu1 li:hover > ul {\n  /* On hover, display the next level's menu */\n  display: inline;\n}\n\n/* Menu Link Styles */\n\n.top-level-menu1 a /* Apply to all links inside the multi-level menu */ {\n  font-size: 12px;\n  color: black;\n  text-decoration: none;\n  padding: 0 0 0 10px;\n  padding-left: 15px;\n\n  /* Make the link cover the entire list item-container */\n  display: block;\n}\n.top-level-menu1 a:hover {\n  color: black;\n}\n.third {\n  padding-left: 5px;\n}\n.third > a {\n  padding-left: 10px;\n}\n.icons {\n  margin-left: 3px;\n}\n</style>\n"]}]}