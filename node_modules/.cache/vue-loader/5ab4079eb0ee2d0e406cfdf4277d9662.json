{"remainingRequest":"/home/mobiotics/Projects/hancom/formcontrols/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/mobiotics/Projects/hancom/formcontrols/src/FormDesigner/components/atoms/FDToggleButton/index.vue?vue&type=style&index=0&id=54c33a74&scoped=true&lang=css&","dependencies":[{"path":"/home/mobiotics/Projects/hancom/formcontrols/src/FormDesigner/components/atoms/FDToggleButton/index.vue","mtime":1610544258554},{"path":"/home/mobiotics/Projects/hancom/formcontrols/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/mobiotics/Projects/hancom/formcontrols/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/home/mobiotics/Projects/hancom/formcontrols/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/home/mobiotics/Projects/hancom/formcontrols/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/mobiotics/Projects/hancom/formcontrols/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoudG9nZ2xlLWJ1dHRvbiB7CiAgd2lkdGg6IDBweDsKICBoZWlnaHQ6IDBweDsKICBsZWZ0OiAwcHg7CiAgdG9wOiAwcHg7CiAgYm94LXNoYWRvdzogMXB4IDFweCBncmF5OwogIGJvcmRlcjogbm9uZTsKICBvdmVyZmxvdzogaGlkZGVuOwogIG91dGxpbmU6IG5vbmU7CiAgYm94LXNpemluZzogYm9yZGVyLWJveDsKfQo="},{"version":3,"sources":["index.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.vue","sourceRoot":"src/FormDesigner/components/atoms/FDToggleButton","sourcesContent":["<template>\n  <button\n    class=\"toggle-button\"\n    :style=\"styleObj\"\n    :name=\"properties.Name\"\n    :tabindex=\"properties.TabIndex\"\n    :title=\"properties.ControlTipText\"\n    :runmode=\"getDisableValue\"\n    @mousedown=\"controlEditMode\"\n    @keydown.enter.prevent=\"setContentEditable($event, true)\"\n    @blur=\"\n      () => {\n        isClicked = false;\n        isFocus = false;\n      }\n    \"\n    @click.stop=\"toggleButtonClick\"\n  >\n    <span v-if=\"!syncIsEditMode || isRunMode\">\n      <span>{{ computedCaption.afterbeginCaption }}</span>\n      <span class=\"spanClass\">{{ computedCaption.acceleratorCaption }}</span>\n      <span>{{ computedCaption.beforeendCaption }}</span>\n    </span>\n    <FDEditableText\n      v-else\n      :editable=\"isRunMode === false && syncIsEditMode\"\n      :style=\"editCssObj\"\n      :caption=\"properties.Caption\"\n      @updateCaption=\"updateCaption\"\n      @releaseEditMode=\"releaseEditMode\"\n    >\n    </FDEditableText>\n  </button>\n</template>\n\n<script lang=\"ts\">\nimport { Component, Mixins, Watch } from 'vue-property-decorator'\nimport FdControlVue from '@/api/abstract/FormDesigner/FdControlVue'\nimport FDEditableText from '@/FormDesigner/components/atoms/FDEditableText/index.vue'\n\n@Component({\n  name: 'FDToggleButton',\n  components: {\n    FDEditableText\n  }\n})\nexport default class FDToggleButton extends Mixins(FdControlVue) {\n  $el!: HTMLButtonElement;\n  isClicked: boolean = true;\n  isFocus: boolean = false;\n  clickCount: number = 0;\n\n  /**\n   * @description getDisableValue checks for the RunMode of the control and then returns after checking for the Enabled\n   * and the Locked property\n   * @function getDisableValue\n   */\n  get getDisableValue () {\n    if (this.isRunMode) {\n      return (\n        this.properties.Enabled === false || this.properties.Locked === true\n      )\n    } else {\n      return true\n    }\n  }\n\n  /**\n   * @description toggleButtonClick is a method to check the check the clicked functionality of the button tag.\n   * Also It sets the variables isClicked and isFocus based on the Locked property\n   * @function toggleButtonClick\n   * @param MouseEvent\n   */\n  toggleButtonClick (e: MouseEvent) {\n    if (this.isRunMode) {\n      this.clickCount = this.clickCount + 1\n      if (this.properties.Locked === false) {\n        this.isFocus = true\n        this.isClicked = !this.isClicked\n        if (this.properties.TripleState) {\n          if (this.clickCount % 3 === 0) {\n            this.updateDataModel({ propertyName: 'Value', value: '' })\n          } else if (this.isClicked) {\n            this.updateDataModel({ propertyName: 'Value', value: 'True' })\n          } else {\n            this.updateDataModel({ propertyName: 'Value', value: 'False' })\n          }\n        } else if (this.isClicked) {\n          this.updateDataModel({ propertyName: 'Value', value: 'True' })\n        } else {\n          this.updateDataModel({ propertyName: 'Value', value: 'False' })\n        }\n      } else {\n        this.isClicked = false\n      }\n    }\n    this.selectedItem(e)\n    if (this.isEditMode) {\n      (this.$el.children[0] as HTMLSpanElement).focus()\n    }\n  }\n\n  /**\n   * @description style object is passed to :style attribute in button tag\n   * dynamically changing the styles of the component based on properties\n   * @function styleObj\n   *\n   */\n  protected get styleObj (): Partial<CSSStyleDeclaration> {\n    const controlProp = this.properties\n    const font: font = controlProp.Font\n      ? controlProp.Font\n      : {\n        FontName: 'Arial',\n        FontSize: 10,\n        FontItalic: true,\n        FontBold: true,\n        FontUnderline: true,\n        FontStrikethrough: true\n      }\n    let display = ''\n    if (this.isRunMode) {\n      display = controlProp.Visible ? 'inline-block' : 'none'\n    } else {\n      display = 'inline-block'\n    }\n    return {\n      left: `${controlProp.Left}px`,\n      width: `${controlProp.Width}px`,\n      height: `${controlProp.Height}px`,\n      top: `${controlProp.Top}px`,\n      boxShadow: controlProp.Enabled\n        ? controlProp.Value === 'False' || controlProp.Value === 'false'\n          ? '1px 1px gray'\n          : controlProp.Value === 'True' || controlProp.Value === 'true'\n            ? '-1px -1px black'\n            : '1px 1px gray'\n        : '1px 1px gray',\n      backgroundColor: controlProp.BackStyle ? controlProp.BackColor : 'transparent',\n      outline: controlProp.Enabled\n        ? this.isFocus\n          ? '1px dotted black'\n          : 'none'\n        : 'none',\n      outlineOffset: this.isClicked ? '-5px' : '-5px',\n      display: display,\n      color:\n        controlProp.Enabled === true &&\n        (controlProp.Value === 'False' ||\n          controlProp.Value === 'false' ||\n          controlProp.Value === 'True' ||\n          controlProp.Value === 'true')\n          ? controlProp.ForeColor\n          : this.getEnabled,\n      cursor:\n        controlProp.MousePointer !== 0 || controlProp.MouseIcon !== ''\n          ? this.getMouseCursorData\n          : 'default',\n      fontFamily: (font.FontStyle! !== '') ? this.setFontStyle : font.FontName!,\n      fontSize: `${font.FontSize}px`,\n      fontStyle: font.FontItalic || this.isItalic ? 'italic' : '',\n      textDecoration:\n        font.FontStrikethrough === true && font.FontUnderline === true\n          ? 'underline line-through'\n          : font.FontUnderline\n            ? 'underline'\n            : font.FontStrikethrough\n              ? 'line-through'\n              : '',\n      textUnderlinePosition: 'under',\n      fontWeight: font.FontBold ? 'bold' : (font.FontStyle !== '') ? this.tempWeight : '',\n      fontStretch: (font.FontStyle !== '') ? this.tempStretch : '',\n      whiteSpace: controlProp.WordWrap ? 'pre-wrap' : 'pre',\n      wordBreak: controlProp.WordWrap ? 'break-all' : 'normal',\n      paddingLeft: controlProp.AutoSize ? '0px' : '0px',\n      paddingRight: controlProp.WordWrap ? '0px' : '6px',\n      textAlign:\n        controlProp.TextAlign === 0\n          ? 'left'\n          : controlProp.TextAlign === 1\n            ? 'center'\n            : 'right',\n      backgroundImage: `url(${controlProp.Picture})`,\n      backgroundRepeat: this.getRepeat,\n      backgroundPosition: controlProp.Picture ? this.getPosition : '',\n      backgroundPositionX: controlProp.Picture ? this.getPositionX : '',\n      backgroundPositionY: controlProp.Picture ? this.getPositionY : '',\n      borderLeft: controlProp.Value !== 'True' ? '1px solid' : '',\n      borderTop: controlProp.Value !== 'True' ? '1px solid' : '',\n      borderRight: controlProp.Value === 'True' ? '1px solid' : '',\n      borderBottom: controlProp.Value === 'True' ? '1px solid' : '',\n      borderTopColor: controlProp.Value !== 'True' ? 'white !important' : '',\n      borderLeftColor: controlProp.Value !== 'True' ? 'white !important' : '',\n      borderBottomColor: controlProp.Value === 'True' ? 'white !important' : '',\n      borderRightColor: controlProp.Value === 'True' ? 'white !important' : ''\n    }\n  }\n\n  /**\n   * @description style object is passed to :style attribute in tag\n   * dynamically changing the styles of the component based on properties\n   * @function editCssObj\n   *\n   */\n  protected get editCssObj (): Partial<CSSStyleDeclaration> {\n    const controlProp = this.properties\n    return {\n      backgroundImage: 'none'\n    }\n  }\n\n  /**\n   * @description watches changes in properties to set autoset when true\n   * @function autoSize\n   * @param oldVal previous properties data\n   * @param newVal  new/changed properties data\n   */\n  @Watch('properties.AutoSize', { deep: true })\n  autoSize (newVal: boolean, oldVal: boolean) {\n    // if autoSize is true then height and width value will not get updated\n    this.updateAutoSize()\n  }\n\n  @Watch('properties.Font.FontSize', { deep: true })\n  autoSizeValidateOnFontChange () {\n    if (this.properties.AutoSize) {\n      this.updateAutoSize()\n    }\n  }\n\n  @Watch('properties.WordWrap', { deep: true })\n  autoSizeValidateOnWordWrapChange () {\n    if (this.properties.AutoSize) {\n      this.updateAutoSize()\n    }\n  }\n\n  @Watch('properties.Caption', { deep: true })\n  autoSizeValidateOnCaptionChange () {\n    if (this.properties.AutoSize) {\n      this.updateAutoSize()\n    }\n  }\n\n  /**\n   * @description changes width and height when autoSize is true by getting content offsetWidth\n   *  and offsetHeight with the help of Ref attribute\n   * @function updateAutoSize\n   * @override\n   */\n  updateAutoSize () {\n    if (this.properties.AutoSize === true) {\n      this.$nextTick(() => {\n        this.updateDataModel({\n          propertyName: 'Height',\n          value:\n            (this.$el.childNodes[0] as HTMLSpanElement)\n              .offsetHeight + 5\n        })\n        this.updateDataModel({\n          propertyName: 'Width',\n          value:\n            (this.$el.childNodes[0] as HTMLSpanElement)\n              .offsetWidth + 5\n        })\n      })\n    }\n  }\n\n  /**\n   * @description mounted initializes the values which are required for the component\n   */\n  mounted () {\n    this.$el.focus()\n    this.updateAutoSize()\n  }\n  releaseEditMode (event: KeyboardEvent) {\n    this.$el.focus()\n    this.setContentEditable(event, false)\n  }\n}\n</script>\n\n<style scoped>\n.toggle-button {\n  width: 0px;\n  height: 0px;\n  left: 0px;\n  top: 0px;\n  box-shadow: 1px 1px gray;\n  border: none;\n  overflow: hidden;\n  outline: none;\n  box-sizing: border-box;\n}\n</style>\n"]}]}