{"remainingRequest":"/home/mobiotics/Projects/formcontrols/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/mobiotics/Projects/formcontrols/src/FormDesigner/components/atoms/FDTextBox/index.vue?vue&type=style&index=0&id=e831a758&scoped=true&lang=css&","dependencies":[{"path":"/home/mobiotics/Projects/formcontrols/src/FormDesigner/components/atoms/FDTextBox/index.vue","mtime":1610544258554},{"path":"/home/mobiotics/Projects/formcontrols/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/mobiotics/Projects/formcontrols/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/home/mobiotics/Projects/formcontrols/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/home/mobiotics/Projects/formcontrols/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/mobiotics/Projects/formcontrols/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKLnRleHQtYm94LWRlc2lnbiB7CiAgd2lkdGg6IDBweDsKICBoZWlnaHQ6IDBweDsKICBsZWZ0OiAwcHg7CiAgdG9wOiAwcHg7CiAgcmVzaXplOiBub25lOwogIG92ZXJmbG93OiBoaWRkZW47CiAgYm94LXNpemluZzogYm9yZGVyLWJveDsKfQoudGV4dC1ib3gtZGVzaWduOmZvY3VzIHsKICBvdXRsaW5lOiBub25lOwp9Ci50ZXh0LWJveC1kZXNpZ246OnNlbGVjdGlvbiB7CiAgYmFja2dyb3VuZDogbGlnaHRibHVlOwp9Cg=="},{"version":3,"sources":["index.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAykBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.vue","sourceRoot":"src/FormDesigner/components/atoms/FDTextBox","sourcesContent":["<template>\n  <div class=\"resp-textbox\"\n  v-on=\"eventStoppers()\"\n  @click=\"selectedItem\"\n  @mousedown=\"controlEditMode\"\n  :tabindex=\"properties.TabIndex\"\n  @keydown.enter=\"setContentEditable($event, true)\"\n  >\n    <textarea\n      data-gramm=\"false\"\n      ref=\"textareaRef\"\n      :style=\"cssStyleProperty\"\n      :tabindex=\"properties.TabIndex\"\n      :maxlength=\"properties.MaxLength !==0 ? properties.MaxLength : ''\"\n      :disabled=\"getDisableValue\"\n      :title=\"properties.ControlTipText\"\n      :readonly=\"properties.Locked\"\n      @keydown.escape.exact=\"releaseEditMode\"\n      v-cursorDirective=\"{\n        start: data.properties.CursorStartPosition,\n        end: data.properties.CursorEndPosition,\n        pwdCharType: properties.PasswordChar,\n      }\"\n      @keydown.tab=\"tabKeyBehavior\"\n      @keydown.enter=\"enterKeyBehavior\"\n      @input=\"\n        properties.PasswordChar === ''\n          ? textAndValueUpdate($event)\n          : handlePasswordChar($event)\n      \"\n      @keydown=\"properties.PasswordChar !== '' ? handleDelete($event) : null\"\n      @blur=\"handleBlur($event, textareaRef, hideSelectionDiv)\"\n      @click=\"handleClick(hideSelectionDiv)\"\n      class=\"text-box-design\"\n      :value=\"\n        properties.Value\n          | passwordFilter(properties.PasswordChar, properties.Value)\n      \"\n      @dragstart=\"dragBehavior\"\n    />\n    <div\n      ref=\"hideSelectionDiv\"\n      @click=\"divHide($event, textareaRef)\"\n      :style=\"divcssStyleProperty\"\n      :title=\"properties.ControlTipText\"\n      class=\"text-box-design\"\n    >\n      {{\n        properties.Value\n          | passwordFilter(properties.PasswordChar, properties.Value)\n      }}\n    </div>\n    <label ref=\"autoSizeTextarea\"></label>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport {\n  Component,\n  Vue,\n  Prop,\n  Ref,\n  Watch,\n  Emit,\n  Mixins\n} from 'vue-property-decorator'\nimport FdControlVue from '@/api/abstract/FormDesigner/FdControlVue'\nimport { DirectiveBinding } from 'vue/types/options'\n\n@Component({\n  name: 'FDTextBox',\n  filters: {\n    /**\n     * @description filter to show passwordChar instead of original text\n     * @function passwordFilter\n     * @param value text to be filtered\n     * @param password passwordChar value to filter the text\n     * @param text  TextBox properties Text Value\n     */\n    passwordFilter (value: string, password: string, text: string) {\n      if (password !== '' && text !== '') {\n        let filteredValue: string = ''\n        for (let index = 0; index < text.length; index++) {\n          filteredValue = filteredValue + password[0]\n        }\n        return filteredValue\n      } else {\n        return value\n      }\n    }\n  },\n  directives: {\n    cursorDirective: {\n      /**\n       * @description  called after the containing component’s VNode has updated\n       * updates selection start and end cursor positon when data model value changes\n       * to maintain cursor position\n       * @function update Hook Functions i.e, (bind, inserted, update, componentUpdated, unbind)\n       * @param event The element the directive is bound to. This can be used to directly manipulate the DOM.\n       * @param vnode The virtual node produced by Vue’s compiler\n       */\n      update (event: HTMLElement, vnode: DirectiveBinding) {\n        if (vnode.value.pwdCharType !== '') {\n          (event as HTMLFormElement).selectionStart = vnode.value.start;\n          (event as HTMLFormElement).selectionEnd = vnode.value.end\n        } else {\n          return undefined\n        }\n      }\n    }\n  }\n})\nexport default class FDTextBox extends Mixins(FdControlVue) {\n  @Ref('hideSelectionDiv') readonly hideSelectionDiv!: HTMLDivElement;\n  @Ref('autoSizeTextarea') readonly autoSizeTextarea!: HTMLLabelElement;\n  @Ref('textareaRef') textareaRef: HTMLTextAreaElement;\n  $el: HTMLDivElement\n  get getDisableValue () {\n    if (this.isRunMode || this.isEditMode) {\n      return (\n        this.properties.Enabled === false || this.properties.Locked === true\n      )\n    } else {\n      return true\n    }\n  }\n  /**\n   * @description style object is passed to :style attribute in Textarea tag\n   * dynamically changing the styles of the component based on properties\n   * @function cssStyleProperty\n   *\n   */\n  get cssStyleProperty () {\n    const controlProp = this.properties\n    const font: font = controlProp.Font\n      ? controlProp.Font\n      : {\n        FontName: 'Arial',\n        FontSize: 10,\n        FontItalic: true,\n        FontBold: true,\n        FontUnderline: true,\n        FontStrikethrough: true,\n        FontStyle: 'Arial'\n      }\n    return {\n      left: `${controlProp.Left}px`,\n      width: `${controlProp.Width}px`,\n      height: `${controlProp.Height}px`,\n      top: `${controlProp.Top}px`,\n      borderColor: controlProp.BorderStyle === 1 ? controlProp.BorderColor : '',\n      textAlign:\n        controlProp.TextAlign === 0\n          ? 'left'\n          : controlProp.TextAlign === 1\n            ? 'center'\n            : 'right',\n      backgroundColor: controlProp.BackStyle ? controlProp.BackColor : 'transparent',\n      borderLeft: controlProp.BorderStyle === 1 ? '1px solid ' + controlProp.BorderColor : controlProp.SpecialEffect === 2 ? '2px solid gray' : controlProp.SpecialEffect === 3 ? '1.5px solid gray' : controlProp.SpecialEffect === 4 ? '0.5px solid gray' : '',\n      borderRight: controlProp.BorderStyle === 1 ? '1px solid ' + controlProp.BorderColor : controlProp.SpecialEffect === 1 ? '2px solid gray' : controlProp.SpecialEffect === 4 ? '1.5px solid gray' : controlProp.SpecialEffect === 3 ? '0.5px solid gray' : '',\n      borderTop: controlProp.BorderStyle === 1 ? '1px solid ' + controlProp.BorderColor : controlProp.SpecialEffect === 2 ? '2px solid gray' : controlProp.SpecialEffect === 3 ? '1.5px solid gray' : controlProp.SpecialEffect === 4 ? '0.5px solid gray' : '',\n      borderBottom: controlProp.BorderStyle === 1 ? '1px solid ' + controlProp.BorderColor : controlProp.SpecialEffect === 1 ? '2px solid gray' : controlProp.SpecialEffect === 4 ? '1.5px solid gray' : controlProp.SpecialEffect === 3 ? '0.5px solid gray' : '',\n      whiteSpace:\n        controlProp.WordWrap && controlProp.MultiLine ? 'normal' : 'nowrap',\n      wordBreak:\n        controlProp.WordWrap && controlProp.MultiLine ? 'break-word' : 'normal',\n      color:\n        controlProp.Enabled === true ? controlProp.ForeColor : this.getEnabled,\n      cursor:\n        controlProp.MousePointer !== 0 || controlProp.MouseIcon !== ''\n          ? this.getMouseCursorData\n          : 'default',\n      fontFamily: (font.FontStyle! !== '') ? this.setFontStyle : font.FontName!,\n      fontSize: `${font.FontSize}px`,\n      fontStyle: font.FontItalic || this.isItalic ? 'italic' : '',\n      textDecoration:\n        font.FontStrikethrough === true && font.FontUnderline === true\n          ? 'underline line-through'\n          : font.FontUnderline\n            ? 'underline'\n            : font.FontStrikethrough\n              ? 'line-through'\n              : '',\n      fontWeight: font.FontBold ? 'bold' : (font.FontStyle !== '') ? this.tempWeight : '',\n      fontStretch: (font.FontStyle !== '') ? this.tempStretch : '',\n      display: controlProp.Visible ? 'block' : 'none',\n      overflowX: this.getScrollBarX,\n      overflowY: this.getScrollBarY\n      // position: 'relative'\n    }\n  }\n\n  /**\n   * @description updates the dataModel textBox object properties when user insert/delete text\n   * inside textBox when passwordChar is set, updates text and values properties of textBox with entered character\n   * @function handlePasswordChar\n   * @param event its of type TextEvent\n   * @event input\n   *\n   */\n  handlePasswordChar (event: TextEvent) {\n    let newData\n    let text = this.properties.Text!\n    let selectionDiff =\n      (this.data.properties!.CursorStartPosition as number) !==\n      (this.data.properties!.CursorEndPosition as number)\n    if (event.target instanceof HTMLTextAreaElement) {\n      if (selectionDiff) {\n        // selection\n        newData =\n        text.substring(0, this.data.properties!.CursorStartPosition as number) +\n        text.substring(this.data.properties!.CursorEndPosition as number)\n        this.updateDataModel({ propertyName: 'Text', value: newData })\n        this.updateDataModel({ propertyName: 'Value', value: newData })\n      } else if (text.length < event.target.value.length) {\n        // insertion\n        newData = [\n          text.slice(0, event.target.selectionStart - 1),\n          event.data,\n          text.slice(event.target.selectionStart - 1)\n        ].join('')\n        this.updateDataModel({ propertyName: 'Text', value: newData })\n        this.updateDataModel({ propertyName: 'Value', value: newData })\n      } else if (text.length > event.target.value.length) {\n        // deletion\n        newData = [\n          text.slice(0, event.target.selectionStart),\n          text.slice(event.target.selectionStart + 1)\n        ].join('')\n        this.updateDataModel({ propertyName: 'Text', value: newData })\n        this.updateDataModel({ propertyName: 'Value', value: newData })\n      }\n      this.updateDataModel({\n        propertyName: 'CursorStartPosition',\n        value: event.target.selectionStart\n      })\n      this.updateDataModel({\n        propertyName: 'CursorEndPosition',\n        value: event.target.selectionEnd\n      })\n    } else {\n      throw new Error('Expected HTMLTextAreaElement but found different element')\n    }\n  }\n  /**\n   * @description style object is passed to :style attribute in div tag\n   * dynamically changing the styles of the component based on cssStyleProperty of\n   * textarea\n   * @function divcssStyleProperty\n   *\n   */\n  get divcssStyleProperty () {\n    const styleObject = this.cssStyleProperty\n    return {\n      ...styleObject,\n      display: 'none',\n      paddingTop: '2px',\n      paddingLeft: '2px'\n    }\n  }\n  /**\n   * @description When user enters ctrl + enter cursor moves to next line\n   * @function handleCtrlEnter\n   * @param el its of type HTMLTextAreaElement\n   * @param text new line character\n   * @event keydown.enter.ctrl\n   */\n  handleCtrlEnter (el : HTMLTextAreaElement, text: string) {\n    el.focus()\n    if (typeof el.selectionStart === 'number' &&\n            typeof el.selectionEnd === 'number') {\n      const val = el.value\n      const selStart = el.selectionStart\n      el.value = val.slice(0, selStart) + text + val.slice(el.selectionEnd)\n      el.selectionEnd = el.selectionStart = selStart + text.length\n    }\n  }\n  /**\n   * @description EnterKeyBehavior - if true when enter is pressed while editing the cursor moves to next line\n   *  if false the cursor remains in same place\n   * @function enterKeyBehavior\n   * @param event its of type KeyboardEvent\n   * @event keydown.enter\n   */\n  enterKeyBehavior (event: KeyboardEvent): boolean {\n    if (this.properties.MultiLine) {\n      if (event.ctrlKey) {\n        this.handleCtrlEnter(this.textareaRef, '\\n')\n        return true\n      } else if (this.properties.EnterKeyBehavior && this.properties.MultiLine) {\n        return true\n      } else if (event.shiftKey) {\n        return true\n      }\n    }\n    event.preventDefault()\n    return false\n  }\n\n  /**\n   * @description  specifies how the control responds to the TAB key\n   * when  TabKeyBehavior true in textBox tab spaces are added on press of tab Key\n   * when TabKeyBehavior false in textBox pressing tab moves focus to next controls\n   * @function tabKeyBehavior\n   * @param event its of type MouseEvent\n   * @event keydown.tab\n   */\n  tabKeyBehavior (event: KeyboardEvent): boolean {\n    if (this.properties.TabKeyBehavior) {\n      const TABKEY = 9\n      if (event.target instanceof HTMLTextAreaElement) {\n        event.stopPropagation()\n        const eventTaget = event.target\n        const selectionStart = eventTaget.selectionStart\n        const selectionEnd = eventTaget.selectionEnd\n        const value = eventTaget.value\n        if (event.keyCode === TABKEY) {\n          (event.target).value =\n          value.substring(0, selectionStart) +\n          '\\t' +\n          value.substring(selectionEnd)\n          event.preventDefault()\n        }\n        (event.target).selectionStart = selectionStart + 1;\n        (event.target).selectionEnd = (event.target).selectionStart\n        return false\n      } else {\n        throw new Error('Expected HTMLTextAreaElement but found different element')\n      }\n    } else {\n      return true\n    }\n  }\n  /**\n   * @description updates the dataModel textBox object properties when user insert/delete text\n   * inside textBox, updates text and values properties of textBox\n   * @function textAndValueUpdate\n   * @param event its of type InputEvent\n   * @event input\n   *\n   */\n  textAndValueUpdate (event: InputEvent) {\n    const propData = this.properties\n    if (event.target instanceof HTMLTextAreaElement) {\n      this.updateDataModel({\n        propertyName: 'Value',\n        value: (event.target).value\n      })\n      this.updateDataModel({\n        propertyName: 'Text',\n        value: (event.target).value\n      })\n      if (this.properties.ControlSource !== '') {\n        this.updateDataModelExtraData({\n          propertyName: 'ControlSourceValue',\n          value: (event.target).value\n        })\n      } else {\n        return undefined\n      }\n    } else {\n      throw new Error('Expected HTMLTextAreaElement but found different element')\n    }\n    if (this.properties.AutoSize) {\n      this.updateAutoSize()\n    }\n  }\n\n  @Watch('properties.Font.FontSize', { deep: true })\n  autoSizeValidateOnFontChange () {\n    if (this.properties.AutoSize) {\n      this.updateAutoSize()\n    }\n  }\n\n  @Watch('properties.WordWrap', { deep: true })\n  autoSizeValidateOnWordWrapChange () {\n    if (this.properties.AutoSize) {\n      this.updateAutoSize()\n    }\n  }\n\n  /**\n   * @description dragBehavior - if true when dragging\n   *  if false the cursor remains in same place\n   * @function dragBehavior\n   * @param event its of type KeyboardEvent\n   * @event dragStart\n   */\n  dragBehavior (e: Event) {\n    if (this.properties.DragBehavior) {\n      return true\n    }\n    e.preventDefault()\n  }\n\n  /**\n   * @override\n   */\n  @Watch('properties.AutoSize', { deep: true })\n  updateAutoSize () {\n    if (this.properties.AutoSize === true) {\n      this.$nextTick(() => {\n        const textareaRef: HTMLTextAreaElement = this.textareaRef\n        // replication of stype attribute to Label tag for autoSize property to work\n        let tempLabel: HTMLLabelElement = this.autoSizeTextarea\n        tempLabel.style.display = 'inline'\n        tempLabel.style.fontStyle = textareaRef.style.fontStyle\n        tempLabel.style.fontSize =\n            parseInt(textareaRef.style.fontSize) + 'px'\n        tempLabel.style.whiteSpace = textareaRef.style.whiteSpace\n        tempLabel.style.wordBreak = textareaRef.style.wordBreak\n        tempLabel.style.fontWeight = textareaRef.style.fontWeight\n        tempLabel.style.width = textareaRef.style.width\n        tempLabel.style.height = textareaRef.style.height\n        tempLabel.innerText = textareaRef.value\n        this.updateDataModel({\n          propertyName: 'Width',\n          value: tempLabel.offsetWidth + 5\n        })\n        this.updateDataModel({\n          propertyName: 'Height',\n          value: tempLabel.offsetHeight + 5\n        })\n        tempLabel.innerText = ''\n        tempLabel.style.display = 'none'\n      })\n    } else {\n      return undefined\n    }\n  }\n\n  created () {\n    const propData: controlData = this.data\n    if (propData.properties.ControlSource !== '') {\n      const controlSourceValue = propData.extraDatas!.ControlSourceValue\n      this.updateDataModel({\n        propertyName: 'Value',\n        value: controlSourceValue\n      })\n      this.updateDataModel({ propertyName: 'Text', value: controlSourceValue })\n    }\n  }\n\n  /**\n  * @description watches ControlSource property\n  * @function updateControlSourceValue\n  * @param oldVal previous string value\n  * @param newVal  new/changed string value\n  */\n  @Watch('properties.ControlSource', { deep: true })\n  updateControlSourceValue (newVal: string, oldVal: string) {\n    const propData: controlData = this.data\n    if (propData.properties.ControlSource !== '') {\n      const controlSourceValue = propData.extraDatas!.ControlSourceValue\n      this.updateDataModel({\n        propertyName: 'Value',\n        value: controlSourceValue\n      })\n      this.updateDataModel({ propertyName: 'Text', value: controlSourceValue })\n    } else {\n      this.updateDataModel({\n        propertyName: 'Value',\n        value: ''\n      })\n      this.updateDataModel({ propertyName: 'Text', value: '' })\n    }\n  }\n  /**\n   * @description keep tracks of key press and selectionStart and selectionEnd\n   * updates extra property CursorStartPosition and CursorEndPosition which is required\n   * when user insert, update or delete text in textBox\n   * @function handleDelete\n   * @param event it is of type KeyboardEvent\n   * @event keydown\n   */\n  handleDelete (event: KeyboardEvent) {\n    if (event.target instanceof HTMLTextAreaElement) {\n      if (event.keyCode === 8) {\n        this.updateDataModel({\n          propertyName: 'CursorStartPosition',\n          value: (event.target).selectionStart!\n        })\n        this.updateDataModel({\n          propertyName: 'CursorEndPosition',\n          value: (event.target).selectionEnd!\n        })\n      } else {\n        return undefined\n      }\n    } else {\n      throw new Error('Expected HTMLTextAreaElement but found different element')\n    }\n  }\n  /**\n   * @description  show selection when TextBox loses focus\n   * when HideSelection is false selection is show if user selects any text\n   * @function handleBlur\n   * @event blur\n   *\n   */\n  handleBlur (\n    event: TextEvent,\n    textareaRef: HTMLTextAreaElement,\n    hideSelectionDiv: HTMLDivElement\n  ) {\n    if (!this.properties.HideSelection) {\n      if (event.target instanceof HTMLTextAreaElement) {\n        const eventTarget = event.target\n        hideSelectionDiv.style.display = 'block'\n        hideSelectionDiv.style.height = this.properties.Height! + 2 + 'px'\n        hideSelectionDiv.style.width = this.properties.Width! + 2 + 'px'\n        textareaRef.style.display = 'none'\n        let textarea = eventTarget.value\n        let firstPart =\n        textarea.slice(0, eventTarget.selectionEnd) +\n        '</span>' +\n        textarea.slice(eventTarget.selectionEnd + Math.abs(0))\n        let text =\n        firstPart.slice(0, eventTarget.selectionStart) +\n        \"<span style='background-color:lightblue'>\" +\n        firstPart.slice(eventTarget.selectionStart + Math.abs(0))\n        hideSelectionDiv.innerHTML = text\n      } else {\n        throw new Error('Expected HTMLTextAreaElement but found different element')\n      }\n    } else {\n      return undefined\n    }\n  }\n  /**\n   *@description hides the div when focus comes to textarea when hideSelection\n   * properties is false\n   * @function handleClick\n   * @param event its of FocusEvent\n   * @event click\n   */\n  handleClick (hideSelectionDiv: HTMLDivElement) {\n    if (!this.properties.HideSelection) {\n      hideSelectionDiv.style.display = 'none'\n    } else {\n      return undefined\n    }\n  }\n  /**\n   * @description hides div instead of textarea when hideSelection is false\n   * when hideSelection properties is true textarea is shown\n   * when hideSelection properties is false div is shown\n   * @function divHide\n   * @param event its of type MouseEvent\n   * @event click\n   */\n  divHide (event: MouseEvent, textareaRef: HTMLTextAreaElement) {\n    if (event.target instanceof HTMLSpanElement || event.target instanceof HTMLDivElement) {\n      (event.target).style.display = 'none'\n      textareaRef.style.display = 'block'\n      if (\n        (event.target).tagName === 'SPAN' &&\n      (event.target).parentNode!.nodeName === 'DIV'\n      ) {\n        ((event.target)\n          .parentNode as HTMLElement).style.display = 'none'\n      }\n      textareaRef.focus()\n      textareaRef.selectionStart = textareaRef.selectionEnd\n    }\n  }\n\n  mounted () {\n    this.$el.focus()\n  }\n  releaseEditMode (event: KeyboardEvent) {\n    this.$el.focus()\n    this.setContentEditable(event, false)\n  }\n  eventStoppers () {\n    const eventStop = (event: Event) => event.stopPropagation()\n    return this.isEditMode === false ? null : {\n      keydown: eventStop\n    }\n  }\n}\n</script>\n\n<style scoped>\n.text-box-design {\n  width: 0px;\n  height: 0px;\n  left: 0px;\n  top: 0px;\n  resize: none;\n  overflow: hidden;\n  box-sizing: border-box;\n}\n.text-box-design:focus {\n  outline: none;\n}\n.text-box-design::selection {\n  background: lightblue;\n}\n</style>\n"]}]}