{"remainingRequest":"/home/mobiotics/Projects/formcontrols/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/mobiotics/Projects/formcontrols/src/FormDesigner/components/atoms/FDContextMenu/index.vue?vue&type=style&index=0&id=07dec5b8&scoped=true&lang=css&","dependencies":[{"path":"/home/mobiotics/Projects/formcontrols/src/FormDesigner/components/atoms/FDContextMenu/index.vue","mtime":1610544258554},{"path":"/home/mobiotics/Projects/formcontrols/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/mobiotics/Projects/formcontrols/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/home/mobiotics/Projects/formcontrols/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/home/mobiotics/Projects/formcontrols/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/mobiotics/Projects/formcontrols/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCi5vdXRlcmNvbnRleHQtZGl2IHsKICBib3JkZXI6IDAuM3B4IHNvbGlkIGJsYWNrOwogIGJveC1zaGFkb3c6IDJweCAycHggbGlnaHRncmF5OwogIHdpZHRoOiAxNTBweDsKICBoZWlnaHQ6IGF1dG87CiAgZm9udC1zaXplOiAxM3B4OwogIHBvc2l0aW9uOiBmaXhlZDsKICB6LWluZGV4OiAxMDAwOwp9Ci53cmFwcGVyLWNvbnRleHQgewogIGRpc3BsYXk6IGdyaWQ7CiAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAxZnI7CiAgd2lkdGg6IDEwMCU7CiAgaGVpZ2h0OiAxMDAlOwp9Ci53cmFwcGVyMS1jb250ZXh0IHsKICBkaXNwbGF5OiBncmlkOwogIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMTAlIDkwJTsKICBib3JkZXI6IDAuM3B4IHNvbGlkIHdoaXRlOwogIGJhY2tncm91bmQ6IHdoaXRlOwogIGhlaWdodDogMjRweDsKICBwYWRkaW5nLXRvcDogNXB4OwogIG91dGxpbmU6IG5vbmU7Cn0KLndyYXBwZXIxLWNvbnRleHQ6aG92ZXIgewogIGJhY2tncm91bmQtY29sb3I6IHJnYigxNTUsIDIxNSwgMjU1KTsKICBib3JkZXI6IDAuM3B4IHNvbGlkIHJnYigwLCAxNTMsIDI1NSk7Cn0KLndyYXBwZXIyMSB7CiAgZGlzcGxheTogZ3JpZDsKICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDEwJSA4NSUgNSU7Cn0KLnRyaWFuZ2xlLXJpZ2h0IHsKICB3aWR0aDogMDsKICBoZWlnaHQ6IDA7CiAgYm9yZGVyLXRvcDogNXB4IHNvbGlkIHRyYW5zcGFyZW50OwogIGJvcmRlci1sZWZ0OiA1cHggc29saWQgYmxhY2s7CiAgYm9yZGVyLWJvdHRvbTogNXB4IHNvbGlkIHRyYW5zcGFyZW50OwogIHBhZGRpbmctdG9wOiAycHg7Cn0KLmlzZXQtY29udGV4dCB7CiAgdGV4dC1hbGlnbjogbGVmdDsKICBwYWRkaW5nLWxlZnQ6IDE1cHg7CiAgZm9udC1zaXplOiAxMnB4Owp9Ci5zZXQtY29udGV4dCB7CiAgdGV4dC1hbGlnbjogbGVmdDsKICBwYWRkaW5nLWxlZnQ6IDE1cHg7CiAgZm9udC1zaXplOiAxMnB4Owp9CmhyIHsKICBtYXJnaW46IDBweDsKfQp1bCB7CiAgbGlzdC1zdHlsZS10eXBlOiBub25lOwogIG1hcmdpbi1ibG9jay1zdGFydDogMGVtOwogIG1hcmdpbi1ibG9jay1lbmQ6IDBlbTsKICBtYXJnaW4taW5saW5lLXN0YXJ0OiAwcHg7CiAgbWFyZ2luLWlubGluZS1lbmQ6IDBweDsKICBwYWRkaW5nLWlubGluZS1zdGFydDogMHB4OwogIG1hcmdpbi10b3A6IDBweDsKICBtYXJnaW4tYm90dG9tOiAwcHg7Cn0KCi8qIHRlc3Rpbmcgc3VibWVudSAqLwoKLnRvcC1sZXZlbC1tZW51IHsKICBsaXN0LXN0eWxlOiBub25lOwogIHBhZGRpbmc6IDA7CiAgbWFyZ2luOiAwOwp9CgoudG9wLWxldmVsLW1lbnUgPiBsaSB7CiAgcG9zaXRpb246IGFic29sdXRlOwogIGZsb2F0OiBsZWZ0OwogIGhlaWdodDogMzBweDsKICB3aWR0aDogMTQzcHg7Cn0KCi50b3AtbGV2ZWwtbWVudSBsaTpob3ZlciA+IHVsIHsKICAvKiBPbiBob3ZlciwgZGlzcGxheSB0aGUgbmV4dCBsZXZlbCdzIG1lbnUgKi8KICBkaXNwbGF5OiBpbmxpbmU7Cn0KCi8qIE1lbnUgTGluayBTdHlsZXMgKi8KCi50b3AtbGV2ZWwtbWVudSBhIC8qIEFwcGx5IHRvIGFsbCBsaW5rcyBpbnNpZGUgdGhlIG11bHRpLWxldmVsIG1lbnUgKi8gewogIGZvbnQtc2l6ZTogMTJweDsKICBjb2xvcjogYmxhY2s7CiAgdGV4dC1kZWNvcmF0aW9uOiBub25lOwogIHBhZGRpbmc6IDAgMCAwIDEwcHg7CiAgcGFkZGluZy1sZWZ0OiAxNXB4OwoKICAvKiBNYWtlIHRoZSBsaW5rIGNvdmVyIHRoZSBlbnRpcmUgbGlzdCBpdGVtLWNvbnRhaW5lciAqLwogIGRpc3BsYXk6IGJsb2NrOwp9Ci50b3AtbGV2ZWwtbWVudSBhOmhvdmVyIHsKICBjb2xvcjogYmxhY2s7Cn0KLnRoaXJkLWxldmVsLW1lbnUgewogIHBvc2l0aW9uOiBhYnNvbHV0ZTsKICB0b3A6IDA7CiAgcmlnaHQ6IC0xMDBweDsKICB3aWR0aDogMTEwcHg7CiAgbGlzdC1zdHlsZTogbm9uZTsKICBwYWRkaW5nOiAwOwogIG1hcmdpbjogMDsKICBkaXNwbGF5OiBub25lOwogIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrOwogIGJhY2tncm91bmQtY29sb3I6IHdoaXRlOwp9CgoudGhpcmQtbGV2ZWwtbWVudSA+IGxpIHsKICBoZWlnaHQ6IDIwcHg7CiAgcGFkZGluZy10b3A6IDVweDsKICAvKiBtYXJnaW46IDFweDsgKi8KfQoudGhpcmQtbGV2ZWwtbWVudSA+IGxpOmhvdmVyIHsKICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMTU1LCAyMTUsIDI1NSk7CiAgYm9yZGVyOiAwLjJweCBzb2xpZCByZ2IoMCwgMTUzLCAyNTUpOwp9Ci50b3AtbGV2ZWwtbWVudTEgewogIGxpc3Qtc3R5bGU6IG5vbmU7CiAgcGFkZGluZzogMDsKICBtYXJnaW46IDA7Cn0KCi50b3AtbGV2ZWwtbWVudTEgPiBsaSB7CiAgcG9zaXRpb246IGFic29sdXRlOwogIGZsb2F0OiBsZWZ0OwogIGhlaWdodDogMzBweDsKICB3aWR0aDogMTQzcHg7Cn0KCi50b3AtbGV2ZWwtbWVudTEgbGk6aG92ZXIgPiB1bCB7CiAgLyogT24gaG92ZXIsIGRpc3BsYXkgdGhlIG5leHQgbGV2ZWwncyBtZW51ICovCiAgZGlzcGxheTogaW5saW5lOwp9CgovKiBNZW51IExpbmsgU3R5bGVzICovCgoudG9wLWxldmVsLW1lbnUxIGEgLyogQXBwbHkgdG8gYWxsIGxpbmtzIGluc2lkZSB0aGUgbXVsdGktbGV2ZWwgbWVudSAqLyB7CiAgZm9udC1zaXplOiAxMnB4OwogIGNvbG9yOiBibGFjazsKICB0ZXh0LWRlY29yYXRpb246IG5vbmU7CiAgcGFkZGluZzogMCAwIDAgMTBweDsKICBwYWRkaW5nLWxlZnQ6IDE1cHg7CgogIC8qIE1ha2UgdGhlIGxpbmsgY292ZXIgdGhlIGVudGlyZSBsaXN0IGl0ZW0tY29udGFpbmVyICovCiAgZGlzcGxheTogYmxvY2s7Cn0KLnRvcC1sZXZlbC1tZW51MSBhOmhvdmVyIHsKICBjb2xvcjogYmxhY2s7Cn0KLnRoaXJkIHsKICBwYWRkaW5nLWxlZnQ6IDVweDsKfQoudGhpcmQgPiBhIHsKICBwYWRkaW5nLWxlZnQ6IDEwcHg7Cn0KLmljb25zIHsKICBtYXJnaW4tbGVmdDogM3B4Owp9Cg=="},{"version":3,"sources":["index.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkwCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.vue","sourceRoot":"src/FormDesigner/components/atoms/FDContextMenu","sourcesContent":["<template>\n  <div>\n    <div class=\"outercontext-div\">\n      <div class=\"wrapper-context\" v-for=\"(value, i) in values\" :key=\"i\">\n        <button\n          class=\"wrapper1-context\"\n          v-if=\"value.values.length === 0\"\n          :style=\"{\n            border: value.text === 'none' ? '0.3px solid white' : '',\n            background: value.text === 'none' ? 'white' : '',\n            height: value.text === 'none' ? '4px' : '',\n            'padding-top': value.text === 'none' ? '0px' : '',\n            outline: value.text === 'none' ? 'none' : '',\n          }\"\n          @mousedown.stop=\"value.disabled === false ? controlAction(value.id) : controlDisable($event)\"\n        >\n          <div>\n            <FDSVGImage v-if=\"value.icon\" :name=\"value.icon\" />\n          </div>\n          <span v-if=\"value.text === 'none'\">\n            <hr />\n          </span>\n          <span\n            v-else\n            class=\"set-context\"\n            v-html=\"value.text\"\n            :style=\"{ opacity: value.disabled ? 0.5 : 1 }\"\n            >{{ value.text }}\n          </span>\n        </button>\n        <button class=\"wrapper1-context wrapper21\" v-else>\n          <div></div>\n          <ul class=\"set-context top-level-menu\">\n            <li>\n              <a href=\"#\" v-html=\"value.text\"  @mousedown.prevent.stop>{{ value.text }}</a>\n              <ul class=\"third-level-menu\">\n                <li\n                  class=\"wrapper1-context\"\n                  v-for=\"(subVal, i) in value.values\"\n                  :key=\"i\"\n                  :style=\"{\n                    border: subVal.text === 'none' ? '0.3px solid white' : '',\n                    background: subVal.text === 'none' ? 'white' : '',\n                    height: subVal.text === 'none' ? '4px' : '',\n                    'padding-top': subVal.text === 'none' ? '0px' : '',\n                    outline: subVal.text === 'none' ? 'none' : '',\n                  }\"\n                  @mousedown.stop=\"subVal.disabled === false ? controlAction(value.id, subVal.id): controlDisable($event)\"\n                >\n                  <div>\n                    <FDSVGImage v-if=\"subVal.icon\" :name=\"subVal.icon\" />\n                  </div>\n                  <a v-if=\"subVal.text === 'none'\">\n                    <hr />\n                  </a>\n                  <a\n                    v-else\n                    href=\"#\"\n                    v-html=\"subVal.text\"\n                    :style=\"{ opacity: subVal.disabled ? 0.5 : 1 }\"\n                    >{{ subVal.text }}</a\n                  >\n                </li>\n              </ul>\n            </li>\n          </ul>\n          <div class=\"triangle-right\"></div>\n        </button>\n      </div>\n    </div>\n    <div></div>\n    <div></div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { Component, Vue, Prop, Emit } from 'vue-property-decorator'\nimport FDSVGImage from '@/FormDesigner/components/atoms/FDSVGImage/index.vue'\nimport { ControlPropertyData } from '@/FormDesigner/models/ControlsTableProperties/ControlPropertyData.ts'\n\nimport { Action, State } from 'vuex-class'\nimport {\n  IaddChildControls,\n  IaddControl,\n  IdeleteControl,\n  IselectControl,\n  IsetChildControls,\n  IupdateControl,\n  IupdateControlExtraData,\n  IupdateCopyControlList,\n  IupdateGroup\n} from '@/storeModules/fd/actions'\nimport { EventBus } from '@/FormDesigner/event-bus'\nimport FDCommonMethod from '@/api/abstract/FormDesigner/FDCommonMethod'\n\n@Component({\n  name: 'ContextMenu',\n  components: {\n    FDSVGImage\n  }\n})\nexport default class ContextMenu extends FDCommonMethod {\n  @Prop() values: Array<IControlContextMenu>;\n  @Prop() userFormId: string;\n  @Prop() containerId: string;\n  @Prop() keyEventName: string;\n  @Prop() controlId: string;\n  @Prop() selectedTab: number;\n  @Prop() data: controlData;\n  @Prop() groupStyleArray: Array<IGroupStyle>\n\n  @State((state) => state.fd.selectedControls)\n  selectedControls!: fdState['selectedControls'];\n  @State((state: rootState) => state.fd.copyControlList)\n  copyControlList!: fdState['copyControlList'];\n  @State((state) => state.fd.userformData) userformData!: userformData;\n  @State((state) => state.fd.copiedControl) copiedControl!: userformData;\n  @State((state) => state.fd.groupedControls)\n  groupedControls!: fdState['groupedControls'];\n\n  @Action('fd/deleteControl') deleteControl!: (payload: IdeleteControl) => void;\n  @Action('fd/deleteCopiedControl') deleteCopiedControl!: (payload: IdeleteControl) => void;\n  @Action('fd/updateCopyControlList') updateCopyControlList!: (\n    payload: IupdateCopyControlList\n  ) => void;\n  @Action('fd/addControl') addControl!: (payload: IaddControl) => void;\n  @Action('fd/addCopiedControl') addCopiedControl!: (\n    payload: IaddControl\n  ) => void;\n  @Action('fd/selectControl') selectControl!: (payload: IselectControl) => void;\n  @Action('fd/updateGroup') updateGroup!: (payload: IupdateGroup) => void;\n  @Action('fd/updateControlExtraData') updateControlExtraData!: (\n    payload: IupdateControlExtraData\n  ) => void;\n  @Action('fd/updateControl') updateControl!: (payload: IupdateControl) => void;\n  @Action('fd/setChildControls') setChildControls!: (\n    payload: IsetChildControls\n  ) => void;\n  @Action('fd/addChildControls') addChildControls!: (\n    payload: IaddChildControls\n  ) => void;\n  controlAction (controlActionName: string, subVal: string) {\n    if (controlActionName === 'ID_COPY') {\n      this.copyControl('copy')\n    } else if (controlActionName === 'ID_DELETE') {\n      this.clickDelete()\n    } else if (controlActionName === 'ID_PASTE') {\n      this.pasteControl()\n    } else if (controlActionName === 'ID_CUT') {\n      this.cutControl()\n    } else if (controlActionName === 'ID_SELECTALL') {\n      this.selectAll()\n    } else if (controlActionName === 'ID_GROUP') {\n      this.groupControl()\n    } else if (controlActionName === 'ID_UNGROUP') {\n      this.unGroupControl()\n    } else if (controlActionName === 'ID_NEWPAGE') {\n      this.addNewPage()\n    } else if (controlActionName === 'ID_DELETEPAGE') {\n      this.deleteCurrentPage()\n    } else if (controlActionName === 'ID_CONTROLFORWARD') {\n      this.bringForward()\n    } else if (controlActionName === 'ID_CONTROLBACKWARD') {\n      this.bringBackward()\n    } else if (controlActionName === 'ID_OBJECTPROP') {\n      this.displayProp()\n    } else if (controlActionName === 'ID_RENAME') {\n      const selectedPageID = this.selectedControls[this.userFormId].selected[0]\n      EventBus.$emit(\n        'renamePage',\n        this.userFormId,\n        selectedPageID,\n        this.selectedTab,\n        this.userformData[this.userFormId][selectedPageID].type\n      )\n    } else if (controlActionName === 'ID_MOVE') {\n      const type = this.userformData[this.userFormId][this.controlId].type\n      if (type === 'MultiPage') {\n        EventBus.$emit('userFormTabOrder', this.userFormId, this.controlId, type)\n      } else {\n        EventBus.$emit('tabStripTabOrder', this.userFormId, this.controlId, type)\n      }\n    } else if (controlActionName === 'ID_TABORDER') {\n      EventBus.$emit('userFormTabOrder', this.userFormId, this.containerId, '')\n    } else if (\n      controlActionName === 'ID_ALIGN' ||\n      controlActionName === 'ID_MAKESAMESIZE'\n    ) {\n      this.controlAlignMent(subVal)\n    }\n    this.closeMenu()\n  }\n  created () {\n    EventBus.$on('groupControl', (value: string) => {\n      if (this.selectedControls[this.userFormId].container[0] === this.containerId) {\n        if (value === 'group') {\n          this.groupControl()\n        } else if (value === 'ungroup') {\n          this.unGroupControl()\n        }\n      }\n    })\n  }\n  destroyed () {\n    EventBus.$off('groupControl')\n  }\n  @Emit('closeMenu')\n  closeMenu () {\n    return 0\n  }\n\n  displayProp () {\n    EventBus.$emit('dispProp', false)\n  }\n\n  addNewPage () {\n    const type = this.userformData[this.userFormId][this.controlId].type\n    if (type === 'TabStrip') {\n      const tabControlData = JSON.parse(\n        JSON.stringify(this.userformData[this.userFormId][this.controlId])\n      ).extraDatas.Tabs\n      let prevTabId = -1\n      const initialTabData: tabsItems = {\n        Name: '',\n        Caption: '',\n        ToolTip: '',\n        Accelerator: ''\n      }\n      if (tabControlData.length > 0) {\n        for (let i = 0; i < tabControlData.length; i++) {\n          const id = tabControlData[i].Name.split('Tab').pop() || '-1'\n          const parseId = parseInt(id, 10)\n          if (!isNaN(parseId) && prevTabId < parseId) {\n            prevTabId = parseId\n          }\n        }\n        prevTabId += 1\n        initialTabData.Name = `Tab${prevTabId}`\n        initialTabData.Caption = `Tab${prevTabId}`\n      } else {\n        initialTabData.Name = `Tab${1}`\n        initialTabData.Caption = `Tab${1}`\n      }\n      tabControlData.push(initialTabData)\n      this.updateControlExtraData({\n        userFormId: this.userFormId,\n        controlId: this.controlId,\n        propertyName: 'Tabs',\n        value: tabControlData\n      })\n      this.updateControl({\n        userFormId: this.userFormId,\n        controlId: this.controlId,\n        propertyName: 'Value',\n        value: prevTabId - 1\n      })\n    } else if (type === 'MultiPage') {\n      const parentId = this.controlId.split('MultiPage').pop()\n      const controlName = `Page${parentId}_`\n\n      let lastControlId = 0\n      const userformControlIds = Object.keys(this.userformData[this.userFormId])\n      for (let i = 0; i < userformControlIds.length; i++) {\n        if (userformControlIds[i].indexOf(controlName) !== -1) {\n          const IdNum =\n          userformControlIds[i].split(controlName).pop() || '-1'\n          const pasreId = parseInt(IdNum, 10)\n          if (!isNaN(pasreId) && lastControlId < pasreId) {\n            lastControlId = pasreId\n          }\n        }\n      }\n      const controlPropData = new ControlPropertyData()\n      let controlObj = controlPropData.data['Page']\n      const item = JSON.parse(JSON.stringify(controlObj!))\n      lastControlId += 1\n      item.properties.ID = `ID_${controlName}${lastControlId}`\n      item.properties.Caption = `Page${lastControlId}`\n      item.properties.Name = `Page${lastControlId}`\n      item.properties.Index = this.userformData[this.userFormId][this.controlId].controls.length\n      this.addControl({\n        userFormId: this.userFormId,\n        controlId: this.controlId,\n        addId: item.properties.ID,\n        item: item\n      })\n      this.updateControl({\n        userFormId: this.userFormId,\n        controlId: this.controlId,\n        propertyName: 'Value',\n        value: item.properties.Index\n      })\n      this.selectControl({\n        userFormId: this.userFormId,\n        select: {\n          container: this.getContainerList(item.properties.ID),\n          selected: [item.properties.ID]\n        }\n      })\n      EventBus.$emit('updateMultiPageValue')\n    }\n  }\n  bringForward () {\n    const userData = this.userformData[this.userFormId]\n    const highProrControl = []\n    const lowProrControl = []\n    const container = this.getContainerList(this.getSelectedControlsDatas![0])[0]\n    const containerControls = this.userformData[this.userFormId][container].controls\n    for (const index in containerControls) {\n      const cntrlData = this.userformData[this.userFormId][containerControls[index]]\n      if (cntrlData.type === 'MultiPage' || cntrlData.type === 'Frame' || cntrlData.type === 'ListBox') {\n        highProrControl.push(containerControls[index])\n      } else {\n        lowProrControl.push(containerControls[index])\n      }\n    }\n    let nextSelctedSeries: string[] = []\n    let nextHighControlSeries: string[] = []\n    const getSelControl = [...this.getSelectedControlsDatas!]\n    getSelControl.sort((a, b) => {\n      return userData[a].extraDatas!.zIndex! - userData[b].extraDatas!.zIndex!\n    })\n    for (const selControl of getSelControl!) {\n      const type = userData[selControl].type\n      const tempZIndex = userData[selControl].extraDatas!.zIndex!\n      const controlIndex = Object.keys(userData).findIndex((val: string, index: number) => {\n        return 'zIndex' in userData[val].extraDatas! && (userData[val].extraDatas!.zIndex === tempZIndex + 1)\n      })\n      const nextSelectedControl = controlIndex !== -1 ? Object.keys(userData)[controlIndex] : ''\n      const nextControlType = userData[nextSelectedControl].type\n      if (nextSelectedControl !== '' && !highProrControl.includes(nextSelectedControl)) {\n        if (getSelControl!.includes(nextSelectedControl)) {\n          if (!nextSelctedSeries.includes(selControl)) {\n            nextSelctedSeries.push(selControl)\n          }\n          if (!nextSelctedSeries.includes(nextSelectedControl)) {\n            nextSelctedSeries.push(nextSelectedControl)\n          }\n        } else {\n          if (Object.keys(nextSelctedSeries).length !== 0) {\n            const tempExchageIndex = userData[nextSelctedSeries[0]].extraDatas!.zIndex!\n            const swapTabIndex = userData[nextSelectedControl].extraDatas!.zIndex!\n            if (swapTabIndex <= userData[container].controls.length /* && swapTabIndex > 0 */) {\n              const index = userData[container].controls.findIndex(\n                (val) => userData[val].extraDatas!.zIndex === swapTabIndex\n              )\n              this.updateExtraDatas(userData[container].controls[index], 'zIndex', tempExchageIndex)\n              this.updateExtraDatas(nextSelctedSeries[0], 'zIndex', swapTabIndex - (nextSelctedSeries!.length - 1))\n            }\n            for (let j = 1; j < nextSelctedSeries.length; j++) {\n              const updateIndex = userData[nextSelctedSeries[j]].extraDatas!.zIndex! + 1\n              this.updateExtraDatas(nextSelctedSeries[j], 'zIndex', updateIndex)\n            }\n            nextSelctedSeries = []\n          } else {\n            const swapTabIndex = userData[nextSelectedControl].extraDatas!.zIndex!\n            if (swapTabIndex <= userData[container].controls.length /* && swapTabIndex > 0 */) {\n              const index = userData[container].controls.findIndex(\n                (val) => userData[val].extraDatas!.zIndex === swapTabIndex\n              )\n              this.updateExtraDatas(selControl, 'zIndex', swapTabIndex)\n              this.updateExtraDatas(nextSelectedControl, 'zIndex', tempZIndex)\n            }\n          }\n        }\n      } else {\n        if (getSelControl!.includes(nextSelectedControl) && (type === 'Frame' || type === 'MultiPage' || type === 'ListBox')) {\n          if (!nextHighControlSeries.includes(selControl)) {\n            nextHighControlSeries.push(selControl)\n          }\n          if (!nextHighControlSeries.includes(nextSelectedControl)) {\n            nextHighControlSeries.push(nextSelectedControl)\n          }\n        } else if (type === 'Frame' || type === 'MultiPage' || type === 'ListBox') {\n          if (Object.keys(nextHighControlSeries).length !== 0) {\n            const tempExchageIndex = userData[nextHighControlSeries[0]].extraDatas!.zIndex!\n            const swapTabIndex = userData[nextSelectedControl].extraDatas!.zIndex!\n            if (swapTabIndex <= userData[container].controls.length) {\n              const index = userData[container].controls.findIndex(\n                (val) => userData[val].extraDatas!.zIndex === swapTabIndex\n              )\n              this.updateExtraDatas(userData[container].controls[index], 'zIndex', tempExchageIndex)\n              this.updateExtraDatas(nextHighControlSeries[0], 'zIndex', swapTabIndex - (nextHighControlSeries!.length - 1))\n            }\n            for (let j = 1; j < nextHighControlSeries.length; j++) {\n              const updateIndex = userData[nextHighControlSeries[j]].extraDatas!.zIndex! + 1\n              this.updateExtraDatas(nextHighControlSeries[j], 'zIndex', updateIndex)\n            }\n            nextHighControlSeries = []\n          } else {\n            const swapTabIndex = userData[nextSelectedControl].extraDatas!.zIndex!\n            if (swapTabIndex <= userData[container].controls.length /* && swapTabIndex > 0 */) {\n              const index = userData[container].controls.findIndex(\n                (val) => userData[val].extraDatas!.zIndex === swapTabIndex\n              )\n              this.updateExtraDatas(selControl, 'zIndex', swapTabIndex)\n              this.updateExtraDatas(nextSelectedControl, 'zIndex', tempZIndex)\n            }\n          }\n        }\n      }\n    }\n  }\n  bringBackward () {\n    const userData = this.userformData[this.userFormId]\n    const highProrControl = []\n    const lowProrControl = []\n    const container = this.getContainerList(this.getSelectedControlsDatas![0])[0]\n    const containerControls = this.userformData[this.userFormId][container].controls\n    for (const index in containerControls) {\n      const cntrlData = this.userformData[this.userFormId][containerControls[index]]\n      if (cntrlData.type === 'MultiPage' || cntrlData.type === 'Frame' || cntrlData.type === 'ListBox') {\n        highProrControl.push(containerControls[index])\n      } else {\n        lowProrControl.push(containerControls[index])\n      }\n    }\n    let nextSelctedSeries: string[] = []\n    let nextHighControlSeries: string[] = []\n    const getSelControl = [...this.getSelectedControlsDatas!]\n    getSelControl.sort((a, b) => {\n      return userData[a].extraDatas!.zIndex! - userData[b].extraDatas!.zIndex!\n    })\n    for (const selControl of getSelControl) {\n      const type = userData[selControl].type\n      const tempZIndex = userData[selControl].extraDatas!.zIndex!\n      const controlIndex = Object.keys(userData).findIndex((val: string, index: number) => {\n        return 'zIndex' in userData[val].extraDatas! && (userData[val].extraDatas!.zIndex === tempZIndex - 1)\n      })\n      const nextSelectedControl = controlIndex !== -1 ? Object.keys(userData)[controlIndex] : ''\n      const nextControlType = userData[nextSelectedControl].type\n      if (nextSelectedControl !== '' && !highProrControl.includes(selControl)) {\n        if (getSelControl!.includes(nextSelectedControl)) {\n          if (!nextSelctedSeries.includes(selControl)) {\n            nextSelctedSeries.push(selControl)\n          }\n          if (!nextSelctedSeries.includes(nextSelectedControl)) {\n            nextSelctedSeries.push(nextSelectedControl)\n          }\n        } else {\n          if (Object.keys(nextSelctedSeries).length !== 0) {\n            console.log('nextSelctedSeries', nextSelctedSeries)\n            const tempExchageIndex = userData[nextSelctedSeries[0]].extraDatas!.zIndex!\n            const swapTabIndex = userData[nextSelectedControl].extraDatas!.zIndex!\n            if (swapTabIndex <= userData[container].controls.length && swapTabIndex > 0) {\n              const index = userData[container].controls.findIndex(\n                (val) => userData[val].extraDatas!.zIndex === swapTabIndex\n              )\n              this.updateExtraDatas(userData[container].controls[index], 'zIndex', tempExchageIndex)\n              this.updateExtraDatas(nextSelctedSeries[0], 'zIndex', (nextSelctedSeries!.length + 1) - swapTabIndex)\n            }\n            for (let j = 1; j < nextSelctedSeries.length; j++) {\n              const updateIndex = userData[nextSelctedSeries[j]].extraDatas!.zIndex! - 1\n              this.updateExtraDatas(nextSelctedSeries[j], 'zIndex', updateIndex)\n            }\n            nextSelctedSeries = []\n          } else {\n            const swapTabIndex = userData[nextSelectedControl].extraDatas!.zIndex!\n            if (swapTabIndex <= userData[container].controls.length && swapTabIndex > 0) {\n              const index = userData[container].controls.findIndex(\n                (val) => userData[val].extraDatas!.zIndex === swapTabIndex\n              )\n              this.updateExtraDatas(selControl, 'zIndex', swapTabIndex)\n              this.updateExtraDatas(nextSelectedControl, 'zIndex', tempZIndex)\n            }\n          }\n        }\n      } else if (!lowProrControl.includes(nextSelectedControl) && (type === 'Frame' || type === 'MultiPage' || type === 'ListBox')) {\n        if (getSelControl!.includes(nextSelectedControl)) {\n          if (!nextHighControlSeries.includes(selControl)) {\n            nextHighControlSeries.push(selControl)\n          }\n          if (!nextHighControlSeries.includes(nextSelectedControl)) {\n            nextHighControlSeries.push(nextSelectedControl)\n          }\n        } else {\n          if (Object.keys(nextHighControlSeries).length !== 0) {\n            const tempExchageIndex = userData[nextHighControlSeries[0]].extraDatas!.zIndex!\n            const swapTabIndex = userData[nextSelectedControl].extraDatas!.zIndex!\n            if (swapTabIndex <= userData[container].controls.length) {\n              const index = userData[container].controls.findIndex(\n                (val) => userData[val].extraDatas!.zIndex === swapTabIndex\n              )\n              this.updateExtraDatas(userData[container].controls[index], 'zIndex', tempExchageIndex)\n              this.updateExtraDatas(nextHighControlSeries[0], 'zIndex', (nextHighControlSeries!.length + 1) - swapTabIndex)\n            }\n            for (let j = 1; j < nextHighControlSeries.length; j++) {\n              const updateIndex = userData[nextHighControlSeries[j]].extraDatas!.zIndex! - 1\n              this.updateExtraDatas(nextHighControlSeries[j], 'zIndex', updateIndex)\n            }\n            nextHighControlSeries = []\n          } else {\n            const swapTabIndex = userData[nextSelectedControl].extraDatas!.zIndex!\n            if (swapTabIndex <= userData[container].controls.length && swapTabIndex > 0) {\n              const index = userData[container].controls.findIndex(\n                (val) => userData[val].extraDatas!.zIndex === swapTabIndex\n              )\n              this.updateExtraDatas(selControl, 'zIndex', swapTabIndex)\n              this.updateExtraDatas(nextSelectedControl, 'zIndex', tempZIndex)\n            }\n          }\n        }\n      }\n    }\n  }\n  deletePageIndex (id: string) {\n    const userData = this.userformData[this.userFormId]\n    const container = this.selectedControls[this.userFormId].container[0]\n    const tempIndex = userData[id].properties!.Index!\n    for (const key in userData[container].controls) {\n      const controlZIndex = userData[userData[container].controls[key]].properties!.Index!\n      if (controlZIndex > tempIndex) {\n        this.updateControl({\n          userFormId: this.userFormId,\n          controlId: userData[container].controls[key],\n          propertyName: 'Index',\n          value: controlZIndex - 1\n        })\n      }\n    }\n  }\n  deleteCurrentPage () {\n    const type = this.userformData[this.userFormId][this.controlId].type\n    if (type === 'TabStrip') {\n      const tabControlData = JSON.parse(\n        JSON.stringify(this.userformData[this.userFormId][this.controlId])\n      ).extraDatas.Tabs\n      if (tabControlData && tabControlData.length > 0) {\n        tabControlData.splice(this.selectedTab, 1)\n        this.updateControlExtraData({\n          userFormId: this.userFormId,\n          controlId: this.controlId,\n          propertyName: 'Tabs',\n          value: tabControlData\n        })\n        this.updateTabStripValue(this.selectedTab! - 1)\n      }\n    } else if (type === 'MultiPage') {\n      const controls = this.userformData[this.userFormId][this.controlId].controls\n      if (controls.length > 0) {\n        this.deletePageIndex(this.selectedControls[this.userFormId].selected[0])\n        const index = this.userformData[this.userFormId][this.selectedControls[this.userFormId].selected[0]].properties.Index\n        this.deleteControl({\n          userFormId: this.userFormId,\n          parentId: this.selectedControls[this.userFormId].container[0],\n          targetId: this.selectedControls[this.userFormId].selected[0]\n        })\n        this.updateIndex(index! - 1)\n      }\n      EventBus.$emit('updateMultiPageValue')\n    }\n  }\n  updateTabStripValue (index: number) {\n    const userData = this.userformData[this.userFormId]\n    const tabs = userData[this.controlId].extraDatas!.Tabs!\n    const tabIndex = tabs.findIndex((val, key) => key === index + 1)\n    if (tabIndex !== -1) {\n      const value = index + 1\n      this.updateControlProperty('Value', value, this.controlId)\n    } else if (tabIndex === -1 && index !== -1) {\n      const value = index\n      this.updateControlProperty('Value', value, this.controlId)\n    } else {\n      this.updateControlProperty('Value', -1, this.controlId)\n    }\n  }\n  changeSelect (control: string) {\n    this.selectControl({\n      userFormId: this.userFormId,\n      select: {\n        container: this.getContainerList(control),\n        selected: [control]\n      }\n    })\n  }\n  updateIndex (index: number) {\n    const userData = this.userformData[this.userFormId]\n    const controls = userData[this.controlId].controls\n    const pageIndex = controls.findIndex(val => userData[val].properties.Index === index + 1)\n    if (pageIndex !== -1) {\n      const value = userData[controls[pageIndex]].properties.Index!\n      this.updateControlProperty('Value', value, this.controlId)\n      this.changeSelect(controls[pageIndex])\n    } else if (pageIndex === -1 && index !== -1) {\n      const updateIndex = controls.findIndex(val => userData[val].properties.Index === index)\n      const value = userData[controls[updateIndex]].properties.Index!\n      this.updateControlProperty('Value', value, this.controlId)\n      this.changeSelect(controls[updateIndex])\n    } else {\n      this.updateControlProperty('Value', -1, this.controlId)\n      this.changeSelect(this.controlId)\n    }\n  }\n  updateControlProperty (\n    propertyName: keyof controlProperties,\n    propertyValue: number | string,\n    controlId: string\n  ) {\n    this.updateControl({\n      userFormId: this.userFormId,\n      controlId: controlId,\n      propertyName: propertyName,\n      value: propertyValue\n    })\n  }\n\n  unGroupControl () {\n    const isGroup = this.selectedControls[this.userFormId].selected[0].startsWith('group')\n    const selControl = this.selectedControls[this.userFormId].selected[0]\n    const selected = isGroup\n      ? selControl\n      : this.userformData[this.userFormId][selControl].properties.GroupID!\n\n    const controlList = []\n    for (const key in this.userformData[this.userFormId]) {\n      const type = this.userformData[this.userFormId][key].type\n      if (\n        type !== 'Userform' &&\n        this.userformData[this.userFormId][key].properties.GroupID === selected\n      ) {\n        controlList.push(key)\n      }\n    }\n    const groupArray = [...this.groupedControls[this.userFormId]!.groupArray!]\n    this.updateControlGroupID(selected, '')\n    const index = this.groupedControls[this.userFormId]!.groupArray!.findIndex(\n      (val) => val === selected\n    )\n    groupArray.splice(index, 1)\n    this.updateGroup({ userFormId: this.userFormId, groupArray: groupArray })\n    this.selectControl({\n      userFormId: this.userFormId,\n      select: {\n        container: isGroup\n          ? this.getContainerList(controlList[0])\n          : this.getContainerList(selControl[0]),\n        selected: isGroup ? controlList : [selControl]\n      }\n    })\n  }\n\n  /**\n   * @description To generate new GroupID\n   * @function createGroupId\n   */\n  createGroupId () {\n    let lastControlId = 0\n    for (let i of this.groupedControls[this.userFormId]!.groupArray!) {\n      if (i.indexOf('group') !== -1) {\n        const IdNum = i.split('group').pop() || '-1'\n        const pasreId = parseInt(IdNum, 10)\n        if (!isNaN(pasreId) && lastControlId < pasreId) {\n          lastControlId = pasreId\n        }\n      }\n    }\n    return `group${lastControlId + 1}`\n  }\n\n  @Emit('createGroup')\n  createGroup (groupId: string) {\n    return groupId\n  }\n\n  updateControlGroupID (groupName: string, updateGroupId: string) {\n    for (const val in this.userformData[this.userFormId]) {\n      if (!val.startsWith('ID_USERFORM')) {\n        const controlGrpId = this.userformData[this.userFormId][val].properties\n          .GroupID\n        if (controlGrpId === groupName) {\n          this.updateControlProperty('GroupID', updateGroupId, val)\n        }\n      }\n    }\n  }\n  /**\n   * @description To update the group Information in main data\n   * @function groupControl\n   */\n  groupControl () {\n    let updateGroupId: string = ''\n    const selected = this.selectedControls[this.userFormId].selected\n\n    const selectedGroupArray = selected.filter(\n      (val: string) => val.startsWith('group') && val\n    )\n    updateGroupId = selectedGroupArray[0]\n    if (selectedGroupArray.length >= 2) {\n      const groupArray = [\n        ...this.groupedControls[this.userFormId]!.groupArray!\n      ]\n      for (let i = 0; i < groupArray.length; i++) {\n        for (let j = 0; j < selectedGroupArray.length; j++) {\n          if (selectedGroupArray[j] === groupArray[i]) {\n            this.updateControlGroupID(groupArray[i], selectedGroupArray[0])\n            groupArray.splice(i, 1)\n          }\n        }\n      }\n      this.updateGroup({\n        userFormId: this.userFormId,\n        groupArray: [...groupArray, selectedGroupArray[0]]\n      })\n      updateGroupId = selectedGroupArray[0]!\n    } else if (selectedGroupArray.length === 0) {\n      updateGroupId = this.createGroupId()\n      const groupArray = [\n        ...this.groupedControls[this.userFormId]!.groupArray!,\n        updateGroupId\n      ]\n      this.updateGroup({ userFormId: this.userFormId, groupArray: groupArray })\n    }\n\n    for (let val of selected) {\n      if (!val.startsWith('group')) {\n        this.updateControlProperty('GroupID', updateGroupId, val)\n      }\n    }\n    this.createGroup(updateGroupId)\n    this.selectControl({\n      userFormId: this.userFormId,\n      select: {\n        container: this.getContainerList(updateGroupId),\n        selected: [updateGroupId]\n      }\n    })\n  }\n\n  /**\n   * @description To select all the controls in respective container present in respective userform\n   * @function selectAll\n   */\n  selectAll () {\n    const controlObjectList = [\n      ...this.userformData[this.userFormId][this.containerId].controls\n    ]\n    const selecedGroup: string[] = []\n    for (const val of controlObjectList) {\n      const controlGroupId: string = this.userformData[this.userFormId][val]\n        .properties.GroupID!\n      if (controlGroupId && controlGroupId !== '') {\n        !selecedGroup.includes(controlGroupId)! &&\n          selecedGroup.push(controlGroupId)\n      } else {\n        selecedGroup.push(val)\n      }\n    }\n\n    if (controlObjectList.length !== 0) {\n      this.selectControl({\n        userFormId: this.userFormId,\n        select: {\n          container: this.getContainerList(selecedGroup[0]),\n          selected: [...selecedGroup]\n        }\n      })\n    }\n  }\n\n  /**\n   * @description To update the cutted controls in respective container present in respective userform\n   * @function cutControl\n   */\n  cutControl () {\n    this.copyControl('cut')\n    this.clickDelete()\n  }\n\n  /**\n   * @description To update the copied controls in respective container present in respective userform\n   * @function copyControl\n   */\n  copyControl (type: string) {\n    for (let i = 0; i < this.copiedControl[this.userFormId][this.userFormId].controls.length; i++) {\n      this.deleteCopiedControl({\n        userFormId: this.userFormId,\n        parentId: this.userFormId,\n        targetId: this.copiedControl[this.userFormId][this.userFormId].controls[i]\n      })\n    }\n    const userFormData = this.userformData[this.userFormId]\n    const selContainer = this.selectedControls[this.userFormId].container[0]\n    const selSelected = this.selectedControls[this.userFormId].selected\n    const updateSelected = []\n    for (let control of selSelected) {\n      if (!control.startsWith('group') && userFormData[control].type === 'Page') {\n        control = this.getContainerList(control)[0]\n      }\n      updateSelected.push(control)\n    }\n    this.updateCopyControlList({\n      userFormId: this.userFormId,\n      parentId: selContainer,\n      targetId: updateSelected,\n      type: type\n    })\n\n    const recCopyControl = (daTarget: string) => {\n      const daTargetControls = userFormData[daTarget].controls\n      if (daTargetControls.length > 0) {\n        for (let i in daTargetControls) {\n          const controlObject = JSON.parse(JSON.stringify(userFormData[daTargetControls[i]]))\n          const controlArray = []\n          const ctrlObj = { ...controlObject, controls: [] }\n          this.addCopiedControl({\n            userFormId: this.userFormId,\n            controlId: daTarget,\n            addId: daTargetControls[i],\n            item: ctrlObj\n          })\n          recCopyControl(daTargetControls[i])\n        }\n      }\n    }\n\n    for (let key of selSelected) {\n      if (!key.startsWith('group')) {\n        if (userFormData[key].type === 'Page') {\n          key = this.getContainerList(key)[0]\n        }\n        const controlObject = JSON.parse(JSON.stringify(userFormData[key]))\n        const ctrlObj = { ...controlObject, controls: [] }\n        this.addCopiedControl({\n          userFormId: this.userFormId,\n          controlId: this.userFormId,\n          addId: key,\n          item: ctrlObj\n        })\n        recCopyControl(key)\n      } else {\n        for (let ctrlId in userFormData) {\n          const controlProp = userFormData[ctrlId].properties.GroupID\n          if (controlProp) {\n            if (controlProp === key) {\n              const controlObject = JSON.parse(\n                JSON.stringify(userFormData[ctrlId])\n              )\n              const ctrlObj = { ...controlObject, controls: [] }\n              this.addCopiedControl({\n                userFormId: this.userFormId,\n                controlId: this.userFormId,\n                addId: ctrlId,\n                item: ctrlObj\n              })\n              recCopyControl(ctrlId)\n            }\n          }\n        }\n      }\n    }\n  }\n  updateNewControl (parentId: string, ctrlId: string, ctrlObj: controlData, isParent: boolean) {\n    this.addControl({\n      userFormId: this.userFormId,\n      controlId: parentId,\n      addId: ctrlId,\n      item: ctrlObj\n    })\n    if (isParent) {\n      const newTabIndex = this.userformData[this.userFormId][parentId].controls.length\n      this.updateTabIndexValue(ctrlId)\n      this.updateZIndexValue(ctrlId)\n    }\n  }\n\n  newPasteControlId (key: string, parentId: string) {\n    const userFormData = this.userformData[this.userFormId]\n    let lastControlId = 0\n    const type = key in userFormData ? userFormData[key].type : ''\n    const parentName = parentId !== '' ? parentId.split('MultiPage').pop() : -1\n    const selectedControlName: string | undefined =\n    type === 'Page'\n      ? `Page${parentName}_`\n      : key.replace(/[0-9]/g, '').split('_').pop()\n    const userformControlIds = Object.keys(userFormData)\n    for (let i = 0; i < userformControlIds.length; i++) {\n      if (userformControlIds[i].indexOf(selectedControlName!) !== -1) {\n        const IdNum = userformControlIds[i].split(selectedControlName!).pop() || '-1'\n        const pasreId = parseInt(IdNum, 10)\n        if (!isNaN(pasreId) && lastControlId < pasreId) {\n          lastControlId = pasreId\n        }\n      }\n    }\n    lastControlId += 1\n    const Name = `${selectedControlName}${lastControlId}`\n    return Name\n  }\n  removeChildControl (daTarget: string, deleteControl: string) {\n    const removeControl = [...this.userformData[this.userFormId][daTarget].controls]\n    const removeIndex = removeControl.findIndex((val) => val === deleteControl)\n    removeControl.splice(removeIndex, 1)\n    this.setChildControls({\n      userFormId: this.userFormId,\n      containerId: daTarget,\n      targetControls: removeControl\n    })\n  }\n  /**\n   * @description To paste controls in respective container present in respective userform\n   * @function pasteControl\n   */\n  pasteControl () {\n    if (this.copyControlList.type === 'copy') {\n      const selContainer = this.copyControlList.parentId\n      const selSelected = this.copyControlList.targetId\n      const userFormData = this.userformData[this.userFormId]\n      const presentGroupId: string[] = []\n      const newGroupId: string[] = []\n      const oldControlId: string[] = []\n      const newControlId: string[] = []\n\n      for (const key in this.copiedControl[this.userFormId]) {\n        const controlProp = this.copiedControl[this.userFormId][key].properties.GroupID\n        if (controlProp && !presentGroupId.includes(controlProp)) {\n          presentGroupId.push(controlProp)\n        }\n      }\n      for (let j in presentGroupId) {\n        const newId = this.createGroupId()\n        newGroupId.push(newId)\n        let groupArray: string[] = [\n          ...this.groupedControls[this.userFormId]!.groupArray!,\n          newId\n        ]\n        this.updateGroup({\n          userFormId: this.userFormId,\n          groupArray: groupArray!\n        })\n      }\n\n      const recCopyControl = (daTarget: string) => {\n        const daTargetControls = userFormData[daTarget].controls\n        if (daTargetControls.length > 0) {\n          for (let i = 0, limit = daTargetControls.length; i < limit; i++) {\n            const key = daTargetControls[i]\n            const Name = this.newPasteControlId(key, daTarget)\n            const controlID:| string| undefined = `ID_${Name}`\n            const controlObj = { ...this.copiedControl[this.userFormId][key] }\n            let groupIdIndex = -1\n            groupIdIndex = presentGroupId.findIndex((val) => val === controlObj.properties.GroupID)\n            const item: controlData = {\n              ...controlObj,\n              properties: {\n                ...controlObj.properties,\n                ID: controlID!,\n                GroupID: groupIdIndex !== -1 ? newGroupId[groupIdIndex] : '',\n                Name: Name\n              }\n            }\n            this.removeChildControl(daTarget, key)\n            this.updateNewControl(daTarget, controlID, item, false)\n            recCopyControl(controlID)\n          }\n        }\n      }\n\n      for (const key of selSelected) {\n        if (!key.startsWith('group')) {\n          oldControlId.push(key)\n          const Name = this.newPasteControlId(key, '')\n          const controlID:| string| undefined = `ID_${Name}`\n          const controlObj = { ...this.copiedControl[this.userFormId][key] }\n          newControlId.push(controlID)\n          let groupIdIndex = -1\n          groupIdIndex = presentGroupId.findIndex(\n            (val) => controlObj.properties.GroupID === val\n          )\n          if (selSelected.length === 1 && this.copiedControl[this.userFormId][selSelected[0]].properties.GroupID !== '') {\n            groupIdIndex = -1\n          }\n          const item: controlData = {\n            ...controlObj,\n            properties: {\n              ...controlObj.properties,\n              ID: controlID!,\n              Left: controlObj.properties.Left! + 10,\n              Top: controlObj.properties.Top! + 10,\n              GroupID: groupIdIndex !== -1 ? newGroupId[groupIdIndex] : '',\n              Name: Name\n            }\n          }\n          this.updateNewControl(this.containerId, controlID, item, true)\n          recCopyControl(controlID)\n        } else {\n          for (let ctrlId in this.copiedControl[this.userFormId]) {\n            const controlProp = this.copiedControl[this.userFormId][ctrlId]\n              .properties.GroupID\n            if (controlProp) {\n              if (controlProp === key) {\n                const Name = this.newPasteControlId(ctrlId, '')\n                const controlID:| string| undefined = `ID_${Name}`\n                const controlObj = this.copiedControl[this.userFormId][ctrlId]\n\n                let groupIdIndex = -1\n                groupIdIndex = presentGroupId.findIndex(\n                  (val) => controlObj.properties.GroupID === val\n                )\n                const item: controlData = {\n                  ...controlObj,\n                  properties: {\n                    ...controlObj.properties,\n                    ID: controlID!,\n                    Left: controlObj.properties.Left! + 10,\n                    Top: controlObj.properties.Top! + 10,\n                    GroupID: groupIdIndex !== -1 ? newGroupId[groupIdIndex] : '',\n                    Name: Name\n                  }\n                }\n                this.updateNewControl(this.containerId, controlID, item, true)\n                recCopyControl(controlID)\n              }\n            }\n          }\n        }\n      }\n      for (let j of newGroupId) {\n        this.createGroup(j)\n      }\n      const newSelected: string[] = []\n      for (const control of selSelected) {\n        if (control.startsWith('group')) {\n          const index = presentGroupId.findIndex((val) => val === control)\n          newSelected.push(newGroupId[index])\n        } else {\n          const index = oldControlId.findIndex((val) => val === control)\n          newSelected.push(newControlId[index])\n        }\n      }\n      this.selectControl({\n        userFormId: this.userFormId,\n        select: {\n          container: this.getContainerList(newSelected[0]),\n          selected: newSelected\n        }\n      })\n    } else if (this.copyControlList.type === 'cut') {\n      const selContainer = this.copyControlList.parentId\n      const selSelected = this.copyControlList.targetId\n      const userFormData = this.copiedControl[this.userFormId]\n      const recCopyControl = (daTarget: string) => {\n        const daTargetControls = userFormData[daTarget].controls\n        if (daTargetControls.length > 0) {\n          for (let i = 0, limit = daTargetControls.length; i < limit; i++) {\n            const key = daTargetControls[i]\n            const controlObj = JSON.parse(JSON.stringify(this.copiedControl[this.userFormId][key]))\n            const item: controlData = {\n              ...controlObj\n            }\n            this.removeChildControl(daTarget, key)\n            this.updateNewControl(daTarget, key, item, false)\n            recCopyControl(key)\n          }\n        }\n      }\n      for (const key of selSelected) {\n        if (!key.startsWith('group')) {\n          const controlObj = JSON.parse(\n            JSON.stringify(this.copiedControl[this.userFormId][key])\n          )\n          if (selSelected.length === 1 && userFormData[selSelected[0]].properties.GroupID! !== '') {\n            controlObj.properties.GroupID = ''\n          }\n          const item: controlData = {\n            ...controlObj\n          }\n          this.updateNewControl(this.containerId, key, item, true)\n          recCopyControl(key)\n        } else {\n          for (let ctrlId in userFormData) {\n            const controlProp = userFormData[ctrlId].properties.GroupID\n            if (controlProp) {\n              if (controlProp === key) {\n                const controlObj = JSON.parse(\n                  JSON.stringify(this.copiedControl[this.userFormId][ctrlId])\n                )\n                const item: controlData = {\n                  ...controlObj\n                }\n                this.updateNewControl(this.containerId, ctrlId, item, true)\n                recCopyControl(ctrlId)\n              }\n            }\n          }\n        }\n      }\n      this.selectControl({\n        userFormId: this.userFormId,\n        select: {\n          container: this.getContainerList(selSelected[0]),\n          selected: selSelected\n        }\n      })\n      this.updateCopyControlList({\n        userFormId: this.userFormId,\n        parentId: this.containerId,\n        targetId: selSelected,\n        type: 'copy'\n      })\n    }\n  }\n\n  /**\n   * @description To delete controls in respective container present in respective userform\n   * @function clickDelete\n   */\n  clickDelete () {\n    const selControl = []\n    const userData = this.userformData[this.userFormId]\n    const selected = this.selectedControls[this.userFormId].selected\n    const selContainer = this.selectedControls[this.userFormId].container\n    const filterControls = []\n    const controls = this.userformData[this.userFormId][this.selectedControls[this.userFormId].container[0]].controls\n    for (const control of selected) {\n      if (!control.startsWith('ID_USERFORM')) {\n        if (control.startsWith('group')) {\n          for (const key in userData) {\n            if (\n              userData[key].properties.GroupID === control\n            ) {\n              selControl.push(key)\n            }\n          }\n        } else {\n          selControl.push(control)\n        }\n      }\n    }\n    if (selected.length === 1 && !selected[0].startsWith('group') && this.userformData[this.userFormId][selected[0]].properties.GroupID !== '') {\n      for (let j = 0; j < controls.length; j++) {\n        if (userData[controls[j]].properties.GroupID === userData[selected[0]].properties.GroupID) {\n          filterControls.push(controls[j])\n        }\n      }\n      if (filterControls.length === 2) {\n        const curSelect = filterControls[0] === selected[0] ? filterControls[1] : filterControls[0]\n        const selGroupId = userData[selected[0]].properties.GroupID\n        this.updateControlProperty('GroupID', '', curSelect)\n      }\n    }\n    for (let i = 0; i < selControl.length; i++) {\n      const controlId = userData[selControl[i]].type === 'Page' ? selContainer[0] : selControl[i]\n      this.deleteZIndex(controlId)\n      this.deleteTabIndex(controlId)\n      this.deleteControl({\n        userFormId: this.userFormId,\n        parentId: this.getContainerList(controlId)[0],\n        targetId: controlId\n      })\n    }\n\n    this.selectControl({\n      userFormId: this.userFormId,\n      select: {\n        container: userData[selContainer[0]].type === 'MultiPage' ? this.getContainerList(selContainer[0]) : selContainer,\n        selected: userData[selContainer[0]].type === 'MultiPage' ? [this.getContainerList(selContainer[0])[0]] : [selContainer[0]]\n      }\n    })\n    EventBus.$emit('focusUserForm')\n  }\n  updateAction (event: KeyboardEvent) {\n    let controlActionName = ''\n    if (event.ctrlKey && event.code === 'KeyA') {\n      controlActionName = 'ID_SELECTALL'\n    } else if (event.ctrlKey && event.code === 'KeyC') {\n      if (\n        this.selectedControls[this.userFormId].selected[0] !== this.userFormId\n      ) {\n        controlActionName = 'ID_COPY'\n      }\n    } else if (event.keyCode === 46) {\n      controlActionName = 'ID_DELETE'\n    } else if (event.ctrlKey && event.code === 'KeyV') {\n      controlActionName = 'ID_PASTE'\n    } else if (event.keyCode && event.code === 'KeyX') {\n      controlActionName = 'ID_CUT'\n    }\n    this.controlAction(controlActionName, '')\n  }\n  updatePropVal (propName: string, propValue: number) {\n    const ctrlSel = this.selectedControls[this.userFormId].selected\n    const usrFrmData = this.userformData[this.userFormId]\n    for (let index = 1; index < ctrlSel.length; index++) {\n      if (!ctrlSel[index].startsWith('group')) {\n        const curProp = usrFrmData[ctrlSel[index]].properties\n        if (propName === 'selRight') {\n          const curRight = curProp.Width! + curProp.Left!\n          const value = curProp.Left! + (propValue - curRight)\n          this.updateControlProperty('Left', value, ctrlSel[index])\n        } else if (propName === 'selBottom') {\n          const curBottom = curProp.Height! + curProp.Top!\n          const value = curProp.Top! + (propValue - curBottom)\n          this.updateControlProperty('Top', value, ctrlSel[index])\n        }\n        if (propName === 'selCenter') {\n          const curCenter = curProp.Width! / 2\n          const value = propValue - curCenter\n          this.updateControlProperty('Left', value, ctrlSel[index])\n        }\n        if (propName === 'selMiddle') {\n          const curMiddle = curProp.Height! / 2\n          const value = propValue - curMiddle\n          this.updateControlProperty('Top', value, ctrlSel[index])\n        } else {\n          const propertyname: keyof controlProperties = propName as keyof controlProperties\n          this.updateControlProperty(propertyname, propValue, ctrlSel[index])\n        }\n      } else {\n        const groupIndex: number = this.groupStyleArray.findIndex(val => val.groupName === ctrlSel[index])\n        const curProp = this.groupStyleArray[groupIndex]\n        const left = parseInt(curProp.left!)\n        const top = parseInt(curProp.top!)\n        const width = parseInt(curProp.width!)\n        const height = parseInt(curProp.height!)\n        let value = -1\n        if (propName === 'selRight') {\n          value = left! + (propValue - (width! + left!))\n          EventBus.$emit('updasteGroupSize', 'Left', value, groupIndex)\n        } else if (propName === 'selBottom') {\n          value = top! + (propValue - (height + top))\n          EventBus.$emit('updasteGroupSize', 'Top', value, groupIndex)\n        }\n        if (propName === 'selCenter') {\n          value = propValue - (width! / 2)\n          EventBus.$emit('updasteGroupSize', 'Left', value, groupIndex)\n        }\n        if (propName === 'selMiddle') {\n          value = propValue - height! / 2\n          EventBus.$emit('updasteGroupSize', 'Top', value, groupIndex)\n        } else {\n          const propertyname: keyof controlProperties = propName as keyof controlProperties\n          EventBus.$emit('updasteGroupSize', propertyname, propValue, groupIndex)\n        }\n      }\n    }\n  }\n  controlAlignMent (subVal: string) {\n    const mainSel = this.selectedControls[this.userFormId].selected[0]\n    const isGroup = mainSel.startsWith('group')\n    const usrFrmData = this.userformData[this.userFormId]\n    const ctrlProp = !isGroup && usrFrmData[mainSel].properties\n    const groupIndex: number = this.groupStyleArray.findIndex(val => val.groupName === mainSel)\n    const newObject = {\n      Left: isGroup && groupIndex !== -1 ? parseInt(this.groupStyleArray[groupIndex].left!) : ctrlProp ? ctrlProp.Left! : 0,\n      Top: isGroup && groupIndex !== -1 ? parseInt(this.groupStyleArray[groupIndex].top!) : ctrlProp ? ctrlProp.Top! : 0,\n      Width: isGroup && groupIndex !== -1 ? parseInt(this.groupStyleArray[groupIndex].width!) : ctrlProp ? ctrlProp.Width! : 0,\n      Height: isGroup && groupIndex !== -1 ? parseInt(this.groupStyleArray[groupIndex].height!) : ctrlProp ? ctrlProp.Height! : 0\n    }\n    if (subVal === 'ID_ALIGNLEFT') {\n      this.updatePropVal('Left', newObject.Left!)\n    } else if (subVal === 'ID_ALIGNTOP') {\n      this.updatePropVal('Top', newObject.Top!)\n    } else if (subVal === 'ID_ALIGNRIGHT') {\n      const selRight = newObject.Width! + newObject.Left!\n      this.updatePropVal('selRight', selRight)\n    } else if (subVal === 'ID_ALIGNBOTTOM') {\n      const selBottom = newObject.Height! + newObject.Top!\n      this.updatePropVal('selBottom', selBottom)\n    } else if (subVal === 'ID_ALIGNCENTER') {\n      const selCenter = newObject.Left! + newObject.Width! / 2\n      this.updatePropVal('selCenter', selCenter)\n    } else if (subVal === 'ID_ALIGNMIDDLE') {\n      const selMiddle = newObject.Top! + newObject.Height! / 2\n      this.updatePropVal('selMiddle', selMiddle)\n    } else if (subVal === 'ID_WIDTH') {\n      this.updatePropVal('Width', newObject.Width!)\n    } else if (subVal === 'ID_HEIGHT') {\n      this.updatePropVal('Height', newObject.Height!)\n    } else if (subVal === 'ID_BOTH') {\n      this.updatePropVal('Height', newObject.Height!)\n      this.updatePropVal('Width', newObject.Width!)\n    }\n  }\n\n  controlDisable (event: MouseEvent) {\n    event.preventDefault()\n    event.stopPropagation()\n  }\n}\n</script>\n\n<style scoped>\n.outercontext-div {\n  border: 0.3px solid black;\n  box-shadow: 2px 2px lightgray;\n  width: 150px;\n  height: auto;\n  font-size: 13px;\n  position: fixed;\n  z-index: 1000;\n}\n.wrapper-context {\n  display: grid;\n  grid-template-columns: 1fr;\n  width: 100%;\n  height: 100%;\n}\n.wrapper1-context {\n  display: grid;\n  grid-template-columns: 10% 90%;\n  border: 0.3px solid white;\n  background: white;\n  height: 24px;\n  padding-top: 5px;\n  outline: none;\n}\n.wrapper1-context:hover {\n  background-color: rgb(155, 215, 255);\n  border: 0.3px solid rgb(0, 153, 255);\n}\n.wrapper21 {\n  display: grid;\n  grid-template-columns: 10% 85% 5%;\n}\n.triangle-right {\n  width: 0;\n  height: 0;\n  border-top: 5px solid transparent;\n  border-left: 5px solid black;\n  border-bottom: 5px solid transparent;\n  padding-top: 2px;\n}\n.iset-context {\n  text-align: left;\n  padding-left: 15px;\n  font-size: 12px;\n}\n.set-context {\n  text-align: left;\n  padding-left: 15px;\n  font-size: 12px;\n}\nhr {\n  margin: 0px;\n}\nul {\n  list-style-type: none;\n  margin-block-start: 0em;\n  margin-block-end: 0em;\n  margin-inline-start: 0px;\n  margin-inline-end: 0px;\n  padding-inline-start: 0px;\n  margin-top: 0px;\n  margin-bottom: 0px;\n}\n\n/* testing submenu */\n\n.top-level-menu {\n  list-style: none;\n  padding: 0;\n  margin: 0;\n}\n\n.top-level-menu > li {\n  position: absolute;\n  float: left;\n  height: 30px;\n  width: 143px;\n}\n\n.top-level-menu li:hover > ul {\n  /* On hover, display the next level's menu */\n  display: inline;\n}\n\n/* Menu Link Styles */\n\n.top-level-menu a /* Apply to all links inside the multi-level menu */ {\n  font-size: 12px;\n  color: black;\n  text-decoration: none;\n  padding: 0 0 0 10px;\n  padding-left: 15px;\n\n  /* Make the link cover the entire list item-container */\n  display: block;\n}\n.top-level-menu a:hover {\n  color: black;\n}\n.third-level-menu {\n  position: absolute;\n  top: 0;\n  right: -100px;\n  width: 110px;\n  list-style: none;\n  padding: 0;\n  margin: 0;\n  display: none;\n  border: 1px solid black;\n  background-color: white;\n}\n\n.third-level-menu > li {\n  height: 20px;\n  padding-top: 5px;\n  /* margin: 1px; */\n}\n.third-level-menu > li:hover {\n  background-color: rgb(155, 215, 255);\n  border: 0.2px solid rgb(0, 153, 255);\n}\n.top-level-menu1 {\n  list-style: none;\n  padding: 0;\n  margin: 0;\n}\n\n.top-level-menu1 > li {\n  position: absolute;\n  float: left;\n  height: 30px;\n  width: 143px;\n}\n\n.top-level-menu1 li:hover > ul {\n  /* On hover, display the next level's menu */\n  display: inline;\n}\n\n/* Menu Link Styles */\n\n.top-level-menu1 a /* Apply to all links inside the multi-level menu */ {\n  font-size: 12px;\n  color: black;\n  text-decoration: none;\n  padding: 0 0 0 10px;\n  padding-left: 15px;\n\n  /* Make the link cover the entire list item-container */\n  display: block;\n}\n.top-level-menu1 a:hover {\n  color: black;\n}\n.third {\n  padding-left: 5px;\n}\n.third > a {\n  padding-left: 10px;\n}\n.icons {\n  margin-left: 3px;\n}\n</style>\n"]}]}