{"remainingRequest":"/home/mobiotics/Projects/hancom/formcontrols/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/mobiotics/Projects/hancom/formcontrols/src/FormDesigner/components/atoms/FDTextBox/index.vue?vue&type=script&lang=ts&","dependencies":[{"path":"/home/mobiotics/Projects/hancom/formcontrols/src/FormDesigner/components/atoms/FDTextBox/index.vue","mtime":1610544258554},{"path":"/home/mobiotics/Projects/hancom/formcontrols/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/mobiotics/Projects/hancom/formcontrols/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/mobiotics/Projects/hancom/formcontrols/node_modules/ts-loader/index.js","mtime":499162500000},{"path":"/home/mobiotics/Projects/hancom/formcontrols/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/mobiotics/Projects/hancom/formcontrols/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKaW1wb3J0IHsKICBDb21wb25lbnQsCiAgVnVlLAogIFByb3AsCiAgUmVmLAogIFdhdGNoLAogIEVtaXQsCiAgTWl4aW5zCn0gZnJvbSAndnVlLXByb3BlcnR5LWRlY29yYXRvcicKaW1wb3J0IEZkQ29udHJvbFZ1ZSBmcm9tICdAL2FwaS9hYnN0cmFjdC9Gb3JtRGVzaWduZXIvRmRDb250cm9sVnVlJwppbXBvcnQgeyBEaXJlY3RpdmVCaW5kaW5nIH0gZnJvbSAndnVlL3R5cGVzL29wdGlvbnMnCgpAQ29tcG9uZW50KHsKICBuYW1lOiAnRkRUZXh0Qm94JywKICBmaWx0ZXJzOiB7CiAgICAvKioKICAgICAqIEBkZXNjcmlwdGlvbiBmaWx0ZXIgdG8gc2hvdyBwYXNzd29yZENoYXIgaW5zdGVhZCBvZiBvcmlnaW5hbCB0ZXh0CiAgICAgKiBAZnVuY3Rpb24gcGFzc3dvcmRGaWx0ZXIKICAgICAqIEBwYXJhbSB2YWx1ZSB0ZXh0IHRvIGJlIGZpbHRlcmVkCiAgICAgKiBAcGFyYW0gcGFzc3dvcmQgcGFzc3dvcmRDaGFyIHZhbHVlIHRvIGZpbHRlciB0aGUgdGV4dAogICAgICogQHBhcmFtIHRleHQgIFRleHRCb3ggcHJvcGVydGllcyBUZXh0IFZhbHVlCiAgICAgKi8KICAgIHBhc3N3b3JkRmlsdGVyICh2YWx1ZTogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nLCB0ZXh0OiBzdHJpbmcpIHsKICAgICAgaWYgKHBhc3N3b3JkICE9PSAnJyAmJiB0ZXh0ICE9PSAnJykgewogICAgICAgIGxldCBmaWx0ZXJlZFZhbHVlOiBzdHJpbmcgPSAnJwogICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0ZXh0Lmxlbmd0aDsgaW5kZXgrKykgewogICAgICAgICAgZmlsdGVyZWRWYWx1ZSA9IGZpbHRlcmVkVmFsdWUgKyBwYXNzd29yZFswXQogICAgICAgIH0KICAgICAgICByZXR1cm4gZmlsdGVyZWRWYWx1ZQogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiB2YWx1ZQogICAgICB9CiAgICB9CiAgfSwKICBkaXJlY3RpdmVzOiB7CiAgICBjdXJzb3JEaXJlY3RpdmU6IHsKICAgICAgLyoqCiAgICAgICAqIEBkZXNjcmlwdGlvbiAgY2FsbGVkIGFmdGVyIHRoZSBjb250YWluaW5nIGNvbXBvbmVudOKAmXMgVk5vZGUgaGFzIHVwZGF0ZWQKICAgICAgICogdXBkYXRlcyBzZWxlY3Rpb24gc3RhcnQgYW5kIGVuZCBjdXJzb3IgcG9zaXRvbiB3aGVuIGRhdGEgbW9kZWwgdmFsdWUgY2hhbmdlcwogICAgICAgKiB0byBtYWludGFpbiBjdXJzb3IgcG9zaXRpb24KICAgICAgICogQGZ1bmN0aW9uIHVwZGF0ZSBIb29rIEZ1bmN0aW9ucyBpLmUsIChiaW5kLCBpbnNlcnRlZCwgdXBkYXRlLCBjb21wb25lbnRVcGRhdGVkLCB1bmJpbmQpCiAgICAgICAqIEBwYXJhbSBldmVudCBUaGUgZWxlbWVudCB0aGUgZGlyZWN0aXZlIGlzIGJvdW5kIHRvLiBUaGlzIGNhbiBiZSB1c2VkIHRvIGRpcmVjdGx5IG1hbmlwdWxhdGUgdGhlIERPTS4KICAgICAgICogQHBhcmFtIHZub2RlIFRoZSB2aXJ0dWFsIG5vZGUgcHJvZHVjZWQgYnkgVnVl4oCZcyBjb21waWxlcgogICAgICAgKi8KICAgICAgdXBkYXRlIChldmVudDogSFRNTEVsZW1lbnQsIHZub2RlOiBEaXJlY3RpdmVCaW5kaW5nKSB7CiAgICAgICAgaWYgKHZub2RlLnZhbHVlLnB3ZENoYXJUeXBlICE9PSAnJykgewogICAgICAgICAgKGV2ZW50IGFzIEhUTUxGb3JtRWxlbWVudCkuc2VsZWN0aW9uU3RhcnQgPSB2bm9kZS52YWx1ZS5zdGFydDsKICAgICAgICAgIChldmVudCBhcyBIVE1MRm9ybUVsZW1lbnQpLnNlbGVjdGlvbkVuZCA9IHZub2RlLnZhbHVlLmVuZAogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkCiAgICAgICAgfQogICAgICB9CiAgICB9CiAgfQp9KQpleHBvcnQgZGVmYXVsdCBjbGFzcyBGRFRleHRCb3ggZXh0ZW5kcyBNaXhpbnMoRmRDb250cm9sVnVlKSB7CiAgQFJlZignaGlkZVNlbGVjdGlvbkRpdicpIHJlYWRvbmx5IGhpZGVTZWxlY3Rpb25EaXYhOiBIVE1MRGl2RWxlbWVudDsKICBAUmVmKCdhdXRvU2l6ZVRleHRhcmVhJykgcmVhZG9ubHkgYXV0b1NpemVUZXh0YXJlYSE6IEhUTUxMYWJlbEVsZW1lbnQ7CiAgQFJlZigndGV4dGFyZWFSZWYnKSB0ZXh0YXJlYVJlZjogSFRNTFRleHRBcmVhRWxlbWVudDsKICAkZWw6IEhUTUxEaXZFbGVtZW50CiAgZ2V0IGdldERpc2FibGVWYWx1ZSAoKSB7CiAgICBpZiAodGhpcy5pc1J1bk1vZGUgfHwgdGhpcy5pc0VkaXRNb2RlKSB7CiAgICAgIHJldHVybiAoCiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLkVuYWJsZWQgPT09IGZhbHNlIHx8IHRoaXMucHJvcGVydGllcy5Mb2NrZWQgPT09IHRydWUKICAgICAgKQogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuIHRydWUKICAgIH0KICB9CiAgLyoqCiAgICogQGRlc2NyaXB0aW9uIHN0eWxlIG9iamVjdCBpcyBwYXNzZWQgdG8gOnN0eWxlIGF0dHJpYnV0ZSBpbiBUZXh0YXJlYSB0YWcKICAgKiBkeW5hbWljYWxseSBjaGFuZ2luZyB0aGUgc3R5bGVzIG9mIHRoZSBjb21wb25lbnQgYmFzZWQgb24gcHJvcGVydGllcwogICAqIEBmdW5jdGlvbiBjc3NTdHlsZVByb3BlcnR5CiAgICoKICAgKi8KICBnZXQgY3NzU3R5bGVQcm9wZXJ0eSAoKSB7CiAgICBjb25zdCBjb250cm9sUHJvcCA9IHRoaXMucHJvcGVydGllcwogICAgY29uc3QgZm9udDogZm9udCA9IGNvbnRyb2xQcm9wLkZvbnQKICAgICAgPyBjb250cm9sUHJvcC5Gb250CiAgICAgIDogewogICAgICAgIEZvbnROYW1lOiAnQXJpYWwnLAogICAgICAgIEZvbnRTaXplOiAxMCwKICAgICAgICBGb250SXRhbGljOiB0cnVlLAogICAgICAgIEZvbnRCb2xkOiB0cnVlLAogICAgICAgIEZvbnRVbmRlcmxpbmU6IHRydWUsCiAgICAgICAgRm9udFN0cmlrZXRocm91Z2g6IHRydWUsCiAgICAgICAgRm9udFN0eWxlOiAnQXJpYWwnCiAgICAgIH0KICAgIHJldHVybiB7CiAgICAgIGxlZnQ6IGAke2NvbnRyb2xQcm9wLkxlZnR9cHhgLAogICAgICB3aWR0aDogYCR7Y29udHJvbFByb3AuV2lkdGh9cHhgLAogICAgICBoZWlnaHQ6IGAke2NvbnRyb2xQcm9wLkhlaWdodH1weGAsCiAgICAgIHRvcDogYCR7Y29udHJvbFByb3AuVG9wfXB4YCwKICAgICAgYm9yZGVyQ29sb3I6IGNvbnRyb2xQcm9wLkJvcmRlclN0eWxlID09PSAxID8gY29udHJvbFByb3AuQm9yZGVyQ29sb3IgOiAnJywKICAgICAgdGV4dEFsaWduOgogICAgICAgIGNvbnRyb2xQcm9wLlRleHRBbGlnbiA9PT0gMAogICAgICAgICAgPyAnbGVmdCcKICAgICAgICAgIDogY29udHJvbFByb3AuVGV4dEFsaWduID09PSAxCiAgICAgICAgICAgID8gJ2NlbnRlcicKICAgICAgICAgICAgOiAncmlnaHQnLAogICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbnRyb2xQcm9wLkJhY2tTdHlsZSA/IGNvbnRyb2xQcm9wLkJhY2tDb2xvciA6ICd0cmFuc3BhcmVudCcsCiAgICAgIGJvcmRlckxlZnQ6IGNvbnRyb2xQcm9wLkJvcmRlclN0eWxlID09PSAxID8gJzFweCBzb2xpZCAnICsgY29udHJvbFByb3AuQm9yZGVyQ29sb3IgOiBjb250cm9sUHJvcC5TcGVjaWFsRWZmZWN0ID09PSAyID8gJzJweCBzb2xpZCBncmF5JyA6IGNvbnRyb2xQcm9wLlNwZWNpYWxFZmZlY3QgPT09IDMgPyAnMS41cHggc29saWQgZ3JheScgOiBjb250cm9sUHJvcC5TcGVjaWFsRWZmZWN0ID09PSA0ID8gJzAuNXB4IHNvbGlkIGdyYXknIDogJycsCiAgICAgIGJvcmRlclJpZ2h0OiBjb250cm9sUHJvcC5Cb3JkZXJTdHlsZSA9PT0gMSA/ICcxcHggc29saWQgJyArIGNvbnRyb2xQcm9wLkJvcmRlckNvbG9yIDogY29udHJvbFByb3AuU3BlY2lhbEVmZmVjdCA9PT0gMSA/ICcycHggc29saWQgZ3JheScgOiBjb250cm9sUHJvcC5TcGVjaWFsRWZmZWN0ID09PSA0ID8gJzEuNXB4IHNvbGlkIGdyYXknIDogY29udHJvbFByb3AuU3BlY2lhbEVmZmVjdCA9PT0gMyA/ICcwLjVweCBzb2xpZCBncmF5JyA6ICcnLAogICAgICBib3JkZXJUb3A6IGNvbnRyb2xQcm9wLkJvcmRlclN0eWxlID09PSAxID8gJzFweCBzb2xpZCAnICsgY29udHJvbFByb3AuQm9yZGVyQ29sb3IgOiBjb250cm9sUHJvcC5TcGVjaWFsRWZmZWN0ID09PSAyID8gJzJweCBzb2xpZCBncmF5JyA6IGNvbnRyb2xQcm9wLlNwZWNpYWxFZmZlY3QgPT09IDMgPyAnMS41cHggc29saWQgZ3JheScgOiBjb250cm9sUHJvcC5TcGVjaWFsRWZmZWN0ID09PSA0ID8gJzAuNXB4IHNvbGlkIGdyYXknIDogJycsCiAgICAgIGJvcmRlckJvdHRvbTogY29udHJvbFByb3AuQm9yZGVyU3R5bGUgPT09IDEgPyAnMXB4IHNvbGlkICcgKyBjb250cm9sUHJvcC5Cb3JkZXJDb2xvciA6IGNvbnRyb2xQcm9wLlNwZWNpYWxFZmZlY3QgPT09IDEgPyAnMnB4IHNvbGlkIGdyYXknIDogY29udHJvbFByb3AuU3BlY2lhbEVmZmVjdCA9PT0gNCA/ICcxLjVweCBzb2xpZCBncmF5JyA6IGNvbnRyb2xQcm9wLlNwZWNpYWxFZmZlY3QgPT09IDMgPyAnMC41cHggc29saWQgZ3JheScgOiAnJywKICAgICAgd2hpdGVTcGFjZToKICAgICAgICBjb250cm9sUHJvcC5Xb3JkV3JhcCAmJiBjb250cm9sUHJvcC5NdWx0aUxpbmUgPyAnbm9ybWFsJyA6ICdub3dyYXAnLAogICAgICB3b3JkQnJlYWs6CiAgICAgICAgY29udHJvbFByb3AuV29yZFdyYXAgJiYgY29udHJvbFByb3AuTXVsdGlMaW5lID8gJ2JyZWFrLXdvcmQnIDogJ25vcm1hbCcsCiAgICAgIGNvbG9yOgogICAgICAgIGNvbnRyb2xQcm9wLkVuYWJsZWQgPT09IHRydWUgPyBjb250cm9sUHJvcC5Gb3JlQ29sb3IgOiB0aGlzLmdldEVuYWJsZWQsCiAgICAgIGN1cnNvcjoKICAgICAgICBjb250cm9sUHJvcC5Nb3VzZVBvaW50ZXIgIT09IDAgfHwgY29udHJvbFByb3AuTW91c2VJY29uICE9PSAnJwogICAgICAgICAgPyB0aGlzLmdldE1vdXNlQ3Vyc29yRGF0YQogICAgICAgICAgOiAnZGVmYXVsdCcsCiAgICAgIGZvbnRGYW1pbHk6IChmb250LkZvbnRTdHlsZSEgIT09ICcnKSA/IHRoaXMuc2V0Rm9udFN0eWxlIDogZm9udC5Gb250TmFtZSEsCiAgICAgIGZvbnRTaXplOiBgJHtmb250LkZvbnRTaXplfXB4YCwKICAgICAgZm9udFN0eWxlOiBmb250LkZvbnRJdGFsaWMgfHwgdGhpcy5pc0l0YWxpYyA/ICdpdGFsaWMnIDogJycsCiAgICAgIHRleHREZWNvcmF0aW9uOgogICAgICAgIGZvbnQuRm9udFN0cmlrZXRocm91Z2ggPT09IHRydWUgJiYgZm9udC5Gb250VW5kZXJsaW5lID09PSB0cnVlCiAgICAgICAgICA/ICd1bmRlcmxpbmUgbGluZS10aHJvdWdoJwogICAgICAgICAgOiBmb250LkZvbnRVbmRlcmxpbmUKICAgICAgICAgICAgPyAndW5kZXJsaW5lJwogICAgICAgICAgICA6IGZvbnQuRm9udFN0cmlrZXRocm91Z2gKICAgICAgICAgICAgICA/ICdsaW5lLXRocm91Z2gnCiAgICAgICAgICAgICAgOiAnJywKICAgICAgZm9udFdlaWdodDogZm9udC5Gb250Qm9sZCA/ICdib2xkJyA6IChmb250LkZvbnRTdHlsZSAhPT0gJycpID8gdGhpcy50ZW1wV2VpZ2h0IDogJycsCiAgICAgIGZvbnRTdHJldGNoOiAoZm9udC5Gb250U3R5bGUgIT09ICcnKSA/IHRoaXMudGVtcFN0cmV0Y2ggOiAnJywKICAgICAgZGlzcGxheTogY29udHJvbFByb3AuVmlzaWJsZSA/ICdibG9jaycgOiAnbm9uZScsCiAgICAgIG92ZXJmbG93WDogdGhpcy5nZXRTY3JvbGxCYXJYLAogICAgICBvdmVyZmxvd1k6IHRoaXMuZ2V0U2Nyb2xsQmFyWQogICAgICAvLyBwb3NpdGlvbjogJ3JlbGF0aXZlJwogICAgfQogIH0KCiAgLyoqCiAgICogQGRlc2NyaXB0aW9uIHVwZGF0ZXMgdGhlIGRhdGFNb2RlbCB0ZXh0Qm94IG9iamVjdCBwcm9wZXJ0aWVzIHdoZW4gdXNlciBpbnNlcnQvZGVsZXRlIHRleHQKICAgKiBpbnNpZGUgdGV4dEJveCB3aGVuIHBhc3N3b3JkQ2hhciBpcyBzZXQsIHVwZGF0ZXMgdGV4dCBhbmQgdmFsdWVzIHByb3BlcnRpZXMgb2YgdGV4dEJveCB3aXRoIGVudGVyZWQgY2hhcmFjdGVyCiAgICogQGZ1bmN0aW9uIGhhbmRsZVBhc3N3b3JkQ2hhcgogICAqIEBwYXJhbSBldmVudCBpdHMgb2YgdHlwZSBUZXh0RXZlbnQKICAgKiBAZXZlbnQgaW5wdXQKICAgKgogICAqLwogIGhhbmRsZVBhc3N3b3JkQ2hhciAoZXZlbnQ6IFRleHRFdmVudCkgewogICAgbGV0IG5ld0RhdGEKICAgIGxldCB0ZXh0ID0gdGhpcy5wcm9wZXJ0aWVzLlRleHQhCiAgICBsZXQgc2VsZWN0aW9uRGlmZiA9CiAgICAgICh0aGlzLmRhdGEucHJvcGVydGllcyEuQ3Vyc29yU3RhcnRQb3NpdGlvbiBhcyBudW1iZXIpICE9PQogICAgICAodGhpcy5kYXRhLnByb3BlcnRpZXMhLkN1cnNvckVuZFBvc2l0aW9uIGFzIG51bWJlcikKICAgIGlmIChldmVudC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MVGV4dEFyZWFFbGVtZW50KSB7CiAgICAgIGlmIChzZWxlY3Rpb25EaWZmKSB7CiAgICAgICAgLy8gc2VsZWN0aW9uCiAgICAgICAgbmV3RGF0YSA9CiAgICAgICAgdGV4dC5zdWJzdHJpbmcoMCwgdGhpcy5kYXRhLnByb3BlcnRpZXMhLkN1cnNvclN0YXJ0UG9zaXRpb24gYXMgbnVtYmVyKSArCiAgICAgICAgdGV4dC5zdWJzdHJpbmcodGhpcy5kYXRhLnByb3BlcnRpZXMhLkN1cnNvckVuZFBvc2l0aW9uIGFzIG51bWJlcikKICAgICAgICB0aGlzLnVwZGF0ZURhdGFNb2RlbCh7IHByb3BlcnR5TmFtZTogJ1RleHQnLCB2YWx1ZTogbmV3RGF0YSB9KQogICAgICAgIHRoaXMudXBkYXRlRGF0YU1vZGVsKHsgcHJvcGVydHlOYW1lOiAnVmFsdWUnLCB2YWx1ZTogbmV3RGF0YSB9KQogICAgICB9IGVsc2UgaWYgKHRleHQubGVuZ3RoIDwgZXZlbnQudGFyZ2V0LnZhbHVlLmxlbmd0aCkgewogICAgICAgIC8vIGluc2VydGlvbgogICAgICAgIG5ld0RhdGEgPSBbCiAgICAgICAgICB0ZXh0LnNsaWNlKDAsIGV2ZW50LnRhcmdldC5zZWxlY3Rpb25TdGFydCAtIDEpLAogICAgICAgICAgZXZlbnQuZGF0YSwKICAgICAgICAgIHRleHQuc2xpY2UoZXZlbnQudGFyZ2V0LnNlbGVjdGlvblN0YXJ0IC0gMSkKICAgICAgICBdLmpvaW4oJycpCiAgICAgICAgdGhpcy51cGRhdGVEYXRhTW9kZWwoeyBwcm9wZXJ0eU5hbWU6ICdUZXh0JywgdmFsdWU6IG5ld0RhdGEgfSkKICAgICAgICB0aGlzLnVwZGF0ZURhdGFNb2RlbCh7IHByb3BlcnR5TmFtZTogJ1ZhbHVlJywgdmFsdWU6IG5ld0RhdGEgfSkKICAgICAgfSBlbHNlIGlmICh0ZXh0Lmxlbmd0aCA+IGV2ZW50LnRhcmdldC52YWx1ZS5sZW5ndGgpIHsKICAgICAgICAvLyBkZWxldGlvbgogICAgICAgIG5ld0RhdGEgPSBbCiAgICAgICAgICB0ZXh0LnNsaWNlKDAsIGV2ZW50LnRhcmdldC5zZWxlY3Rpb25TdGFydCksCiAgICAgICAgICB0ZXh0LnNsaWNlKGV2ZW50LnRhcmdldC5zZWxlY3Rpb25TdGFydCArIDEpCiAgICAgICAgXS5qb2luKCcnKQogICAgICAgIHRoaXMudXBkYXRlRGF0YU1vZGVsKHsgcHJvcGVydHlOYW1lOiAnVGV4dCcsIHZhbHVlOiBuZXdEYXRhIH0pCiAgICAgICAgdGhpcy51cGRhdGVEYXRhTW9kZWwoeyBwcm9wZXJ0eU5hbWU6ICdWYWx1ZScsIHZhbHVlOiBuZXdEYXRhIH0pCiAgICAgIH0KICAgICAgdGhpcy51cGRhdGVEYXRhTW9kZWwoewogICAgICAgIHByb3BlcnR5TmFtZTogJ0N1cnNvclN0YXJ0UG9zaXRpb24nLAogICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQuc2VsZWN0aW9uU3RhcnQKICAgICAgfSkKICAgICAgdGhpcy51cGRhdGVEYXRhTW9kZWwoewogICAgICAgIHByb3BlcnR5TmFtZTogJ0N1cnNvckVuZFBvc2l0aW9uJywKICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LnNlbGVjdGlvbkVuZAogICAgICB9KQogICAgfSBlbHNlIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBIVE1MVGV4dEFyZWFFbGVtZW50IGJ1dCBmb3VuZCBkaWZmZXJlbnQgZWxlbWVudCcpCiAgICB9CiAgfQogIC8qKgogICAqIEBkZXNjcmlwdGlvbiBzdHlsZSBvYmplY3QgaXMgcGFzc2VkIHRvIDpzdHlsZSBhdHRyaWJ1dGUgaW4gZGl2IHRhZwogICAqIGR5bmFtaWNhbGx5IGNoYW5naW5nIHRoZSBzdHlsZXMgb2YgdGhlIGNvbXBvbmVudCBiYXNlZCBvbiBjc3NTdHlsZVByb3BlcnR5IG9mCiAgICogdGV4dGFyZWEKICAgKiBAZnVuY3Rpb24gZGl2Y3NzU3R5bGVQcm9wZXJ0eQogICAqCiAgICovCiAgZ2V0IGRpdmNzc1N0eWxlUHJvcGVydHkgKCkgewogICAgY29uc3Qgc3R5bGVPYmplY3QgPSB0aGlzLmNzc1N0eWxlUHJvcGVydHkKICAgIHJldHVybiB7CiAgICAgIC4uLnN0eWxlT2JqZWN0LAogICAgICBkaXNwbGF5OiAnbm9uZScsCiAgICAgIHBhZGRpbmdUb3A6ICcycHgnLAogICAgICBwYWRkaW5nTGVmdDogJzJweCcKICAgIH0KICB9CiAgLyoqCiAgICogQGRlc2NyaXB0aW9uIFdoZW4gdXNlciBlbnRlcnMgY3RybCArIGVudGVyIGN1cnNvciBtb3ZlcyB0byBuZXh0IGxpbmUKICAgKiBAZnVuY3Rpb24gaGFuZGxlQ3RybEVudGVyCiAgICogQHBhcmFtIGVsIGl0cyBvZiB0eXBlIEhUTUxUZXh0QXJlYUVsZW1lbnQKICAgKiBAcGFyYW0gdGV4dCBuZXcgbGluZSBjaGFyYWN0ZXIKICAgKiBAZXZlbnQga2V5ZG93bi5lbnRlci5jdHJsCiAgICovCiAgaGFuZGxlQ3RybEVudGVyIChlbCA6IEhUTUxUZXh0QXJlYUVsZW1lbnQsIHRleHQ6IHN0cmluZykgewogICAgZWwuZm9jdXMoKQogICAgaWYgKHR5cGVvZiBlbC5zZWxlY3Rpb25TdGFydCA9PT0gJ251bWJlcicgJiYKICAgICAgICAgICAgdHlwZW9mIGVsLnNlbGVjdGlvbkVuZCA9PT0gJ251bWJlcicpIHsKICAgICAgY29uc3QgdmFsID0gZWwudmFsdWUKICAgICAgY29uc3Qgc2VsU3RhcnQgPSBlbC5zZWxlY3Rpb25TdGFydAogICAgICBlbC52YWx1ZSA9IHZhbC5zbGljZSgwLCBzZWxTdGFydCkgKyB0ZXh0ICsgdmFsLnNsaWNlKGVsLnNlbGVjdGlvbkVuZCkKICAgICAgZWwuc2VsZWN0aW9uRW5kID0gZWwuc2VsZWN0aW9uU3RhcnQgPSBzZWxTdGFydCArIHRleHQubGVuZ3RoCiAgICB9CiAgfQogIC8qKgogICAqIEBkZXNjcmlwdGlvbiBFbnRlcktleUJlaGF2aW9yIC0gaWYgdHJ1ZSB3aGVuIGVudGVyIGlzIHByZXNzZWQgd2hpbGUgZWRpdGluZyB0aGUgY3Vyc29yIG1vdmVzIHRvIG5leHQgbGluZQogICAqICBpZiBmYWxzZSB0aGUgY3Vyc29yIHJlbWFpbnMgaW4gc2FtZSBwbGFjZQogICAqIEBmdW5jdGlvbiBlbnRlcktleUJlaGF2aW9yCiAgICogQHBhcmFtIGV2ZW50IGl0cyBvZiB0eXBlIEtleWJvYXJkRXZlbnQKICAgKiBAZXZlbnQga2V5ZG93bi5lbnRlcgogICAqLwogIGVudGVyS2V5QmVoYXZpb3IgKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogYm9vbGVhbiB7CiAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLk11bHRpTGluZSkgewogICAgICBpZiAoZXZlbnQuY3RybEtleSkgewogICAgICAgIHRoaXMuaGFuZGxlQ3RybEVudGVyKHRoaXMudGV4dGFyZWFSZWYsICdcbicpCiAgICAgICAgcmV0dXJuIHRydWUKICAgICAgfSBlbHNlIGlmICh0aGlzLnByb3BlcnRpZXMuRW50ZXJLZXlCZWhhdmlvciAmJiB0aGlzLnByb3BlcnRpZXMuTXVsdGlMaW5lKSB7CiAgICAgICAgcmV0dXJuIHRydWUKICAgICAgfSBlbHNlIGlmIChldmVudC5zaGlmdEtleSkgewogICAgICAgIHJldHVybiB0cnVlCiAgICAgIH0KICAgIH0KICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCkKICAgIHJldHVybiBmYWxzZQogIH0KCiAgLyoqCiAgICogQGRlc2NyaXB0aW9uICBzcGVjaWZpZXMgaG93IHRoZSBjb250cm9sIHJlc3BvbmRzIHRvIHRoZSBUQUIga2V5CiAgICogd2hlbiAgVGFiS2V5QmVoYXZpb3IgdHJ1ZSBpbiB0ZXh0Qm94IHRhYiBzcGFjZXMgYXJlIGFkZGVkIG9uIHByZXNzIG9mIHRhYiBLZXkKICAgKiB3aGVuIFRhYktleUJlaGF2aW9yIGZhbHNlIGluIHRleHRCb3ggcHJlc3NpbmcgdGFiIG1vdmVzIGZvY3VzIHRvIG5leHQgY29udHJvbHMKICAgKiBAZnVuY3Rpb24gdGFiS2V5QmVoYXZpb3IKICAgKiBAcGFyYW0gZXZlbnQgaXRzIG9mIHR5cGUgTW91c2VFdmVudAogICAqIEBldmVudCBrZXlkb3duLnRhYgogICAqLwogIHRhYktleUJlaGF2aW9yIChldmVudDogS2V5Ym9hcmRFdmVudCk6IGJvb2xlYW4gewogICAgaWYgKHRoaXMucHJvcGVydGllcy5UYWJLZXlCZWhhdmlvcikgewogICAgICBjb25zdCBUQUJLRVkgPSA5CiAgICAgIGlmIChldmVudC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MVGV4dEFyZWFFbGVtZW50KSB7CiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCkKICAgICAgICBjb25zdCBldmVudFRhZ2V0ID0gZXZlbnQudGFyZ2V0CiAgICAgICAgY29uc3Qgc2VsZWN0aW9uU3RhcnQgPSBldmVudFRhZ2V0LnNlbGVjdGlvblN0YXJ0CiAgICAgICAgY29uc3Qgc2VsZWN0aW9uRW5kID0gZXZlbnRUYWdldC5zZWxlY3Rpb25FbmQKICAgICAgICBjb25zdCB2YWx1ZSA9IGV2ZW50VGFnZXQudmFsdWUKICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gVEFCS0VZKSB7CiAgICAgICAgICAoZXZlbnQudGFyZ2V0KS52YWx1ZSA9CiAgICAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMCwgc2VsZWN0aW9uU3RhcnQpICsKICAgICAgICAgICdcdCcgKwogICAgICAgICAgdmFsdWUuc3Vic3RyaW5nKHNlbGVjdGlvbkVuZCkKICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCkKICAgICAgICB9CiAgICAgICAgKGV2ZW50LnRhcmdldCkuc2VsZWN0aW9uU3RhcnQgPSBzZWxlY3Rpb25TdGFydCArIDE7CiAgICAgICAgKGV2ZW50LnRhcmdldCkuc2VsZWN0aW9uRW5kID0gKGV2ZW50LnRhcmdldCkuc2VsZWN0aW9uU3RhcnQKICAgICAgICByZXR1cm4gZmFsc2UKICAgICAgfSBlbHNlIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIEhUTUxUZXh0QXJlYUVsZW1lbnQgYnV0IGZvdW5kIGRpZmZlcmVudCBlbGVtZW50JykKICAgICAgfQogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuIHRydWUKICAgIH0KICB9CiAgLyoqCiAgICogQGRlc2NyaXB0aW9uIHVwZGF0ZXMgdGhlIGRhdGFNb2RlbCB0ZXh0Qm94IG9iamVjdCBwcm9wZXJ0aWVzIHdoZW4gdXNlciBpbnNlcnQvZGVsZXRlIHRleHQKICAgKiBpbnNpZGUgdGV4dEJveCwgdXBkYXRlcyB0ZXh0IGFuZCB2YWx1ZXMgcHJvcGVydGllcyBvZiB0ZXh0Qm94CiAgICogQGZ1bmN0aW9uIHRleHRBbmRWYWx1ZVVwZGF0ZQogICAqIEBwYXJhbSBldmVudCBpdHMgb2YgdHlwZSBJbnB1dEV2ZW50CiAgICogQGV2ZW50IGlucHV0CiAgICoKICAgKi8KICB0ZXh0QW5kVmFsdWVVcGRhdGUgKGV2ZW50OiBJbnB1dEV2ZW50KSB7CiAgICBjb25zdCBwcm9wRGF0YSA9IHRoaXMucHJvcGVydGllcwogICAgaWYgKGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIEhUTUxUZXh0QXJlYUVsZW1lbnQpIHsKICAgICAgdGhpcy51cGRhdGVEYXRhTW9kZWwoewogICAgICAgIHByb3BlcnR5TmFtZTogJ1ZhbHVlJywKICAgICAgICB2YWx1ZTogKGV2ZW50LnRhcmdldCkudmFsdWUKICAgICAgfSkKICAgICAgdGhpcy51cGRhdGVEYXRhTW9kZWwoewogICAgICAgIHByb3BlcnR5TmFtZTogJ1RleHQnLAogICAgICAgIHZhbHVlOiAoZXZlbnQudGFyZ2V0KS52YWx1ZQogICAgICB9KQogICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLkNvbnRyb2xTb3VyY2UgIT09ICcnKSB7CiAgICAgICAgdGhpcy51cGRhdGVEYXRhTW9kZWxFeHRyYURhdGEoewogICAgICAgICAgcHJvcGVydHlOYW1lOiAnQ29udHJvbFNvdXJjZVZhbHVlJywKICAgICAgICAgIHZhbHVlOiAoZXZlbnQudGFyZ2V0KS52YWx1ZQogICAgICAgIH0pCiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZAogICAgICB9CiAgICB9IGVsc2UgewogICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIEhUTUxUZXh0QXJlYUVsZW1lbnQgYnV0IGZvdW5kIGRpZmZlcmVudCBlbGVtZW50JykKICAgIH0KICAgIGlmICh0aGlzLnByb3BlcnRpZXMuQXV0b1NpemUpIHsKICAgICAgdGhpcy51cGRhdGVBdXRvU2l6ZSgpCiAgICB9CiAgfQoKICBAV2F0Y2goJ3Byb3BlcnRpZXMuRm9udC5Gb250U2l6ZScsIHsgZGVlcDogdHJ1ZSB9KQogIGF1dG9TaXplVmFsaWRhdGVPbkZvbnRDaGFuZ2UgKCkgewogICAgaWYgKHRoaXMucHJvcGVydGllcy5BdXRvU2l6ZSkgewogICAgICB0aGlzLnVwZGF0ZUF1dG9TaXplKCkKICAgIH0KICB9CgogIEBXYXRjaCgncHJvcGVydGllcy5Xb3JkV3JhcCcsIHsgZGVlcDogdHJ1ZSB9KQogIGF1dG9TaXplVmFsaWRhdGVPbldvcmRXcmFwQ2hhbmdlICgpIHsKICAgIGlmICh0aGlzLnByb3BlcnRpZXMuQXV0b1NpemUpIHsKICAgICAgdGhpcy51cGRhdGVBdXRvU2l6ZSgpCiAgICB9CiAgfQoKICAvKioKICAgKiBAZGVzY3JpcHRpb24gZHJhZ0JlaGF2aW9yIC0gaWYgdHJ1ZSB3aGVuIGRyYWdnaW5nCiAgICogIGlmIGZhbHNlIHRoZSBjdXJzb3IgcmVtYWlucyBpbiBzYW1lIHBsYWNlCiAgICogQGZ1bmN0aW9uIGRyYWdCZWhhdmlvcgogICAqIEBwYXJhbSBldmVudCBpdHMgb2YgdHlwZSBLZXlib2FyZEV2ZW50CiAgICogQGV2ZW50IGRyYWdTdGFydAogICAqLwogIGRyYWdCZWhhdmlvciAoZTogRXZlbnQpIHsKICAgIGlmICh0aGlzLnByb3BlcnRpZXMuRHJhZ0JlaGF2aW9yKSB7CiAgICAgIHJldHVybiB0cnVlCiAgICB9CiAgICBlLnByZXZlbnREZWZhdWx0KCkKICB9CgogIC8qKgogICAqIEBvdmVycmlkZQogICAqLwogIEBXYXRjaCgncHJvcGVydGllcy5BdXRvU2l6ZScsIHsgZGVlcDogdHJ1ZSB9KQogIHVwZGF0ZUF1dG9TaXplICgpIHsKICAgIGlmICh0aGlzLnByb3BlcnRpZXMuQXV0b1NpemUgPT09IHRydWUpIHsKICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4gewogICAgICAgIGNvbnN0IHRleHRhcmVhUmVmOiBIVE1MVGV4dEFyZWFFbGVtZW50ID0gdGhpcy50ZXh0YXJlYVJlZgogICAgICAgIC8vIHJlcGxpY2F0aW9uIG9mIHN0eXBlIGF0dHJpYnV0ZSB0byBMYWJlbCB0YWcgZm9yIGF1dG9TaXplIHByb3BlcnR5IHRvIHdvcmsKICAgICAgICBsZXQgdGVtcExhYmVsOiBIVE1MTGFiZWxFbGVtZW50ID0gdGhpcy5hdXRvU2l6ZVRleHRhcmVhCiAgICAgICAgdGVtcExhYmVsLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJwogICAgICAgIHRlbXBMYWJlbC5zdHlsZS5mb250U3R5bGUgPSB0ZXh0YXJlYVJlZi5zdHlsZS5mb250U3R5bGUKICAgICAgICB0ZW1wTGFiZWwuc3R5bGUuZm9udFNpemUgPQogICAgICAgICAgICBwYXJzZUludCh0ZXh0YXJlYVJlZi5zdHlsZS5mb250U2l6ZSkgKyAncHgnCiAgICAgICAgdGVtcExhYmVsLnN0eWxlLndoaXRlU3BhY2UgPSB0ZXh0YXJlYVJlZi5zdHlsZS53aGl0ZVNwYWNlCiAgICAgICAgdGVtcExhYmVsLnN0eWxlLndvcmRCcmVhayA9IHRleHRhcmVhUmVmLnN0eWxlLndvcmRCcmVhawogICAgICAgIHRlbXBMYWJlbC5zdHlsZS5mb250V2VpZ2h0ID0gdGV4dGFyZWFSZWYuc3R5bGUuZm9udFdlaWdodAogICAgICAgIHRlbXBMYWJlbC5zdHlsZS53aWR0aCA9IHRleHRhcmVhUmVmLnN0eWxlLndpZHRoCiAgICAgICAgdGVtcExhYmVsLnN0eWxlLmhlaWdodCA9IHRleHRhcmVhUmVmLnN0eWxlLmhlaWdodAogICAgICAgIHRlbXBMYWJlbC5pbm5lclRleHQgPSB0ZXh0YXJlYVJlZi52YWx1ZQogICAgICAgIHRoaXMudXBkYXRlRGF0YU1vZGVsKHsKICAgICAgICAgIHByb3BlcnR5TmFtZTogJ1dpZHRoJywKICAgICAgICAgIHZhbHVlOiB0ZW1wTGFiZWwub2Zmc2V0V2lkdGggKyA1CiAgICAgICAgfSkKICAgICAgICB0aGlzLnVwZGF0ZURhdGFNb2RlbCh7CiAgICAgICAgICBwcm9wZXJ0eU5hbWU6ICdIZWlnaHQnLAogICAgICAgICAgdmFsdWU6IHRlbXBMYWJlbC5vZmZzZXRIZWlnaHQgKyA1CiAgICAgICAgfSkKICAgICAgICB0ZW1wTGFiZWwuaW5uZXJUZXh0ID0gJycKICAgICAgICB0ZW1wTGFiZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJwogICAgICB9KQogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuIHVuZGVmaW5lZAogICAgfQogIH0KCiAgY3JlYXRlZCAoKSB7CiAgICBjb25zdCBwcm9wRGF0YTogY29udHJvbERhdGEgPSB0aGlzLmRhdGEKICAgIGlmIChwcm9wRGF0YS5wcm9wZXJ0aWVzLkNvbnRyb2xTb3VyY2UgIT09ICcnKSB7CiAgICAgIGNvbnN0IGNvbnRyb2xTb3VyY2VWYWx1ZSA9IHByb3BEYXRhLmV4dHJhRGF0YXMhLkNvbnRyb2xTb3VyY2VWYWx1ZQogICAgICB0aGlzLnVwZGF0ZURhdGFNb2RlbCh7CiAgICAgICAgcHJvcGVydHlOYW1lOiAnVmFsdWUnLAogICAgICAgIHZhbHVlOiBjb250cm9sU291cmNlVmFsdWUKICAgICAgfSkKICAgICAgdGhpcy51cGRhdGVEYXRhTW9kZWwoeyBwcm9wZXJ0eU5hbWU6ICdUZXh0JywgdmFsdWU6IGNvbnRyb2xTb3VyY2VWYWx1ZSB9KQogICAgfQogIH0KCiAgLyoqCiAgKiBAZGVzY3JpcHRpb24gd2F0Y2hlcyBDb250cm9sU291cmNlIHByb3BlcnR5CiAgKiBAZnVuY3Rpb24gdXBkYXRlQ29udHJvbFNvdXJjZVZhbHVlCiAgKiBAcGFyYW0gb2xkVmFsIHByZXZpb3VzIHN0cmluZyB2YWx1ZQogICogQHBhcmFtIG5ld1ZhbCAgbmV3L2NoYW5nZWQgc3RyaW5nIHZhbHVlCiAgKi8KICBAV2F0Y2goJ3Byb3BlcnRpZXMuQ29udHJvbFNvdXJjZScsIHsgZGVlcDogdHJ1ZSB9KQogIHVwZGF0ZUNvbnRyb2xTb3VyY2VWYWx1ZSAobmV3VmFsOiBzdHJpbmcsIG9sZFZhbDogc3RyaW5nKSB7CiAgICBjb25zdCBwcm9wRGF0YTogY29udHJvbERhdGEgPSB0aGlzLmRhdGEKICAgIGlmIChwcm9wRGF0YS5wcm9wZXJ0aWVzLkNvbnRyb2xTb3VyY2UgIT09ICcnKSB7CiAgICAgIGNvbnN0IGNvbnRyb2xTb3VyY2VWYWx1ZSA9IHByb3BEYXRhLmV4dHJhRGF0YXMhLkNvbnRyb2xTb3VyY2VWYWx1ZQogICAgICB0aGlzLnVwZGF0ZURhdGFNb2RlbCh7CiAgICAgICAgcHJvcGVydHlOYW1lOiAnVmFsdWUnLAogICAgICAgIHZhbHVlOiBjb250cm9sU291cmNlVmFsdWUKICAgICAgfSkKICAgICAgdGhpcy51cGRhdGVEYXRhTW9kZWwoeyBwcm9wZXJ0eU5hbWU6ICdUZXh0JywgdmFsdWU6IGNvbnRyb2xTb3VyY2VWYWx1ZSB9KQogICAgfSBlbHNlIHsKICAgICAgdGhpcy51cGRhdGVEYXRhTW9kZWwoewogICAgICAgIHByb3BlcnR5TmFtZTogJ1ZhbHVlJywKICAgICAgICB2YWx1ZTogJycKICAgICAgfSkKICAgICAgdGhpcy51cGRhdGVEYXRhTW9kZWwoeyBwcm9wZXJ0eU5hbWU6ICdUZXh0JywgdmFsdWU6ICcnIH0pCiAgICB9CiAgfQogIC8qKgogICAqIEBkZXNjcmlwdGlvbiBrZWVwIHRyYWNrcyBvZiBrZXkgcHJlc3MgYW5kIHNlbGVjdGlvblN0YXJ0IGFuZCBzZWxlY3Rpb25FbmQKICAgKiB1cGRhdGVzIGV4dHJhIHByb3BlcnR5IEN1cnNvclN0YXJ0UG9zaXRpb24gYW5kIEN1cnNvckVuZFBvc2l0aW9uIHdoaWNoIGlzIHJlcXVpcmVkCiAgICogd2hlbiB1c2VyIGluc2VydCwgdXBkYXRlIG9yIGRlbGV0ZSB0ZXh0IGluIHRleHRCb3gKICAgKiBAZnVuY3Rpb24gaGFuZGxlRGVsZXRlCiAgICogQHBhcmFtIGV2ZW50IGl0IGlzIG9mIHR5cGUgS2V5Ym9hcmRFdmVudAogICAqIEBldmVudCBrZXlkb3duCiAgICovCiAgaGFuZGxlRGVsZXRlIChldmVudDogS2V5Ym9hcmRFdmVudCkgewogICAgaWYgKGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIEhUTUxUZXh0QXJlYUVsZW1lbnQpIHsKICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDgpIHsKICAgICAgICB0aGlzLnVwZGF0ZURhdGFNb2RlbCh7CiAgICAgICAgICBwcm9wZXJ0eU5hbWU6ICdDdXJzb3JTdGFydFBvc2l0aW9uJywKICAgICAgICAgIHZhbHVlOiAoZXZlbnQudGFyZ2V0KS5zZWxlY3Rpb25TdGFydCEKICAgICAgICB9KQogICAgICAgIHRoaXMudXBkYXRlRGF0YU1vZGVsKHsKICAgICAgICAgIHByb3BlcnR5TmFtZTogJ0N1cnNvckVuZFBvc2l0aW9uJywKICAgICAgICAgIHZhbHVlOiAoZXZlbnQudGFyZ2V0KS5zZWxlY3Rpb25FbmQhCiAgICAgICAgfSkKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gdW5kZWZpbmVkCiAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgSFRNTFRleHRBcmVhRWxlbWVudCBidXQgZm91bmQgZGlmZmVyZW50IGVsZW1lbnQnKQogICAgfQogIH0KICAvKioKICAgKiBAZGVzY3JpcHRpb24gIHNob3cgc2VsZWN0aW9uIHdoZW4gVGV4dEJveCBsb3NlcyBmb2N1cwogICAqIHdoZW4gSGlkZVNlbGVjdGlvbiBpcyBmYWxzZSBzZWxlY3Rpb24gaXMgc2hvdyBpZiB1c2VyIHNlbGVjdHMgYW55IHRleHQKICAgKiBAZnVuY3Rpb24gaGFuZGxlQmx1cgogICAqIEBldmVudCBibHVyCiAgICoKICAgKi8KICBoYW5kbGVCbHVyICgKICAgIGV2ZW50OiBUZXh0RXZlbnQsCiAgICB0ZXh0YXJlYVJlZjogSFRNTFRleHRBcmVhRWxlbWVudCwKICAgIGhpZGVTZWxlY3Rpb25EaXY6IEhUTUxEaXZFbGVtZW50CiAgKSB7CiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5IaWRlU2VsZWN0aW9uKSB7CiAgICAgIGlmIChldmVudC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MVGV4dEFyZWFFbGVtZW50KSB7CiAgICAgICAgY29uc3QgZXZlbnRUYXJnZXQgPSBldmVudC50YXJnZXQKICAgICAgICBoaWRlU2VsZWN0aW9uRGl2LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snCiAgICAgICAgaGlkZVNlbGVjdGlvbkRpdi5zdHlsZS5oZWlnaHQgPSB0aGlzLnByb3BlcnRpZXMuSGVpZ2h0ISArIDIgKyAncHgnCiAgICAgICAgaGlkZVNlbGVjdGlvbkRpdi5zdHlsZS53aWR0aCA9IHRoaXMucHJvcGVydGllcy5XaWR0aCEgKyAyICsgJ3B4JwogICAgICAgIHRleHRhcmVhUmVmLnN0eWxlLmRpc3BsYXkgPSAnbm9uZScKICAgICAgICBsZXQgdGV4dGFyZWEgPSBldmVudFRhcmdldC52YWx1ZQogICAgICAgIGxldCBmaXJzdFBhcnQgPQogICAgICAgIHRleHRhcmVhLnNsaWNlKDAsIGV2ZW50VGFyZ2V0LnNlbGVjdGlvbkVuZCkgKwogICAgICAgICc8L3NwYW4+JyArCiAgICAgICAgdGV4dGFyZWEuc2xpY2UoZXZlbnRUYXJnZXQuc2VsZWN0aW9uRW5kICsgTWF0aC5hYnMoMCkpCiAgICAgICAgbGV0IHRleHQgPQogICAgICAgIGZpcnN0UGFydC5zbGljZSgwLCBldmVudFRhcmdldC5zZWxlY3Rpb25TdGFydCkgKwogICAgICAgICI8c3BhbiBzdHlsZT0nYmFja2dyb3VuZC1jb2xvcjpsaWdodGJsdWUnPiIgKwogICAgICAgIGZpcnN0UGFydC5zbGljZShldmVudFRhcmdldC5zZWxlY3Rpb25TdGFydCArIE1hdGguYWJzKDApKQogICAgICAgIGhpZGVTZWxlY3Rpb25EaXYuaW5uZXJIVE1MID0gdGV4dAogICAgICB9IGVsc2UgewogICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgSFRNTFRleHRBcmVhRWxlbWVudCBidXQgZm91bmQgZGlmZmVyZW50IGVsZW1lbnQnKQogICAgICB9CiAgICB9IGVsc2UgewogICAgICByZXR1cm4gdW5kZWZpbmVkCiAgICB9CiAgfQogIC8qKgogICAqQGRlc2NyaXB0aW9uIGhpZGVzIHRoZSBkaXYgd2hlbiBmb2N1cyBjb21lcyB0byB0ZXh0YXJlYSB3aGVuIGhpZGVTZWxlY3Rpb24KICAgKiBwcm9wZXJ0aWVzIGlzIGZhbHNlCiAgICogQGZ1bmN0aW9uIGhhbmRsZUNsaWNrCiAgICogQHBhcmFtIGV2ZW50IGl0cyBvZiBGb2N1c0V2ZW50CiAgICogQGV2ZW50IGNsaWNrCiAgICovCiAgaGFuZGxlQ2xpY2sgKGhpZGVTZWxlY3Rpb25EaXY6IEhUTUxEaXZFbGVtZW50KSB7CiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5IaWRlU2VsZWN0aW9uKSB7CiAgICAgIGhpZGVTZWxlY3Rpb25EaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuIHVuZGVmaW5lZAogICAgfQogIH0KICAvKioKICAgKiBAZGVzY3JpcHRpb24gaGlkZXMgZGl2IGluc3RlYWQgb2YgdGV4dGFyZWEgd2hlbiBoaWRlU2VsZWN0aW9uIGlzIGZhbHNlCiAgICogd2hlbiBoaWRlU2VsZWN0aW9uIHByb3BlcnRpZXMgaXMgdHJ1ZSB0ZXh0YXJlYSBpcyBzaG93bgogICAqIHdoZW4gaGlkZVNlbGVjdGlvbiBwcm9wZXJ0aWVzIGlzIGZhbHNlIGRpdiBpcyBzaG93bgogICAqIEBmdW5jdGlvbiBkaXZIaWRlCiAgICogQHBhcmFtIGV2ZW50IGl0cyBvZiB0eXBlIE1vdXNlRXZlbnQKICAgKiBAZXZlbnQgY2xpY2sKICAgKi8KICBkaXZIaWRlIChldmVudDogTW91c2VFdmVudCwgdGV4dGFyZWFSZWY6IEhUTUxUZXh0QXJlYUVsZW1lbnQpIHsKICAgIGlmIChldmVudC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MU3BhbkVsZW1lbnQgfHwgZXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgSFRNTERpdkVsZW1lbnQpIHsKICAgICAgKGV2ZW50LnRhcmdldCkuc3R5bGUuZGlzcGxheSA9ICdub25lJwogICAgICB0ZXh0YXJlYVJlZi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJwogICAgICBpZiAoCiAgICAgICAgKGV2ZW50LnRhcmdldCkudGFnTmFtZSA9PT0gJ1NQQU4nICYmCiAgICAgIChldmVudC50YXJnZXQpLnBhcmVudE5vZGUhLm5vZGVOYW1lID09PSAnRElWJwogICAgICApIHsKICAgICAgICAoKGV2ZW50LnRhcmdldCkKICAgICAgICAgIC5wYXJlbnROb2RlIGFzIEhUTUxFbGVtZW50KS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnCiAgICAgIH0KICAgICAgdGV4dGFyZWFSZWYuZm9jdXMoKQogICAgICB0ZXh0YXJlYVJlZi5zZWxlY3Rpb25TdGFydCA9IHRleHRhcmVhUmVmLnNlbGVjdGlvbkVuZAogICAgfQogIH0KCiAgbW91bnRlZCAoKSB7CiAgICB0aGlzLiRlbC5mb2N1cygpCiAgfQogIHJlbGVhc2VFZGl0TW9kZSAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHsKICAgIHRoaXMuJGVsLmZvY3VzKCkKICAgIHRoaXMuc2V0Q29udGVudEVkaXRhYmxlKGV2ZW50LCBmYWxzZSkKICB9CiAgZXZlbnRTdG9wcGVycyAoKSB7CiAgICBjb25zdCBldmVudFN0b3AgPSAoZXZlbnQ6IEV2ZW50KSA9PiBldmVudC5zdG9wUHJvcGFnYXRpb24oKQogICAgcmV0dXJuIHRoaXMuaXNFZGl0TW9kZSA9PT0gZmFsc2UgPyBudWxsIDogewogICAgICBrZXlkb3duOiBldmVudFN0b3AKICAgIH0KICB9Cn0K"},{"version":3,"sources":["index.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.vue","sourceRoot":"src/FormDesigner/components/atoms/FDTextBox","sourcesContent":["<template>\n  <div class=\"resp-textbox\"\n  v-on=\"eventStoppers()\"\n  @click=\"selectedItem\"\n  @mousedown=\"controlEditMode\"\n  :tabindex=\"properties.TabIndex\"\n  @keydown.enter=\"setContentEditable($event, true)\"\n  >\n    <textarea\n      data-gramm=\"false\"\n      ref=\"textareaRef\"\n      :style=\"cssStyleProperty\"\n      :tabindex=\"properties.TabIndex\"\n      :maxlength=\"properties.MaxLength !==0 ? properties.MaxLength : ''\"\n      :disabled=\"getDisableValue\"\n      :title=\"properties.ControlTipText\"\n      :readonly=\"properties.Locked\"\n      @keydown.escape.exact=\"releaseEditMode\"\n      v-cursorDirective=\"{\n        start: data.properties.CursorStartPosition,\n        end: data.properties.CursorEndPosition,\n        pwdCharType: properties.PasswordChar,\n      }\"\n      @keydown.tab=\"tabKeyBehavior\"\n      @keydown.enter=\"enterKeyBehavior\"\n      @input=\"\n        properties.PasswordChar === ''\n          ? textAndValueUpdate($event)\n          : handlePasswordChar($event)\n      \"\n      @keydown=\"properties.PasswordChar !== '' ? handleDelete($event) : null\"\n      @blur=\"handleBlur($event, textareaRef, hideSelectionDiv)\"\n      @click=\"handleClick(hideSelectionDiv)\"\n      class=\"text-box-design\"\n      :value=\"\n        properties.Value\n          | passwordFilter(properties.PasswordChar, properties.Value)\n      \"\n      @dragstart=\"dragBehavior\"\n    />\n    <div\n      ref=\"hideSelectionDiv\"\n      @click=\"divHide($event, textareaRef)\"\n      :style=\"divcssStyleProperty\"\n      :title=\"properties.ControlTipText\"\n      class=\"text-box-design\"\n    >\n      {{\n        properties.Value\n          | passwordFilter(properties.PasswordChar, properties.Value)\n      }}\n    </div>\n    <label ref=\"autoSizeTextarea\"></label>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport {\n  Component,\n  Vue,\n  Prop,\n  Ref,\n  Watch,\n  Emit,\n  Mixins\n} from 'vue-property-decorator'\nimport FdControlVue from '@/api/abstract/FormDesigner/FdControlVue'\nimport { DirectiveBinding } from 'vue/types/options'\n\n@Component({\n  name: 'FDTextBox',\n  filters: {\n    /**\n     * @description filter to show passwordChar instead of original text\n     * @function passwordFilter\n     * @param value text to be filtered\n     * @param password passwordChar value to filter the text\n     * @param text  TextBox properties Text Value\n     */\n    passwordFilter (value: string, password: string, text: string) {\n      if (password !== '' && text !== '') {\n        let filteredValue: string = ''\n        for (let index = 0; index < text.length; index++) {\n          filteredValue = filteredValue + password[0]\n        }\n        return filteredValue\n      } else {\n        return value\n      }\n    }\n  },\n  directives: {\n    cursorDirective: {\n      /**\n       * @description  called after the containing component’s VNode has updated\n       * updates selection start and end cursor positon when data model value changes\n       * to maintain cursor position\n       * @function update Hook Functions i.e, (bind, inserted, update, componentUpdated, unbind)\n       * @param event The element the directive is bound to. This can be used to directly manipulate the DOM.\n       * @param vnode The virtual node produced by Vue’s compiler\n       */\n      update (event: HTMLElement, vnode: DirectiveBinding) {\n        if (vnode.value.pwdCharType !== '') {\n          (event as HTMLFormElement).selectionStart = vnode.value.start;\n          (event as HTMLFormElement).selectionEnd = vnode.value.end\n        } else {\n          return undefined\n        }\n      }\n    }\n  }\n})\nexport default class FDTextBox extends Mixins(FdControlVue) {\n  @Ref('hideSelectionDiv') readonly hideSelectionDiv!: HTMLDivElement;\n  @Ref('autoSizeTextarea') readonly autoSizeTextarea!: HTMLLabelElement;\n  @Ref('textareaRef') textareaRef: HTMLTextAreaElement;\n  $el: HTMLDivElement\n  get getDisableValue () {\n    if (this.isRunMode || this.isEditMode) {\n      return (\n        this.properties.Enabled === false || this.properties.Locked === true\n      )\n    } else {\n      return true\n    }\n  }\n  /**\n   * @description style object is passed to :style attribute in Textarea tag\n   * dynamically changing the styles of the component based on properties\n   * @function cssStyleProperty\n   *\n   */\n  get cssStyleProperty () {\n    const controlProp = this.properties\n    const font: font = controlProp.Font\n      ? controlProp.Font\n      : {\n        FontName: 'Arial',\n        FontSize: 10,\n        FontItalic: true,\n        FontBold: true,\n        FontUnderline: true,\n        FontStrikethrough: true,\n        FontStyle: 'Arial'\n      }\n    return {\n      left: `${controlProp.Left}px`,\n      width: `${controlProp.Width}px`,\n      height: `${controlProp.Height}px`,\n      top: `${controlProp.Top}px`,\n      borderColor: controlProp.BorderStyle === 1 ? controlProp.BorderColor : '',\n      textAlign:\n        controlProp.TextAlign === 0\n          ? 'left'\n          : controlProp.TextAlign === 1\n            ? 'center'\n            : 'right',\n      backgroundColor: controlProp.BackStyle ? controlProp.BackColor : 'transparent',\n      borderLeft: controlProp.BorderStyle === 1 ? '1px solid ' + controlProp.BorderColor : controlProp.SpecialEffect === 2 ? '2px solid gray' : controlProp.SpecialEffect === 3 ? '1.5px solid gray' : controlProp.SpecialEffect === 4 ? '0.5px solid gray' : '',\n      borderRight: controlProp.BorderStyle === 1 ? '1px solid ' + controlProp.BorderColor : controlProp.SpecialEffect === 1 ? '2px solid gray' : controlProp.SpecialEffect === 4 ? '1.5px solid gray' : controlProp.SpecialEffect === 3 ? '0.5px solid gray' : '',\n      borderTop: controlProp.BorderStyle === 1 ? '1px solid ' + controlProp.BorderColor : controlProp.SpecialEffect === 2 ? '2px solid gray' : controlProp.SpecialEffect === 3 ? '1.5px solid gray' : controlProp.SpecialEffect === 4 ? '0.5px solid gray' : '',\n      borderBottom: controlProp.BorderStyle === 1 ? '1px solid ' + controlProp.BorderColor : controlProp.SpecialEffect === 1 ? '2px solid gray' : controlProp.SpecialEffect === 4 ? '1.5px solid gray' : controlProp.SpecialEffect === 3 ? '0.5px solid gray' : '',\n      whiteSpace:\n        controlProp.WordWrap && controlProp.MultiLine ? 'normal' : 'nowrap',\n      wordBreak:\n        controlProp.WordWrap && controlProp.MultiLine ? 'break-word' : 'normal',\n      color:\n        controlProp.Enabled === true ? controlProp.ForeColor : this.getEnabled,\n      cursor:\n        controlProp.MousePointer !== 0 || controlProp.MouseIcon !== ''\n          ? this.getMouseCursorData\n          : 'default',\n      fontFamily: (font.FontStyle! !== '') ? this.setFontStyle : font.FontName!,\n      fontSize: `${font.FontSize}px`,\n      fontStyle: font.FontItalic || this.isItalic ? 'italic' : '',\n      textDecoration:\n        font.FontStrikethrough === true && font.FontUnderline === true\n          ? 'underline line-through'\n          : font.FontUnderline\n            ? 'underline'\n            : font.FontStrikethrough\n              ? 'line-through'\n              : '',\n      fontWeight: font.FontBold ? 'bold' : (font.FontStyle !== '') ? this.tempWeight : '',\n      fontStretch: (font.FontStyle !== '') ? this.tempStretch : '',\n      display: controlProp.Visible ? 'block' : 'none',\n      overflowX: this.getScrollBarX,\n      overflowY: this.getScrollBarY\n      // position: 'relative'\n    }\n  }\n\n  /**\n   * @description updates the dataModel textBox object properties when user insert/delete text\n   * inside textBox when passwordChar is set, updates text and values properties of textBox with entered character\n   * @function handlePasswordChar\n   * @param event its of type TextEvent\n   * @event input\n   *\n   */\n  handlePasswordChar (event: TextEvent) {\n    let newData\n    let text = this.properties.Text!\n    let selectionDiff =\n      (this.data.properties!.CursorStartPosition as number) !==\n      (this.data.properties!.CursorEndPosition as number)\n    if (event.target instanceof HTMLTextAreaElement) {\n      if (selectionDiff) {\n        // selection\n        newData =\n        text.substring(0, this.data.properties!.CursorStartPosition as number) +\n        text.substring(this.data.properties!.CursorEndPosition as number)\n        this.updateDataModel({ propertyName: 'Text', value: newData })\n        this.updateDataModel({ propertyName: 'Value', value: newData })\n      } else if (text.length < event.target.value.length) {\n        // insertion\n        newData = [\n          text.slice(0, event.target.selectionStart - 1),\n          event.data,\n          text.slice(event.target.selectionStart - 1)\n        ].join('')\n        this.updateDataModel({ propertyName: 'Text', value: newData })\n        this.updateDataModel({ propertyName: 'Value', value: newData })\n      } else if (text.length > event.target.value.length) {\n        // deletion\n        newData = [\n          text.slice(0, event.target.selectionStart),\n          text.slice(event.target.selectionStart + 1)\n        ].join('')\n        this.updateDataModel({ propertyName: 'Text', value: newData })\n        this.updateDataModel({ propertyName: 'Value', value: newData })\n      }\n      this.updateDataModel({\n        propertyName: 'CursorStartPosition',\n        value: event.target.selectionStart\n      })\n      this.updateDataModel({\n        propertyName: 'CursorEndPosition',\n        value: event.target.selectionEnd\n      })\n    } else {\n      throw new Error('Expected HTMLTextAreaElement but found different element')\n    }\n  }\n  /**\n   * @description style object is passed to :style attribute in div tag\n   * dynamically changing the styles of the component based on cssStyleProperty of\n   * textarea\n   * @function divcssStyleProperty\n   *\n   */\n  get divcssStyleProperty () {\n    const styleObject = this.cssStyleProperty\n    return {\n      ...styleObject,\n      display: 'none',\n      paddingTop: '2px',\n      paddingLeft: '2px'\n    }\n  }\n  /**\n   * @description When user enters ctrl + enter cursor moves to next line\n   * @function handleCtrlEnter\n   * @param el its of type HTMLTextAreaElement\n   * @param text new line character\n   * @event keydown.enter.ctrl\n   */\n  handleCtrlEnter (el : HTMLTextAreaElement, text: string) {\n    el.focus()\n    if (typeof el.selectionStart === 'number' &&\n            typeof el.selectionEnd === 'number') {\n      const val = el.value\n      const selStart = el.selectionStart\n      el.value = val.slice(0, selStart) + text + val.slice(el.selectionEnd)\n      el.selectionEnd = el.selectionStart = selStart + text.length\n    }\n  }\n  /**\n   * @description EnterKeyBehavior - if true when enter is pressed while editing the cursor moves to next line\n   *  if false the cursor remains in same place\n   * @function enterKeyBehavior\n   * @param event its of type KeyboardEvent\n   * @event keydown.enter\n   */\n  enterKeyBehavior (event: KeyboardEvent): boolean {\n    if (this.properties.MultiLine) {\n      if (event.ctrlKey) {\n        this.handleCtrlEnter(this.textareaRef, '\\n')\n        return true\n      } else if (this.properties.EnterKeyBehavior && this.properties.MultiLine) {\n        return true\n      } else if (event.shiftKey) {\n        return true\n      }\n    }\n    event.preventDefault()\n    return false\n  }\n\n  /**\n   * @description  specifies how the control responds to the TAB key\n   * when  TabKeyBehavior true in textBox tab spaces are added on press of tab Key\n   * when TabKeyBehavior false in textBox pressing tab moves focus to next controls\n   * @function tabKeyBehavior\n   * @param event its of type MouseEvent\n   * @event keydown.tab\n   */\n  tabKeyBehavior (event: KeyboardEvent): boolean {\n    if (this.properties.TabKeyBehavior) {\n      const TABKEY = 9\n      if (event.target instanceof HTMLTextAreaElement) {\n        event.stopPropagation()\n        const eventTaget = event.target\n        const selectionStart = eventTaget.selectionStart\n        const selectionEnd = eventTaget.selectionEnd\n        const value = eventTaget.value\n        if (event.keyCode === TABKEY) {\n          (event.target).value =\n          value.substring(0, selectionStart) +\n          '\\t' +\n          value.substring(selectionEnd)\n          event.preventDefault()\n        }\n        (event.target).selectionStart = selectionStart + 1;\n        (event.target).selectionEnd = (event.target).selectionStart\n        return false\n      } else {\n        throw new Error('Expected HTMLTextAreaElement but found different element')\n      }\n    } else {\n      return true\n    }\n  }\n  /**\n   * @description updates the dataModel textBox object properties when user insert/delete text\n   * inside textBox, updates text and values properties of textBox\n   * @function textAndValueUpdate\n   * @param event its of type InputEvent\n   * @event input\n   *\n   */\n  textAndValueUpdate (event: InputEvent) {\n    const propData = this.properties\n    if (event.target instanceof HTMLTextAreaElement) {\n      this.updateDataModel({\n        propertyName: 'Value',\n        value: (event.target).value\n      })\n      this.updateDataModel({\n        propertyName: 'Text',\n        value: (event.target).value\n      })\n      if (this.properties.ControlSource !== '') {\n        this.updateDataModelExtraData({\n          propertyName: 'ControlSourceValue',\n          value: (event.target).value\n        })\n      } else {\n        return undefined\n      }\n    } else {\n      throw new Error('Expected HTMLTextAreaElement but found different element')\n    }\n    if (this.properties.AutoSize) {\n      this.updateAutoSize()\n    }\n  }\n\n  @Watch('properties.Font.FontSize', { deep: true })\n  autoSizeValidateOnFontChange () {\n    if (this.properties.AutoSize) {\n      this.updateAutoSize()\n    }\n  }\n\n  @Watch('properties.WordWrap', { deep: true })\n  autoSizeValidateOnWordWrapChange () {\n    if (this.properties.AutoSize) {\n      this.updateAutoSize()\n    }\n  }\n\n  /**\n   * @description dragBehavior - if true when dragging\n   *  if false the cursor remains in same place\n   * @function dragBehavior\n   * @param event its of type KeyboardEvent\n   * @event dragStart\n   */\n  dragBehavior (e: Event) {\n    if (this.properties.DragBehavior) {\n      return true\n    }\n    e.preventDefault()\n  }\n\n  /**\n   * @override\n   */\n  @Watch('properties.AutoSize', { deep: true })\n  updateAutoSize () {\n    if (this.properties.AutoSize === true) {\n      this.$nextTick(() => {\n        const textareaRef: HTMLTextAreaElement = this.textareaRef\n        // replication of stype attribute to Label tag for autoSize property to work\n        let tempLabel: HTMLLabelElement = this.autoSizeTextarea\n        tempLabel.style.display = 'inline'\n        tempLabel.style.fontStyle = textareaRef.style.fontStyle\n        tempLabel.style.fontSize =\n            parseInt(textareaRef.style.fontSize) + 'px'\n        tempLabel.style.whiteSpace = textareaRef.style.whiteSpace\n        tempLabel.style.wordBreak = textareaRef.style.wordBreak\n        tempLabel.style.fontWeight = textareaRef.style.fontWeight\n        tempLabel.style.width = textareaRef.style.width\n        tempLabel.style.height = textareaRef.style.height\n        tempLabel.innerText = textareaRef.value\n        this.updateDataModel({\n          propertyName: 'Width',\n          value: tempLabel.offsetWidth + 5\n        })\n        this.updateDataModel({\n          propertyName: 'Height',\n          value: tempLabel.offsetHeight + 5\n        })\n        tempLabel.innerText = ''\n        tempLabel.style.display = 'none'\n      })\n    } else {\n      return undefined\n    }\n  }\n\n  created () {\n    const propData: controlData = this.data\n    if (propData.properties.ControlSource !== '') {\n      const controlSourceValue = propData.extraDatas!.ControlSourceValue\n      this.updateDataModel({\n        propertyName: 'Value',\n        value: controlSourceValue\n      })\n      this.updateDataModel({ propertyName: 'Text', value: controlSourceValue })\n    }\n  }\n\n  /**\n  * @description watches ControlSource property\n  * @function updateControlSourceValue\n  * @param oldVal previous string value\n  * @param newVal  new/changed string value\n  */\n  @Watch('properties.ControlSource', { deep: true })\n  updateControlSourceValue (newVal: string, oldVal: string) {\n    const propData: controlData = this.data\n    if (propData.properties.ControlSource !== '') {\n      const controlSourceValue = propData.extraDatas!.ControlSourceValue\n      this.updateDataModel({\n        propertyName: 'Value',\n        value: controlSourceValue\n      })\n      this.updateDataModel({ propertyName: 'Text', value: controlSourceValue })\n    } else {\n      this.updateDataModel({\n        propertyName: 'Value',\n        value: ''\n      })\n      this.updateDataModel({ propertyName: 'Text', value: '' })\n    }\n  }\n  /**\n   * @description keep tracks of key press and selectionStart and selectionEnd\n   * updates extra property CursorStartPosition and CursorEndPosition which is required\n   * when user insert, update or delete text in textBox\n   * @function handleDelete\n   * @param event it is of type KeyboardEvent\n   * @event keydown\n   */\n  handleDelete (event: KeyboardEvent) {\n    if (event.target instanceof HTMLTextAreaElement) {\n      if (event.keyCode === 8) {\n        this.updateDataModel({\n          propertyName: 'CursorStartPosition',\n          value: (event.target).selectionStart!\n        })\n        this.updateDataModel({\n          propertyName: 'CursorEndPosition',\n          value: (event.target).selectionEnd!\n        })\n      } else {\n        return undefined\n      }\n    } else {\n      throw new Error('Expected HTMLTextAreaElement but found different element')\n    }\n  }\n  /**\n   * @description  show selection when TextBox loses focus\n   * when HideSelection is false selection is show if user selects any text\n   * @function handleBlur\n   * @event blur\n   *\n   */\n  handleBlur (\n    event: TextEvent,\n    textareaRef: HTMLTextAreaElement,\n    hideSelectionDiv: HTMLDivElement\n  ) {\n    if (!this.properties.HideSelection) {\n      if (event.target instanceof HTMLTextAreaElement) {\n        const eventTarget = event.target\n        hideSelectionDiv.style.display = 'block'\n        hideSelectionDiv.style.height = this.properties.Height! + 2 + 'px'\n        hideSelectionDiv.style.width = this.properties.Width! + 2 + 'px'\n        textareaRef.style.display = 'none'\n        let textarea = eventTarget.value\n        let firstPart =\n        textarea.slice(0, eventTarget.selectionEnd) +\n        '</span>' +\n        textarea.slice(eventTarget.selectionEnd + Math.abs(0))\n        let text =\n        firstPart.slice(0, eventTarget.selectionStart) +\n        \"<span style='background-color:lightblue'>\" +\n        firstPart.slice(eventTarget.selectionStart + Math.abs(0))\n        hideSelectionDiv.innerHTML = text\n      } else {\n        throw new Error('Expected HTMLTextAreaElement but found different element')\n      }\n    } else {\n      return undefined\n    }\n  }\n  /**\n   *@description hides the div when focus comes to textarea when hideSelection\n   * properties is false\n   * @function handleClick\n   * @param event its of FocusEvent\n   * @event click\n   */\n  handleClick (hideSelectionDiv: HTMLDivElement) {\n    if (!this.properties.HideSelection) {\n      hideSelectionDiv.style.display = 'none'\n    } else {\n      return undefined\n    }\n  }\n  /**\n   * @description hides div instead of textarea when hideSelection is false\n   * when hideSelection properties is true textarea is shown\n   * when hideSelection properties is false div is shown\n   * @function divHide\n   * @param event its of type MouseEvent\n   * @event click\n   */\n  divHide (event: MouseEvent, textareaRef: HTMLTextAreaElement) {\n    if (event.target instanceof HTMLSpanElement || event.target instanceof HTMLDivElement) {\n      (event.target).style.display = 'none'\n      textareaRef.style.display = 'block'\n      if (\n        (event.target).tagName === 'SPAN' &&\n      (event.target).parentNode!.nodeName === 'DIV'\n      ) {\n        ((event.target)\n          .parentNode as HTMLElement).style.display = 'none'\n      }\n      textareaRef.focus()\n      textareaRef.selectionStart = textareaRef.selectionEnd\n    }\n  }\n\n  mounted () {\n    this.$el.focus()\n  }\n  releaseEditMode (event: KeyboardEvent) {\n    this.$el.focus()\n    this.setContentEditable(event, false)\n  }\n  eventStoppers () {\n    const eventStop = (event: Event) => event.stopPropagation()\n    return this.isEditMode === false ? null : {\n      keydown: eventStop\n    }\n  }\n}\n</script>\n\n<style scoped>\n.text-box-design {\n  width: 0px;\n  height: 0px;\n  left: 0px;\n  top: 0px;\n  resize: none;\n  overflow: hidden;\n  box-sizing: border-box;\n}\n.text-box-design:focus {\n  outline: none;\n}\n.text-box-design::selection {\n  background: lightblue;\n}\n</style>\n"]}]}